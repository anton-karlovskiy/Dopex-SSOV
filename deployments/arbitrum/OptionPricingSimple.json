{
  "address": "0x2b99e3D67dAD973c1B9747Da742B7E26c8Bdd67B",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "_volatilityCap",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "_minOptionPricePercentage",
          "type": "uint256"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "constructor"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "previousOwner",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "newOwner",
          "type": "address"
        }
      ],
      "name": "OwnershipTransferred",
      "type": "event"
    },
    {
      "inputs": [
        {
          "internalType": "bool",
          "name": "isPut",
          "type": "bool"
        },
        {
          "internalType": "uint256",
          "name": "expiry",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "strike",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "lastPrice",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "volatility",
          "type": "uint256"
        }
      ],
      "name": "getOptionPrice",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "minOptionPricePercentage",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "owner",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "renounceOwnership",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "newOwner",
          "type": "address"
        }
      ],
      "name": "transferOwnership",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "_minOptionPricePercentage",
          "type": "uint256"
        }
      ],
      "name": "updateMinOptionPricePercentage",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "_volatilityCap",
          "type": "uint256"
        }
      ],
      "name": "updateVolatilityCap",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "volatilityCap",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    }
  ],
  "transactionHash": "0xa9f3f14c58878b7e5b1bcde06fa1cca345df77d280b188945205af02eec80b69",
  "receipt": {
    "to": null,
    "from": "0xDe485812E28824e542B9c2270B6b8eD9232B7D0b",
    "contractAddress": "0x2b99e3D67dAD973c1B9747Da742B7E26c8Bdd67B",
    "transactionIndex": 0,
    "gasUsed": "89686672",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000800000000000000000800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000020000000000000000000800000000000000000000000000000000400004000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000002000000000000000100000000000000000000000000000000020000000000000000000000000000000000000000000040000000000000000000000",
    "blockHash": "0xff5e384c7aa5f66b9697e7a1c1e369f69520c6fe5999a1b7dcaf6d27f0f8ee5f",
    "transactionHash": "0xa9f3f14c58878b7e5b1bcde06fa1cca345df77d280b188945205af02eec80b69",
    "logs": [
      {
        "transactionIndex": 0,
        "blockNumber": 2635517,
        "transactionHash": "0xa9f3f14c58878b7e5b1bcde06fa1cca345df77d280b188945205af02eec80b69",
        "address": "0x2b99e3D67dAD973c1B9747Da742B7E26c8Bdd67B",
        "topics": [
          "0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0",
          "0x0000000000000000000000000000000000000000000000000000000000000000",
          "0x000000000000000000000000de485812e28824e542b9c2270b6b8ed9232b7d0b"
        ],
        "data": "0x",
        "logIndex": 0,
        "blockHash": "0xff5e384c7aa5f66b9697e7a1c1e369f69520c6fe5999a1b7dcaf6d27f0f8ee5f"
      }
    ],
    "blockNumber": 2635517,
    "cumulativeGasUsed": "70370352",
    "status": 1,
    "byzantium": true
  },
  "args": [
    "1000",
    "1"
  ],
  "solcInputHash": "13251561be0841762d466ec3898cf295",
  "metadata": "{\"compiler\":{\"version\":\"0.8.4+commit.c7e474f2\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_volatilityCap\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_minOptionPricePercentage\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"isPut\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"expiry\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"strike\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"volatility\",\"type\":\"uint256\"}],\"name\":\"getOptionPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minOptionPricePercentage\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_minOptionPricePercentage\",\"type\":\"uint256\"}],\"name\":\"updateMinOptionPricePercentage\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_volatilityCap\",\"type\":\"uint256\"}],\"name\":\"updateVolatilityCap\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"volatilityCap\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{\"getOptionPrice(bool,uint256,uint256,uint256,uint256)\":{\"params\":{\"expiry\":\"expiry timestamp\",\"isPut\":\"is put option\",\"lastPrice\":\"current price\",\"strike\":\"strike price\",\"volatility\":\"volatility\"}},\"owner()\":{\"details\":\"Returns the address of the current owner.\"},\"renounceOwnership()\":{\"details\":\"Leaves the contract without owner. It will not be possible to call `onlyOwner` functions anymore. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby removing any functionality that is only available to the owner.\"},\"transferOwnership(address)\":{\"details\":\"Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner.\"},\"updateMinOptionPricePercentage(uint256)\":{\"params\":{\"_minOptionPricePercentage\":\"the new %\"},\"returns\":{\"_0\":\"whether % was updated\"}},\"updateVolatilityCap(uint256)\":{\"params\":{\"_volatilityCap\":\"the new volatility cap\"},\"returns\":{\"_0\":\"whether volatility cap was updated\"}}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"getOptionPrice(bool,uint256,uint256,uint256,uint256)\":{\"notice\":\"computes the option price (with liquidity multiplier)\"},\"updateMinOptionPricePercentage(uint256)\":{\"notice\":\"updates % of the price of asset which is the minimum option price possible\"},\"updateVolatilityCap(uint256)\":{\"notice\":\"updates volatility cap for an option pool\"}},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/pricing/OptionPricingSimple.sol\":\"OptionPricingSimple\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[]},\"sources\":{\"@openzeppelin/contracts/access/Ownable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor () {\\n        address msgSender = _msgSender();\\n        _owner = msgSender;\\n        emit OwnershipTransferred(address(0), msgSender);\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        emit OwnershipTransferred(_owner, address(0));\\n        _owner = address(0);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        emit OwnershipTransferred(_owner, newOwner);\\n        _owner = newOwner;\\n    }\\n}\\n\",\"keccak256\":\"0x1cae4f85f114ff17b90414f5da67365b1d00337abb5bce9bf944eb78a2c0673c\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/Context.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/*\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\\n        return msg.data;\\n    }\\n}\\n\",\"keccak256\":\"0xf930d2df426bfcfc1f7415be724f04081c96f4fb9ec8d0e3a521c07692dface0\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/math/SafeMath.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n// CAUTION\\n// This version of SafeMath should only be used with Solidity 0.8 or later,\\n// because it relies on the compiler's built in overflow checks.\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations.\\n *\\n * NOTE: `SafeMath` is no longer needed starting with Solidity 0.8. The compiler\\n * now has built in overflow checking.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            uint256 c = a + b;\\n            if (c < a) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b > a) return (false, 0);\\n            return (true, a - b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n            // benefit is lost if 'b' is also tested.\\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n            if (a == 0) return (true, 0);\\n            uint256 c = a * b;\\n            if (c / a != b) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a / b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a % b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a + b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a * b;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a % b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {trySub}.\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        unchecked {\\n            require(b <= a, errorMessage);\\n            return a - b;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        unchecked {\\n            require(b > 0, errorMessage);\\n            return a / b;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting with custom message when dividing by zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryMod}.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        unchecked {\\n            require(b > 0, errorMessage);\\n            return a % b;\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x2526b7c6a366fc211bbc176078ab02b83833e7682abcc5b3bed9d700b34e2a3e\",\"license\":\"MIT\"},\"contracts/external/libraries/ABDKMathQuad.sol\":{\"content\":\"// SPDX-License-Identifier: BSD-4-Clause\\n/*\\n * ABDK Math Quad Smart Contract Library.  Copyright \\u00a9 2019 by ABDK Consulting.\\n * Author: Mikhail Vladimirov <mikhail.vladimirov@gmail.com>\\n */\\npragma solidity ^0.8.0;\\n\\n/**\\n * Smart contract library of mathematical functions operating with IEEE 754\\n * quadruple-precision binary floating-point numbers (quadruple precision\\n * numbers).  As long as quadruple precision numbers are 16-bytes long, they are\\n * represented by bytes16 type.\\n */\\nlibrary ABDKMathQuad {\\n  /*\\n   * 0.\\n   */\\n  bytes16 private constant POSITIVE_ZERO = 0x00000000000000000000000000000000;\\n\\n  /*\\n   * -0.\\n   */\\n  bytes16 private constant NEGATIVE_ZERO = 0x80000000000000000000000000000000;\\n\\n  /*\\n   * +Infinity.\\n   */\\n  bytes16 private constant POSITIVE_INFINITY =\\n    0x7FFF0000000000000000000000000000;\\n\\n  /*\\n   * -Infinity.\\n   */\\n  bytes16 private constant NEGATIVE_INFINITY =\\n    0xFFFF0000000000000000000000000000;\\n\\n  /*\\n   * Canonical NaN value.\\n   */\\n  bytes16 private constant NaN = 0x7FFF8000000000000000000000000000;\\n\\n  /**\\n   * Convert signed 256-bit integer number into quadruple precision number.\\n   *\\n   * @param x signed 256-bit integer number\\n   * @return quadruple precision number\\n   */\\n  function fromInt(int256 x) internal pure returns (bytes16) {\\n    unchecked {\\n      if (x == 0) return bytes16(0);\\n      else {\\n        // We rely on overflow behavior here\\n        uint256 result = uint256(x > 0 ? x : -x);\\n\\n        uint256 msb = mostSignificantBit(result);\\n        if (msb < 112) result <<= 112 - msb;\\n        else if (msb > 112) result >>= msb - 112;\\n\\n        result =\\n          (result & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF) |\\n          ((16383 + msb) << 112);\\n        if (x < 0) result |= 0x80000000000000000000000000000000;\\n\\n        return bytes16(uint128(result));\\n      }\\n    }\\n  }\\n\\n  /**\\n   * Convert quadruple precision number into signed 256-bit integer number\\n   * rounding towards zero.  Revert on overflow.\\n   *\\n   * @param x quadruple precision number\\n   * @return signed 256-bit integer number\\n   */\\n  function toInt(bytes16 x) internal pure returns (int256) {\\n    unchecked {\\n      uint256 exponent = (uint128(x) >> 112) & 0x7FFF;\\n\\n      require(exponent <= 16638); // Overflow\\n      if (exponent < 16383) return 0; // Underflow\\n\\n      uint256 result = (uint256(uint128(x)) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF) |\\n        0x10000000000000000000000000000;\\n\\n      if (exponent < 16495) result >>= 16495 - exponent;\\n      else if (exponent > 16495) result <<= exponent - 16495;\\n\\n      if (uint128(x) >= 0x80000000000000000000000000000000) {\\n        // Negative\\n        require(\\n          result <=\\n            0x8000000000000000000000000000000000000000000000000000000000000000\\n        );\\n        return -int256(result); // We rely on overflow behavior here\\n      } else {\\n        require(\\n          result <=\\n            0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\\n        );\\n        return int256(result);\\n      }\\n    }\\n  }\\n\\n  /**\\n   * Convert unsigned 256-bit integer number into quadruple precision number.\\n   *\\n   * @param x unsigned 256-bit integer number\\n   * @return quadruple precision number\\n   */\\n  function fromUInt(uint256 x) internal pure returns (bytes16) {\\n    unchecked {\\n      if (x == 0) return bytes16(0);\\n      else {\\n        uint256 result = x;\\n\\n        uint256 msb = mostSignificantBit(result);\\n        if (msb < 112) result <<= 112 - msb;\\n        else if (msb > 112) result >>= msb - 112;\\n\\n        result =\\n          (result & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF) |\\n          ((16383 + msb) << 112);\\n\\n        return bytes16(uint128(result));\\n      }\\n    }\\n  }\\n\\n  /**\\n   * Convert quadruple precision number into unsigned 256-bit integer number\\n   * rounding towards zero.  Revert on underflow.  Note, that negative floating\\n   * point numbers in range (-1.0 .. 0.0) may be converted to unsigned integer\\n   * without error, because they are rounded to zero.\\n   *\\n   * @param x quadruple precision number\\n   * @return unsigned 256-bit integer number\\n   */\\n  function toUInt(bytes16 x) internal pure returns (uint256) {\\n    unchecked {\\n      uint256 exponent = (uint128(x) >> 112) & 0x7FFF;\\n\\n      if (exponent < 16383) return 0; // Underflow\\n\\n      require(uint128(x) < 0x80000000000000000000000000000000); // Negative\\n\\n      require(exponent <= 16638); // Overflow\\n      uint256 result = (uint256(uint128(x)) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF) |\\n        0x10000000000000000000000000000;\\n\\n      if (exponent < 16495) result >>= 16495 - exponent;\\n      else if (exponent > 16495) result <<= exponent - 16495;\\n\\n      return result;\\n    }\\n  }\\n\\n  /**\\n   * Convert signed 128.128 bit fixed point number into quadruple precision\\n   * number.\\n   *\\n   * @param x signed 128.128 bit fixed point number\\n   * @return quadruple precision number\\n   */\\n  function from128x128(int256 x) internal pure returns (bytes16) {\\n    unchecked {\\n      if (x == 0) return bytes16(0);\\n      else {\\n        // We rely on overflow behavior here\\n        uint256 result = uint256(x > 0 ? x : -x);\\n\\n        uint256 msb = mostSignificantBit(result);\\n        if (msb < 112) result <<= 112 - msb;\\n        else if (msb > 112) result >>= msb - 112;\\n\\n        result =\\n          (result & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF) |\\n          ((16255 + msb) << 112);\\n        if (x < 0) result |= 0x80000000000000000000000000000000;\\n\\n        return bytes16(uint128(result));\\n      }\\n    }\\n  }\\n\\n  /**\\n   * Convert quadruple precision number into signed 128.128 bit fixed point\\n   * number.  Revert on overflow.\\n   *\\n   * @param x quadruple precision number\\n   * @return signed 128.128 bit fixed point number\\n   */\\n  function to128x128(bytes16 x) internal pure returns (int256) {\\n    unchecked {\\n      uint256 exponent = (uint128(x) >> 112) & 0x7FFF;\\n\\n      require(exponent <= 16510); // Overflow\\n      if (exponent < 16255) return 0; // Underflow\\n\\n      uint256 result = (uint256(uint128(x)) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF) |\\n        0x10000000000000000000000000000;\\n\\n      if (exponent < 16367) result >>= 16367 - exponent;\\n      else if (exponent > 16367) result <<= exponent - 16367;\\n\\n      if (uint128(x) >= 0x80000000000000000000000000000000) {\\n        // Negative\\n        require(\\n          result <=\\n            0x8000000000000000000000000000000000000000000000000000000000000000\\n        );\\n        return -int256(result); // We rely on overflow behavior here\\n      } else {\\n        require(\\n          result <=\\n            0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\\n        );\\n        return int256(result);\\n      }\\n    }\\n  }\\n\\n  /**\\n   * Convert signed 64.64 bit fixed point number into quadruple precision\\n   * number.\\n   *\\n   * @param x signed 64.64 bit fixed point number\\n   * @return quadruple precision number\\n   */\\n  function from64x64(int128 x) internal pure returns (bytes16) {\\n    unchecked {\\n      if (x == 0) return bytes16(0);\\n      else {\\n        // We rely on overflow behavior here\\n        uint256 result = uint128(x > 0 ? x : -x);\\n\\n        uint256 msb = mostSignificantBit(result);\\n        if (msb < 112) result <<= 112 - msb;\\n        else if (msb > 112) result >>= msb - 112;\\n\\n        result =\\n          (result & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF) |\\n          ((16319 + msb) << 112);\\n        if (x < 0) result |= 0x80000000000000000000000000000000;\\n\\n        return bytes16(uint128(result));\\n      }\\n    }\\n  }\\n\\n  /**\\n   * Convert quadruple precision number into signed 64.64 bit fixed point\\n   * number.  Revert on overflow.\\n   *\\n   * @param x quadruple precision number\\n   * @return signed 64.64 bit fixed point number\\n   */\\n  function to64x64(bytes16 x) internal pure returns (int128) {\\n    unchecked {\\n      uint256 exponent = (uint128(x) >> 112) & 0x7FFF;\\n\\n      require(exponent <= 16446); // Overflow\\n      if (exponent < 16319) return 0; // Underflow\\n\\n      uint256 result = (uint256(uint128(x)) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF) |\\n        0x10000000000000000000000000000;\\n\\n      if (exponent < 16431) result >>= 16431 - exponent;\\n      else if (exponent > 16431) result <<= exponent - 16431;\\n\\n      if (uint128(x) >= 0x80000000000000000000000000000000) {\\n        // Negative\\n        require(result <= 0x80000000000000000000000000000000);\\n        return -int128(int256(result)); // We rely on overflow behavior here\\n      } else {\\n        require(result <= 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\\n        return int128(int256(result));\\n      }\\n    }\\n  }\\n\\n  /**\\n   * Convert octuple precision number into quadruple precision number.\\n   *\\n   * @param x octuple precision number\\n   * @return quadruple precision number\\n   */\\n  function fromOctuple(bytes32 x) internal pure returns (bytes16) {\\n    unchecked {\\n      bool negative = x &\\n        0x8000000000000000000000000000000000000000000000000000000000000000 >\\n        0;\\n\\n      uint256 exponent = (uint256(x) >> 236) & 0x7FFFF;\\n      uint256 significand = uint256(x) &\\n        0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n\\n      if (exponent == 0x7FFFF) {\\n        if (significand > 0) return NaN;\\n        else return negative ? NEGATIVE_INFINITY : POSITIVE_INFINITY;\\n      }\\n\\n      if (exponent > 278526)\\n        return negative ? NEGATIVE_INFINITY : POSITIVE_INFINITY;\\n      else if (exponent < 245649)\\n        return negative ? NEGATIVE_ZERO : POSITIVE_ZERO;\\n      else if (exponent < 245761) {\\n        significand =\\n          (significand |\\n            0x100000000000000000000000000000000000000000000000000000000000) >>\\n          (245885 - exponent);\\n        exponent = 0;\\n      } else {\\n        significand >>= 124;\\n        exponent -= 245760;\\n      }\\n\\n      uint128 result = uint128(significand | (exponent << 112));\\n      if (negative) result |= 0x80000000000000000000000000000000;\\n\\n      return bytes16(result);\\n    }\\n  }\\n\\n  /**\\n   * Convert quadruple precision number into octuple precision number.\\n   *\\n   * @param x quadruple precision number\\n   * @return octuple precision number\\n   */\\n  function toOctuple(bytes16 x) internal pure returns (bytes32) {\\n    unchecked {\\n      uint256 exponent = (uint128(x) >> 112) & 0x7FFF;\\n\\n      uint256 result = uint128(x) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n\\n      if (exponent == 0x7FFF)\\n        exponent = 0x7FFFF; // Infinity or NaN\\n      else if (exponent == 0) {\\n        if (result > 0) {\\n          uint256 msb = mostSignificantBit(result);\\n          result =\\n            (result << (236 - msb)) &\\n            0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n          exponent = 245649 + msb;\\n        }\\n      } else {\\n        result <<= 124;\\n        exponent += 245760;\\n      }\\n\\n      result |= exponent << 236;\\n      if (uint128(x) >= 0x80000000000000000000000000000000)\\n        result |= 0x8000000000000000000000000000000000000000000000000000000000000000;\\n\\n      return bytes32(result);\\n    }\\n  }\\n\\n  /**\\n   * Convert double precision number into quadruple precision number.\\n   *\\n   * @param x double precision number\\n   * @return quadruple precision number\\n   */\\n  function fromDouble(bytes8 x) internal pure returns (bytes16) {\\n    unchecked {\\n      uint256 exponent = (uint64(x) >> 52) & 0x7FF;\\n\\n      uint256 result = uint64(x) & 0xFFFFFFFFFFFFF;\\n\\n      if (exponent == 0x7FF)\\n        exponent = 0x7FFF; // Infinity or NaN\\n      else if (exponent == 0) {\\n        if (result > 0) {\\n          uint256 msb = mostSignificantBit(result);\\n          result = (result << (112 - msb)) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n          exponent = 15309 + msb;\\n        }\\n      } else {\\n        result <<= 60;\\n        exponent += 15360;\\n      }\\n\\n      result |= exponent << 112;\\n      if (x & 0x8000000000000000 > 0)\\n        result |= 0x80000000000000000000000000000000;\\n\\n      return bytes16(uint128(result));\\n    }\\n  }\\n\\n  /**\\n   * Convert quadruple precision number into double precision number.\\n   *\\n   * @param x quadruple precision number\\n   * @return double precision number\\n   */\\n  function toDouble(bytes16 x) internal pure returns (bytes8) {\\n    unchecked {\\n      bool negative = uint128(x) >= 0x80000000000000000000000000000000;\\n\\n      uint256 exponent = (uint128(x) >> 112) & 0x7FFF;\\n      uint256 significand = uint128(x) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n\\n      if (exponent == 0x7FFF) {\\n        if (significand > 0) return 0x7FF8000000000000;\\n        // NaN\\n        else\\n          return\\n            negative\\n              ? bytes8(0xFFF0000000000000) // -Infinity\\n              : bytes8(0x7FF0000000000000); // Infinity\\n      }\\n\\n      if (exponent > 17406)\\n        return\\n          negative\\n            ? bytes8(0xFFF0000000000000) // -Infinity\\n            : bytes8(0x7FF0000000000000);\\n      // Infinity\\n      else if (exponent < 15309)\\n        return\\n          negative\\n            ? bytes8(0x8000000000000000) // -0\\n            : bytes8(0x0000000000000000);\\n      // 0\\n      else if (exponent < 15361) {\\n        significand =\\n          (significand | 0x10000000000000000000000000000) >>\\n          (15421 - exponent);\\n        exponent = 0;\\n      } else {\\n        significand >>= 60;\\n        exponent -= 15360;\\n      }\\n\\n      uint64 result = uint64(significand | (exponent << 52));\\n      if (negative) result |= 0x8000000000000000;\\n\\n      return bytes8(result);\\n    }\\n  }\\n\\n  /**\\n   * Test whether given quadruple precision number is NaN.\\n   *\\n   * @param x quadruple precision number\\n   * @return true if x is NaN, false otherwise\\n   */\\n  function isNaN(bytes16 x) internal pure returns (bool) {\\n    unchecked {\\n      return\\n        uint128(x) & 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF >\\n        0x7FFF0000000000000000000000000000;\\n    }\\n  }\\n\\n  /**\\n   * Test whether given quadruple precision number is positive or negative\\n   * infinity.\\n   *\\n   * @param x quadruple precision number\\n   * @return true if x is positive or negative infinity, false otherwise\\n   */\\n  function isInfinity(bytes16 x) internal pure returns (bool) {\\n    unchecked {\\n      return\\n        uint128(x) & 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF ==\\n        0x7FFF0000000000000000000000000000;\\n    }\\n  }\\n\\n  /**\\n   * Calculate sign of x, i.e. -1 if x is negative, 0 if x if zero, and 1 if x\\n   * is positive.  Note that sign (-0) is zero.  Revert if x is NaN.\\n   *\\n   * @param x quadruple precision number\\n   * @return sign of x\\n   */\\n  function sign(bytes16 x) internal pure returns (int8) {\\n    unchecked {\\n      uint128 absoluteX = uint128(x) & 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n\\n      require(absoluteX <= 0x7FFF0000000000000000000000000000); // Not NaN\\n\\n      if (absoluteX == 0) return 0;\\n      else if (uint128(x) >= 0x80000000000000000000000000000000) return -1;\\n      else return 1;\\n    }\\n  }\\n\\n  /**\\n   * Calculate sign (x - y).  Revert if either argument is NaN, or both\\n   * arguments are infinities of the same sign.\\n   *\\n   * @param x quadruple precision number\\n   * @param y quadruple precision number\\n   * @return sign (x - y)\\n   */\\n  function cmp(bytes16 x, bytes16 y) internal pure returns (int8) {\\n    unchecked {\\n      uint128 absoluteX = uint128(x) & 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n\\n      require(absoluteX <= 0x7FFF0000000000000000000000000000); // Not NaN\\n\\n      uint128 absoluteY = uint128(y) & 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n\\n      require(absoluteY <= 0x7FFF0000000000000000000000000000); // Not NaN\\n\\n      // Not infinities of the same sign\\n      require(x != y || absoluteX < 0x7FFF0000000000000000000000000000);\\n\\n      if (x == y) return 0;\\n      else {\\n        bool negativeX = uint128(x) >= 0x80000000000000000000000000000000;\\n        bool negativeY = uint128(y) >= 0x80000000000000000000000000000000;\\n\\n        if (negativeX) {\\n          if (negativeY) return absoluteX > absoluteY ? -1 : int8(1);\\n          else return -1;\\n        } else {\\n          if (negativeY) return 1;\\n          else return absoluteX > absoluteY ? int8(1) : -1;\\n        }\\n      }\\n    }\\n  }\\n\\n  /**\\n   * Test whether x equals y.  NaN, infinity, and -infinity are not equal to\\n   * anything.\\n   *\\n   * @param x quadruple precision number\\n   * @param y quadruple precision number\\n   * @return true if x equals to y, false otherwise\\n   */\\n  function eq(bytes16 x, bytes16 y) internal pure returns (bool) {\\n    unchecked {\\n      if (x == y) {\\n        return\\n          uint128(x) & 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF <\\n          0x7FFF0000000000000000000000000000;\\n      } else return false;\\n    }\\n  }\\n\\n  /**\\n   * Calculate x + y.  Special values behave in the following way:\\n   *\\n   * NaN + x = NaN for any x.\\n   * Infinity + x = Infinity for any finite x.\\n   * -Infinity + x = -Infinity for any finite x.\\n   * Infinity + Infinity = Infinity.\\n   * -Infinity + -Infinity = -Infinity.\\n   * Infinity + -Infinity = -Infinity + Infinity = NaN.\\n   *\\n   * @param x quadruple precision number\\n   * @param y quadruple precision number\\n   * @return quadruple precision number\\n   */\\n  function add(bytes16 x, bytes16 y) internal pure returns (bytes16) {\\n    unchecked {\\n      uint256 xExponent = (uint128(x) >> 112) & 0x7FFF;\\n      uint256 yExponent = (uint128(y) >> 112) & 0x7FFF;\\n\\n      if (xExponent == 0x7FFF) {\\n        if (yExponent == 0x7FFF) {\\n          if (x == y) return x;\\n          else return NaN;\\n        } else return x;\\n      } else if (yExponent == 0x7FFF) return y;\\n      else {\\n        bool xSign = uint128(x) >= 0x80000000000000000000000000000000;\\n        uint256 xSignifier = uint128(x) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n        if (xExponent == 0) xExponent = 1;\\n        else xSignifier |= 0x10000000000000000000000000000;\\n\\n        bool ySign = uint128(y) >= 0x80000000000000000000000000000000;\\n        uint256 ySignifier = uint128(y) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n        if (yExponent == 0) yExponent = 1;\\n        else ySignifier |= 0x10000000000000000000000000000;\\n\\n        if (xSignifier == 0) return y == NEGATIVE_ZERO ? POSITIVE_ZERO : y;\\n        else if (ySignifier == 0) return x == NEGATIVE_ZERO ? POSITIVE_ZERO : x;\\n        else {\\n          int256 delta = int256(xExponent) - int256(yExponent);\\n\\n          if (xSign == ySign) {\\n            if (delta > 112) return x;\\n            else if (delta > 0) ySignifier >>= uint256(delta);\\n            else if (delta < -112) return y;\\n            else if (delta < 0) {\\n              xSignifier >>= uint256(-delta);\\n              xExponent = yExponent;\\n            }\\n\\n            xSignifier += ySignifier;\\n\\n            if (xSignifier >= 0x20000000000000000000000000000) {\\n              xSignifier >>= 1;\\n              xExponent += 1;\\n            }\\n\\n            if (xExponent == 0x7FFF)\\n              return xSign ? NEGATIVE_INFINITY : POSITIVE_INFINITY;\\n            else {\\n              if (xSignifier < 0x10000000000000000000000000000) xExponent = 0;\\n              else xSignifier &= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n\\n              return\\n                bytes16(\\n                  uint128(\\n                    (xSign ? 0x80000000000000000000000000000000 : 0) |\\n                      (xExponent << 112) |\\n                      xSignifier\\n                  )\\n                );\\n            }\\n          } else {\\n            if (delta > 0) {\\n              xSignifier <<= 1;\\n              xExponent -= 1;\\n            } else if (delta < 0) {\\n              ySignifier <<= 1;\\n              xExponent = yExponent - 1;\\n            }\\n\\n            if (delta > 112) ySignifier = 1;\\n            else if (delta > 1)\\n              ySignifier = ((ySignifier - 1) >> uint256(delta - 1)) + 1;\\n            else if (delta < -112) xSignifier = 1;\\n            else if (delta < -1)\\n              xSignifier = ((xSignifier - 1) >> uint256(-delta - 1)) + 1;\\n\\n            if (xSignifier >= ySignifier) xSignifier -= ySignifier;\\n            else {\\n              xSignifier = ySignifier - xSignifier;\\n              xSign = ySign;\\n            }\\n\\n            if (xSignifier == 0) return POSITIVE_ZERO;\\n\\n            uint256 msb = mostSignificantBit(xSignifier);\\n\\n            if (msb == 113) {\\n              xSignifier = (xSignifier >> 1) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n              xExponent += 1;\\n            } else if (msb < 112) {\\n              uint256 shift = 112 - msb;\\n              if (xExponent > shift) {\\n                xSignifier =\\n                  (xSignifier << shift) &\\n                  0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n                xExponent -= shift;\\n              } else {\\n                xSignifier <<= xExponent - 1;\\n                xExponent = 0;\\n              }\\n            } else xSignifier &= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n\\n            if (xExponent == 0x7FFF)\\n              return xSign ? NEGATIVE_INFINITY : POSITIVE_INFINITY;\\n            else\\n              return\\n                bytes16(\\n                  uint128(\\n                    (xSign ? 0x80000000000000000000000000000000 : 0) |\\n                      (xExponent << 112) |\\n                      xSignifier\\n                  )\\n                );\\n          }\\n        }\\n      }\\n    }\\n  }\\n\\n  /**\\n   * Calculate x - y.  Special values behave in the following way:\\n   *\\n   * NaN - x = NaN for any x.\\n   * Infinity - x = Infinity for any finite x.\\n   * -Infinity - x = -Infinity for any finite x.\\n   * Infinity - -Infinity = Infinity.\\n   * -Infinity - Infinity = -Infinity.\\n   * Infinity - Infinity = -Infinity - -Infinity = NaN.\\n   *\\n   * @param x quadruple precision number\\n   * @param y quadruple precision number\\n   * @return quadruple precision number\\n   */\\n  function sub(bytes16 x, bytes16 y) internal pure returns (bytes16) {\\n    unchecked {\\n      return add(x, y ^ 0x80000000000000000000000000000000);\\n    }\\n  }\\n\\n  /**\\n   * Calculate x * y.  Special values behave in the following way:\\n   *\\n   * NaN * x = NaN for any x.\\n   * Infinity * x = Infinity for any finite positive x.\\n   * Infinity * x = -Infinity for any finite negative x.\\n   * -Infinity * x = -Infinity for any finite positive x.\\n   * -Infinity * x = Infinity for any finite negative x.\\n   * Infinity * 0 = NaN.\\n   * -Infinity * 0 = NaN.\\n   * Infinity * Infinity = Infinity.\\n   * Infinity * -Infinity = -Infinity.\\n   * -Infinity * Infinity = -Infinity.\\n   * -Infinity * -Infinity = Infinity.\\n   *\\n   * @param x quadruple precision number\\n   * @param y quadruple precision number\\n   * @return quadruple precision number\\n   */\\n  function mul(bytes16 x, bytes16 y) internal pure returns (bytes16) {\\n    unchecked {\\n      uint256 xExponent = (uint128(x) >> 112) & 0x7FFF;\\n      uint256 yExponent = (uint128(y) >> 112) & 0x7FFF;\\n\\n      if (xExponent == 0x7FFF) {\\n        if (yExponent == 0x7FFF) {\\n          if (x == y) return x ^ (y & 0x80000000000000000000000000000000);\\n          else if (x ^ y == 0x80000000000000000000000000000000) return x | y;\\n          else return NaN;\\n        } else {\\n          if (y & 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF == 0) return NaN;\\n          else return x ^ (y & 0x80000000000000000000000000000000);\\n        }\\n      } else if (yExponent == 0x7FFF) {\\n        if (x & 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF == 0) return NaN;\\n        else return y ^ (x & 0x80000000000000000000000000000000);\\n      } else {\\n        uint256 xSignifier = uint128(x) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n        if (xExponent == 0) xExponent = 1;\\n        else xSignifier |= 0x10000000000000000000000000000;\\n\\n        uint256 ySignifier = uint128(y) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n        if (yExponent == 0) yExponent = 1;\\n        else ySignifier |= 0x10000000000000000000000000000;\\n\\n        xSignifier *= ySignifier;\\n        if (xSignifier == 0)\\n          return\\n            (x ^ y) & 0x80000000000000000000000000000000 > 0\\n              ? NEGATIVE_ZERO\\n              : POSITIVE_ZERO;\\n\\n        xExponent += yExponent;\\n\\n        uint256 msb = xSignifier >=\\n          0x200000000000000000000000000000000000000000000000000000000\\n          ? 225\\n          : xSignifier >=\\n            0x100000000000000000000000000000000000000000000000000000000\\n          ? 224\\n          : mostSignificantBit(xSignifier);\\n\\n        if (xExponent + msb < 16496) {\\n          // Underflow\\n          xExponent = 0;\\n          xSignifier = 0;\\n        } else if (xExponent + msb < 16608) {\\n          // Subnormal\\n          if (xExponent < 16496) xSignifier >>= 16496 - xExponent;\\n          else if (xExponent > 16496) xSignifier <<= xExponent - 16496;\\n          xExponent = 0;\\n        } else if (xExponent + msb > 49373) {\\n          xExponent = 0x7FFF;\\n          xSignifier = 0;\\n        } else {\\n          if (msb > 112) xSignifier >>= msb - 112;\\n          else if (msb < 112) xSignifier <<= 112 - msb;\\n\\n          xSignifier &= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n\\n          xExponent = xExponent + msb - 16607;\\n        }\\n\\n        return\\n          bytes16(\\n            uint128(\\n              uint128((x ^ y) & 0x80000000000000000000000000000000) |\\n                (xExponent << 112) |\\n                xSignifier\\n            )\\n          );\\n      }\\n    }\\n  }\\n\\n  /**\\n   * Calculate x / y.  Special values behave in the following way:\\n   *\\n   * NaN / x = NaN for any x.\\n   * x / NaN = NaN for any x.\\n   * Infinity / x = Infinity for any finite non-negative x.\\n   * Infinity / x = -Infinity for any finite negative x including -0.\\n   * -Infinity / x = -Infinity for any finite non-negative x.\\n   * -Infinity / x = Infinity for any finite negative x including -0.\\n   * x / Infinity = 0 for any finite non-negative x.\\n   * x / -Infinity = -0 for any finite non-negative x.\\n   * x / Infinity = -0 for any finite non-negative x including -0.\\n   * x / -Infinity = 0 for any finite non-negative x including -0.\\n   *\\n   * Infinity / Infinity = NaN.\\n   * Infinity / -Infinity = -NaN.\\n   * -Infinity / Infinity = -NaN.\\n   * -Infinity / -Infinity = NaN.\\n   *\\n   * Division by zero behaves in the following way:\\n   *\\n   * x / 0 = Infinity for any finite positive x.\\n   * x / -0 = -Infinity for any finite positive x.\\n   * x / 0 = -Infinity for any finite negative x.\\n   * x / -0 = Infinity for any finite negative x.\\n   * 0 / 0 = NaN.\\n   * 0 / -0 = NaN.\\n   * -0 / 0 = NaN.\\n   * -0 / -0 = NaN.\\n   *\\n   * @param x quadruple precision number\\n   * @param y quadruple precision number\\n   * @return quadruple precision number\\n   */\\n  function div(bytes16 x, bytes16 y) internal pure returns (bytes16) {\\n    unchecked {\\n      uint256 xExponent = (uint128(x) >> 112) & 0x7FFF;\\n      uint256 yExponent = (uint128(y) >> 112) & 0x7FFF;\\n\\n      if (xExponent == 0x7FFF) {\\n        if (yExponent == 0x7FFF) return NaN;\\n        else return x ^ (y & 0x80000000000000000000000000000000);\\n      } else if (yExponent == 0x7FFF) {\\n        if (y & 0x0000FFFFFFFFFFFFFFFFFFFFFFFFFFFF != 0) return NaN;\\n        else\\n          return POSITIVE_ZERO | ((x ^ y) & 0x80000000000000000000000000000000);\\n      } else if (y & 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF == 0) {\\n        if (x & 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF == 0) return NaN;\\n        else\\n          return\\n            POSITIVE_INFINITY | ((x ^ y) & 0x80000000000000000000000000000000);\\n      } else {\\n        uint256 ySignifier = uint128(y) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n        if (yExponent == 0) yExponent = 1;\\n        else ySignifier |= 0x10000000000000000000000000000;\\n\\n        uint256 xSignifier = uint128(x) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n        if (xExponent == 0) {\\n          if (xSignifier != 0) {\\n            uint256 shift = 226 - mostSignificantBit(xSignifier);\\n\\n            xSignifier <<= shift;\\n\\n            xExponent = 1;\\n            yExponent += shift - 114;\\n          }\\n        } else {\\n          xSignifier = (xSignifier | 0x10000000000000000000000000000) << 114;\\n        }\\n\\n        xSignifier = xSignifier / ySignifier;\\n        if (xSignifier == 0)\\n          return\\n            (x ^ y) & 0x80000000000000000000000000000000 > 0\\n              ? NEGATIVE_ZERO\\n              : POSITIVE_ZERO;\\n\\n        assert(xSignifier >= 0x1000000000000000000000000000);\\n\\n        uint256 msb = xSignifier >= 0x80000000000000000000000000000\\n          ? mostSignificantBit(xSignifier)\\n          : xSignifier >= 0x40000000000000000000000000000\\n          ? 114\\n          : xSignifier >= 0x20000000000000000000000000000\\n          ? 113\\n          : 112;\\n\\n        if (xExponent + msb > yExponent + 16497) {\\n          // Overflow\\n          xExponent = 0x7FFF;\\n          xSignifier = 0;\\n        } else if (xExponent + msb + 16380 < yExponent) {\\n          // Underflow\\n          xExponent = 0;\\n          xSignifier = 0;\\n        } else if (xExponent + msb + 16268 < yExponent) {\\n          // Subnormal\\n          if (xExponent + 16380 > yExponent)\\n            xSignifier <<= xExponent + 16380 - yExponent;\\n          else if (xExponent + 16380 < yExponent)\\n            xSignifier >>= yExponent - xExponent - 16380;\\n\\n          xExponent = 0;\\n        } else {\\n          // Normal\\n          if (msb > 112) xSignifier >>= msb - 112;\\n\\n          xSignifier &= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n\\n          xExponent = xExponent + msb + 16269 - yExponent;\\n        }\\n\\n        return\\n          bytes16(\\n            uint128(\\n              uint128((x ^ y) & 0x80000000000000000000000000000000) |\\n                (xExponent << 112) |\\n                xSignifier\\n            )\\n          );\\n      }\\n    }\\n  }\\n\\n  /**\\n   * Calculate -x.\\n   *\\n   * @param x quadruple precision number\\n   * @return quadruple precision number\\n   */\\n  function neg(bytes16 x) internal pure returns (bytes16) {\\n    unchecked {\\n      return x ^ 0x80000000000000000000000000000000;\\n    }\\n  }\\n\\n  /**\\n   * Calculate |x|.\\n   *\\n   * @param x quadruple precision number\\n   * @return quadruple precision number\\n   */\\n  function abs(bytes16 x) internal pure returns (bytes16) {\\n    unchecked {\\n      return x & 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n    }\\n  }\\n\\n  /**\\n   * Calculate square root of x.  Return NaN on negative x excluding -0.\\n   *\\n   * @param x quadruple precision number\\n   * @return quadruple precision number\\n   */\\n  function sqrt(bytes16 x) internal pure returns (bytes16) {\\n    unchecked {\\n      if (uint128(x) > 0x80000000000000000000000000000000) return NaN;\\n      else {\\n        uint256 xExponent = (uint128(x) >> 112) & 0x7FFF;\\n        if (xExponent == 0x7FFF) return x;\\n        else {\\n          uint256 xSignifier = uint128(x) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n          if (xExponent == 0) xExponent = 1;\\n          else xSignifier |= 0x10000000000000000000000000000;\\n\\n          if (xSignifier == 0) return POSITIVE_ZERO;\\n\\n          bool oddExponent = xExponent & 0x1 == 0;\\n          xExponent = (xExponent + 16383) >> 1;\\n\\n          if (oddExponent) {\\n            if (xSignifier >= 0x10000000000000000000000000000)\\n              xSignifier <<= 113;\\n            else {\\n              uint256 msb = mostSignificantBit(xSignifier);\\n              uint256 shift = (226 - msb) & 0xFE;\\n              xSignifier <<= shift;\\n              xExponent -= (shift - 112) >> 1;\\n            }\\n          } else {\\n            if (xSignifier >= 0x10000000000000000000000000000)\\n              xSignifier <<= 112;\\n            else {\\n              uint256 msb = mostSignificantBit(xSignifier);\\n              uint256 shift = (225 - msb) & 0xFE;\\n              xSignifier <<= shift;\\n              xExponent -= (shift - 112) >> 1;\\n            }\\n          }\\n\\n          uint256 r = 0x10000000000000000000000000000;\\n          r = (r + xSignifier / r) >> 1;\\n          r = (r + xSignifier / r) >> 1;\\n          r = (r + xSignifier / r) >> 1;\\n          r = (r + xSignifier / r) >> 1;\\n          r = (r + xSignifier / r) >> 1;\\n          r = (r + xSignifier / r) >> 1;\\n          r = (r + xSignifier / r) >> 1; // Seven iterations should be enough\\n          uint256 r1 = xSignifier / r;\\n          if (r1 < r) r = r1;\\n\\n          return\\n            bytes16(\\n              uint128((xExponent << 112) | (r & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF))\\n            );\\n        }\\n      }\\n    }\\n  }\\n\\n  /**\\n   * Calculate binary logarithm of x.  Return NaN on negative x excluding -0.\\n   *\\n   * @param x quadruple precision number\\n   * @return quadruple precision number\\n   */\\n  function log_2(bytes16 x) internal pure returns (bytes16) {\\n    unchecked {\\n      if (uint128(x) > 0x80000000000000000000000000000000) return NaN;\\n      else if (x == 0x3FFF0000000000000000000000000000) return POSITIVE_ZERO;\\n      else {\\n        uint256 xExponent = (uint128(x) >> 112) & 0x7FFF;\\n        if (xExponent == 0x7FFF) return x;\\n        else {\\n          uint256 xSignifier = uint128(x) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n          if (xExponent == 0) xExponent = 1;\\n          else xSignifier |= 0x10000000000000000000000000000;\\n\\n          if (xSignifier == 0) return NEGATIVE_INFINITY;\\n\\n          bool resultNegative;\\n          uint256 resultExponent = 16495;\\n          uint256 resultSignifier;\\n\\n          if (xExponent >= 0x3FFF) {\\n            resultNegative = false;\\n            resultSignifier = xExponent - 0x3FFF;\\n            xSignifier <<= 15;\\n          } else {\\n            resultNegative = true;\\n            if (xSignifier >= 0x10000000000000000000000000000) {\\n              resultSignifier = 0x3FFE - xExponent;\\n              xSignifier <<= 15;\\n            } else {\\n              uint256 msb = mostSignificantBit(xSignifier);\\n              resultSignifier = 16493 - msb;\\n              xSignifier <<= 127 - msb;\\n            }\\n          }\\n\\n          if (xSignifier == 0x80000000000000000000000000000000) {\\n            if (resultNegative) resultSignifier += 1;\\n            uint256 shift = 112 - mostSignificantBit(resultSignifier);\\n            resultSignifier <<= shift;\\n            resultExponent -= shift;\\n          } else {\\n            uint256 bb = resultNegative ? 1 : 0;\\n            while (resultSignifier < 0x10000000000000000000000000000) {\\n              resultSignifier <<= 1;\\n              resultExponent -= 1;\\n\\n              xSignifier *= xSignifier;\\n              uint256 b = xSignifier >> 255;\\n              resultSignifier += b ^ bb;\\n              xSignifier >>= 127 + b;\\n            }\\n          }\\n\\n          return\\n            bytes16(\\n              uint128(\\n                (resultNegative ? 0x80000000000000000000000000000000 : 0) |\\n                  (resultExponent << 112) |\\n                  (resultSignifier & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF)\\n              )\\n            );\\n        }\\n      }\\n    }\\n  }\\n\\n  /**\\n   * Calculate natural logarithm of x.  Return NaN on negative x excluding -0.\\n   *\\n   * @param x quadruple precision number\\n   * @return quadruple precision number\\n   */\\n  function ln(bytes16 x) internal pure returns (bytes16) {\\n    unchecked {\\n      return mul(log_2(x), 0x3FFE62E42FEFA39EF35793C7673007E5);\\n    }\\n  }\\n\\n  /**\\n   * Calculate 2^x.\\n   *\\n   * @param x quadruple precision number\\n   * @return quadruple precision number\\n   */\\n  function pow_2(bytes16 x) internal pure returns (bytes16) {\\n    unchecked {\\n      bool xNegative = uint128(x) > 0x80000000000000000000000000000000;\\n      uint256 xExponent = (uint128(x) >> 112) & 0x7FFF;\\n      uint256 xSignifier = uint128(x) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n\\n      if (xExponent == 0x7FFF && xSignifier != 0) return NaN;\\n      else if (xExponent > 16397)\\n        return xNegative ? POSITIVE_ZERO : POSITIVE_INFINITY;\\n      else if (xExponent < 16255) return 0x3FFF0000000000000000000000000000;\\n      else {\\n        if (xExponent == 0) xExponent = 1;\\n        else xSignifier |= 0x10000000000000000000000000000;\\n\\n        if (xExponent > 16367) xSignifier <<= xExponent - 16367;\\n        else if (xExponent < 16367) xSignifier >>= 16367 - xExponent;\\n\\n        if (xNegative && xSignifier > 0x406E00000000000000000000000000000000)\\n          return POSITIVE_ZERO;\\n\\n        if (!xNegative && xSignifier > 0x3FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)\\n          return POSITIVE_INFINITY;\\n\\n        uint256 resultExponent = xSignifier >> 128;\\n        xSignifier &= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n        if (xNegative && xSignifier != 0) {\\n          xSignifier = ~xSignifier;\\n          resultExponent += 1;\\n        }\\n\\n        uint256 resultSignifier = 0x80000000000000000000000000000000;\\n        if (xSignifier & 0x80000000000000000000000000000000 > 0)\\n          resultSignifier =\\n            (resultSignifier * 0x16A09E667F3BCC908B2FB1366EA957D3E) >>\\n            128;\\n        if (xSignifier & 0x40000000000000000000000000000000 > 0)\\n          resultSignifier =\\n            (resultSignifier * 0x1306FE0A31B7152DE8D5A46305C85EDEC) >>\\n            128;\\n        if (xSignifier & 0x20000000000000000000000000000000 > 0)\\n          resultSignifier =\\n            (resultSignifier * 0x1172B83C7D517ADCDF7C8C50EB14A791F) >>\\n            128;\\n        if (xSignifier & 0x10000000000000000000000000000000 > 0)\\n          resultSignifier =\\n            (resultSignifier * 0x10B5586CF9890F6298B92B71842A98363) >>\\n            128;\\n        if (xSignifier & 0x8000000000000000000000000000000 > 0)\\n          resultSignifier =\\n            (resultSignifier * 0x1059B0D31585743AE7C548EB68CA417FD) >>\\n            128;\\n        if (xSignifier & 0x4000000000000000000000000000000 > 0)\\n          resultSignifier =\\n            (resultSignifier * 0x102C9A3E778060EE6F7CACA4F7A29BDE8) >>\\n            128;\\n        if (xSignifier & 0x2000000000000000000000000000000 > 0)\\n          resultSignifier =\\n            (resultSignifier * 0x10163DA9FB33356D84A66AE336DCDFA3F) >>\\n            128;\\n        if (xSignifier & 0x1000000000000000000000000000000 > 0)\\n          resultSignifier =\\n            (resultSignifier * 0x100B1AFA5ABCBED6129AB13EC11DC9543) >>\\n            128;\\n        if (xSignifier & 0x800000000000000000000000000000 > 0)\\n          resultSignifier =\\n            (resultSignifier * 0x10058C86DA1C09EA1FF19D294CF2F679B) >>\\n            128;\\n        if (xSignifier & 0x400000000000000000000000000000 > 0)\\n          resultSignifier =\\n            (resultSignifier * 0x1002C605E2E8CEC506D21BFC89A23A00F) >>\\n            128;\\n        if (xSignifier & 0x200000000000000000000000000000 > 0)\\n          resultSignifier =\\n            (resultSignifier * 0x100162F3904051FA128BCA9C55C31E5DF) >>\\n            128;\\n        if (xSignifier & 0x100000000000000000000000000000 > 0)\\n          resultSignifier =\\n            (resultSignifier * 0x1000B175EFFDC76BA38E31671CA939725) >>\\n            128;\\n        if (xSignifier & 0x80000000000000000000000000000 > 0)\\n          resultSignifier =\\n            (resultSignifier * 0x100058BA01FB9F96D6CACD4B180917C3D) >>\\n            128;\\n        if (xSignifier & 0x40000000000000000000000000000 > 0)\\n          resultSignifier =\\n            (resultSignifier * 0x10002C5CC37DA9491D0985C348C68E7B3) >>\\n            128;\\n        if (xSignifier & 0x20000000000000000000000000000 > 0)\\n          resultSignifier =\\n            (resultSignifier * 0x1000162E525EE054754457D5995292026) >>\\n            128;\\n        if (xSignifier & 0x10000000000000000000000000000 > 0)\\n          resultSignifier =\\n            (resultSignifier * 0x10000B17255775C040618BF4A4ADE83FC) >>\\n            128;\\n        if (xSignifier & 0x8000000000000000000000000000 > 0)\\n          resultSignifier =\\n            (resultSignifier * 0x1000058B91B5BC9AE2EED81E9B7D4CFAB) >>\\n            128;\\n        if (xSignifier & 0x4000000000000000000000000000 > 0)\\n          resultSignifier =\\n            (resultSignifier * 0x100002C5C89D5EC6CA4D7C8ACC017B7C9) >>\\n            128;\\n        if (xSignifier & 0x2000000000000000000000000000 > 0)\\n          resultSignifier =\\n            (resultSignifier * 0x10000162E43F4F831060E02D839A9D16D) >>\\n            128;\\n        if (xSignifier & 0x1000000000000000000000000000 > 0)\\n          resultSignifier =\\n            (resultSignifier * 0x100000B1721BCFC99D9F890EA06911763) >>\\n            128;\\n        if (xSignifier & 0x800000000000000000000000000 > 0)\\n          resultSignifier =\\n            (resultSignifier * 0x10000058B90CF1E6D97F9CA14DBCC1628) >>\\n            128;\\n        if (xSignifier & 0x400000000000000000000000000 > 0)\\n          resultSignifier =\\n            (resultSignifier * 0x1000002C5C863B73F016468F6BAC5CA2B) >>\\n            128;\\n        if (xSignifier & 0x200000000000000000000000000 > 0)\\n          resultSignifier =\\n            (resultSignifier * 0x100000162E430E5A18F6119E3C02282A5) >>\\n            128;\\n        if (xSignifier & 0x100000000000000000000000000 > 0)\\n          resultSignifier =\\n            (resultSignifier * 0x1000000B1721835514B86E6D96EFD1BFE) >>\\n            128;\\n        if (xSignifier & 0x80000000000000000000000000 > 0)\\n          resultSignifier =\\n            (resultSignifier * 0x100000058B90C0B48C6BE5DF846C5B2EF) >>\\n            128;\\n        if (xSignifier & 0x40000000000000000000000000 > 0)\\n          resultSignifier =\\n            (resultSignifier * 0x10000002C5C8601CC6B9E94213C72737A) >>\\n            128;\\n        if (xSignifier & 0x20000000000000000000000000 > 0)\\n          resultSignifier =\\n            (resultSignifier * 0x1000000162E42FFF037DF38AA2B219F06) >>\\n            128;\\n        if (xSignifier & 0x10000000000000000000000000 > 0)\\n          resultSignifier =\\n            (resultSignifier * 0x10000000B17217FBA9C739AA5819F44F9) >>\\n            128;\\n        if (xSignifier & 0x8000000000000000000000000 > 0)\\n          resultSignifier =\\n            (resultSignifier * 0x1000000058B90BFCDEE5ACD3C1CEDC823) >>\\n            128;\\n        if (xSignifier & 0x4000000000000000000000000 > 0)\\n          resultSignifier =\\n            (resultSignifier * 0x100000002C5C85FE31F35A6A30DA1BE50) >>\\n            128;\\n        if (xSignifier & 0x2000000000000000000000000 > 0)\\n          resultSignifier =\\n            (resultSignifier * 0x10000000162E42FF0999CE3541B9FFFCF) >>\\n            128;\\n        if (xSignifier & 0x1000000000000000000000000 > 0)\\n          resultSignifier =\\n            (resultSignifier * 0x100000000B17217F80F4EF5AADDA45554) >>\\n            128;\\n        if (xSignifier & 0x800000000000000000000000 > 0)\\n          resultSignifier =\\n            (resultSignifier * 0x10000000058B90BFBF8479BD5A81B51AD) >>\\n            128;\\n        if (xSignifier & 0x400000000000000000000000 > 0)\\n          resultSignifier =\\n            (resultSignifier * 0x1000000002C5C85FDF84BD62AE30A74CC) >>\\n            128;\\n        if (xSignifier & 0x200000000000000000000000 > 0)\\n          resultSignifier =\\n            (resultSignifier * 0x100000000162E42FEFB2FED257559BDAA) >>\\n            128;\\n        if (xSignifier & 0x100000000000000000000000 > 0)\\n          resultSignifier =\\n            (resultSignifier * 0x1000000000B17217F7D5A7716BBA4A9AE) >>\\n            128;\\n        if (xSignifier & 0x80000000000000000000000 > 0)\\n          resultSignifier =\\n            (resultSignifier * 0x100000000058B90BFBE9DDBAC5E109CCE) >>\\n            128;\\n        if (xSignifier & 0x40000000000000000000000 > 0)\\n          resultSignifier =\\n            (resultSignifier * 0x10000000002C5C85FDF4B15DE6F17EB0D) >>\\n            128;\\n        if (xSignifier & 0x20000000000000000000000 > 0)\\n          resultSignifier =\\n            (resultSignifier * 0x1000000000162E42FEFA494F1478FDE05) >>\\n            128;\\n        if (xSignifier & 0x10000000000000000000000 > 0)\\n          resultSignifier =\\n            (resultSignifier * 0x10000000000B17217F7D20CF927C8E94C) >>\\n            128;\\n        if (xSignifier & 0x8000000000000000000000 > 0)\\n          resultSignifier =\\n            (resultSignifier * 0x1000000000058B90BFBE8F71CB4E4B33D) >>\\n            128;\\n        if (xSignifier & 0x4000000000000000000000 > 0)\\n          resultSignifier =\\n            (resultSignifier * 0x100000000002C5C85FDF477B662B26945) >>\\n            128;\\n        if (xSignifier & 0x2000000000000000000000 > 0)\\n          resultSignifier =\\n            (resultSignifier * 0x10000000000162E42FEFA3AE53369388C) >>\\n            128;\\n        if (xSignifier & 0x1000000000000000000000 > 0)\\n          resultSignifier =\\n            (resultSignifier * 0x100000000000B17217F7D1D351A389D40) >>\\n            128;\\n        if (xSignifier & 0x800000000000000000000 > 0)\\n          resultSignifier =\\n            (resultSignifier * 0x10000000000058B90BFBE8E8B2D3D4EDE) >>\\n            128;\\n        if (xSignifier & 0x400000000000000000000 > 0)\\n          resultSignifier =\\n            (resultSignifier * 0x1000000000002C5C85FDF4741BEA6E77E) >>\\n            128;\\n        if (xSignifier & 0x200000000000000000000 > 0)\\n          resultSignifier =\\n            (resultSignifier * 0x100000000000162E42FEFA39FE95583C2) >>\\n            128;\\n        if (xSignifier & 0x100000000000000000000 > 0)\\n          resultSignifier =\\n            (resultSignifier * 0x1000000000000B17217F7D1CFB72B45E1) >>\\n            128;\\n        if (xSignifier & 0x80000000000000000000 > 0)\\n          resultSignifier =\\n            (resultSignifier * 0x100000000000058B90BFBE8E7CC35C3F0) >>\\n            128;\\n        if (xSignifier & 0x40000000000000000000 > 0)\\n          resultSignifier =\\n            (resultSignifier * 0x10000000000002C5C85FDF473E242EA38) >>\\n            128;\\n        if (xSignifier & 0x20000000000000000000 > 0)\\n          resultSignifier =\\n            (resultSignifier * 0x1000000000000162E42FEFA39F02B772C) >>\\n            128;\\n        if (xSignifier & 0x10000000000000000000 > 0)\\n          resultSignifier =\\n            (resultSignifier * 0x10000000000000B17217F7D1CF7D83C1A) >>\\n            128;\\n        if (xSignifier & 0x8000000000000000000 > 0)\\n          resultSignifier =\\n            (resultSignifier * 0x1000000000000058B90BFBE8E7BDCBE2E) >>\\n            128;\\n        if (xSignifier & 0x4000000000000000000 > 0)\\n          resultSignifier =\\n            (resultSignifier * 0x100000000000002C5C85FDF473DEA871F) >>\\n            128;\\n        if (xSignifier & 0x2000000000000000000 > 0)\\n          resultSignifier =\\n            (resultSignifier * 0x10000000000000162E42FEFA39EF44D91) >>\\n            128;\\n        if (xSignifier & 0x1000000000000000000 > 0)\\n          resultSignifier =\\n            (resultSignifier * 0x100000000000000B17217F7D1CF79E949) >>\\n            128;\\n        if (xSignifier & 0x800000000000000000 > 0)\\n          resultSignifier =\\n            (resultSignifier * 0x10000000000000058B90BFBE8E7BCE544) >>\\n            128;\\n        if (xSignifier & 0x400000000000000000 > 0)\\n          resultSignifier =\\n            (resultSignifier * 0x1000000000000002C5C85FDF473DE6ECA) >>\\n            128;\\n        if (xSignifier & 0x200000000000000000 > 0)\\n          resultSignifier =\\n            (resultSignifier * 0x100000000000000162E42FEFA39EF366F) >>\\n            128;\\n        if (xSignifier & 0x100000000000000000 > 0)\\n          resultSignifier =\\n            (resultSignifier * 0x1000000000000000B17217F7D1CF79AFA) >>\\n            128;\\n        if (xSignifier & 0x80000000000000000 > 0)\\n          resultSignifier =\\n            (resultSignifier * 0x100000000000000058B90BFBE8E7BCD6D) >>\\n            128;\\n        if (xSignifier & 0x40000000000000000 > 0)\\n          resultSignifier =\\n            (resultSignifier * 0x10000000000000002C5C85FDF473DE6B2) >>\\n            128;\\n        if (xSignifier & 0x20000000000000000 > 0)\\n          resultSignifier =\\n            (resultSignifier * 0x1000000000000000162E42FEFA39EF358) >>\\n            128;\\n        if (xSignifier & 0x10000000000000000 > 0)\\n          resultSignifier =\\n            (resultSignifier * 0x10000000000000000B17217F7D1CF79AB) >>\\n            128;\\n        if (xSignifier & 0x8000000000000000 > 0)\\n          resultSignifier =\\n            (resultSignifier * 0x1000000000000000058B90BFBE8E7BCD5) >>\\n            128;\\n        if (xSignifier & 0x4000000000000000 > 0)\\n          resultSignifier =\\n            (resultSignifier * 0x100000000000000002C5C85FDF473DE6A) >>\\n            128;\\n        if (xSignifier & 0x2000000000000000 > 0)\\n          resultSignifier =\\n            (resultSignifier * 0x10000000000000000162E42FEFA39EF34) >>\\n            128;\\n        if (xSignifier & 0x1000000000000000 > 0)\\n          resultSignifier =\\n            (resultSignifier * 0x100000000000000000B17217F7D1CF799) >>\\n            128;\\n        if (xSignifier & 0x800000000000000 > 0)\\n          resultSignifier =\\n            (resultSignifier * 0x10000000000000000058B90BFBE8E7BCC) >>\\n            128;\\n        if (xSignifier & 0x400000000000000 > 0)\\n          resultSignifier =\\n            (resultSignifier * 0x1000000000000000002C5C85FDF473DE5) >>\\n            128;\\n        if (xSignifier & 0x200000000000000 > 0)\\n          resultSignifier =\\n            (resultSignifier * 0x100000000000000000162E42FEFA39EF2) >>\\n            128;\\n        if (xSignifier & 0x100000000000000 > 0)\\n          resultSignifier =\\n            (resultSignifier * 0x1000000000000000000B17217F7D1CF78) >>\\n            128;\\n        if (xSignifier & 0x80000000000000 > 0)\\n          resultSignifier =\\n            (resultSignifier * 0x100000000000000000058B90BFBE8E7BB) >>\\n            128;\\n        if (xSignifier & 0x40000000000000 > 0)\\n          resultSignifier =\\n            (resultSignifier * 0x10000000000000000002C5C85FDF473DD) >>\\n            128;\\n        if (xSignifier & 0x20000000000000 > 0)\\n          resultSignifier =\\n            (resultSignifier * 0x1000000000000000000162E42FEFA39EE) >>\\n            128;\\n        if (xSignifier & 0x10000000000000 > 0)\\n          resultSignifier =\\n            (resultSignifier * 0x10000000000000000000B17217F7D1CF6) >>\\n            128;\\n        if (xSignifier & 0x8000000000000 > 0)\\n          resultSignifier =\\n            (resultSignifier * 0x1000000000000000000058B90BFBE8E7A) >>\\n            128;\\n        if (xSignifier & 0x4000000000000 > 0)\\n          resultSignifier =\\n            (resultSignifier * 0x100000000000000000002C5C85FDF473C) >>\\n            128;\\n        if (xSignifier & 0x2000000000000 > 0)\\n          resultSignifier =\\n            (resultSignifier * 0x10000000000000000000162E42FEFA39D) >>\\n            128;\\n        if (xSignifier & 0x1000000000000 > 0)\\n          resultSignifier =\\n            (resultSignifier * 0x100000000000000000000B17217F7D1CE) >>\\n            128;\\n        if (xSignifier & 0x800000000000 > 0)\\n          resultSignifier =\\n            (resultSignifier * 0x10000000000000000000058B90BFBE8E6) >>\\n            128;\\n        if (xSignifier & 0x400000000000 > 0)\\n          resultSignifier =\\n            (resultSignifier * 0x1000000000000000000002C5C85FDF472) >>\\n            128;\\n        if (xSignifier & 0x200000000000 > 0)\\n          resultSignifier =\\n            (resultSignifier * 0x100000000000000000000162E42FEFA38) >>\\n            128;\\n        if (xSignifier & 0x100000000000 > 0)\\n          resultSignifier =\\n            (resultSignifier * 0x1000000000000000000000B17217F7D1B) >>\\n            128;\\n        if (xSignifier & 0x80000000000 > 0)\\n          resultSignifier =\\n            (resultSignifier * 0x100000000000000000000058B90BFBE8D) >>\\n            128;\\n        if (xSignifier & 0x40000000000 > 0)\\n          resultSignifier =\\n            (resultSignifier * 0x10000000000000000000002C5C85FDF46) >>\\n            128;\\n        if (xSignifier & 0x20000000000 > 0)\\n          resultSignifier =\\n            (resultSignifier * 0x1000000000000000000000162E42FEFA2) >>\\n            128;\\n        if (xSignifier & 0x10000000000 > 0)\\n          resultSignifier =\\n            (resultSignifier * 0x10000000000000000000000B17217F7D0) >>\\n            128;\\n        if (xSignifier & 0x8000000000 > 0)\\n          resultSignifier =\\n            (resultSignifier * 0x1000000000000000000000058B90BFBE7) >>\\n            128;\\n        if (xSignifier & 0x4000000000 > 0)\\n          resultSignifier =\\n            (resultSignifier * 0x100000000000000000000002C5C85FDF3) >>\\n            128;\\n        if (xSignifier & 0x2000000000 > 0)\\n          resultSignifier =\\n            (resultSignifier * 0x10000000000000000000000162E42FEF9) >>\\n            128;\\n        if (xSignifier & 0x1000000000 > 0)\\n          resultSignifier =\\n            (resultSignifier * 0x100000000000000000000000B17217F7C) >>\\n            128;\\n        if (xSignifier & 0x800000000 > 0)\\n          resultSignifier =\\n            (resultSignifier * 0x10000000000000000000000058B90BFBD) >>\\n            128;\\n        if (xSignifier & 0x400000000 > 0)\\n          resultSignifier =\\n            (resultSignifier * 0x1000000000000000000000002C5C85FDE) >>\\n            128;\\n        if (xSignifier & 0x200000000 > 0)\\n          resultSignifier =\\n            (resultSignifier * 0x100000000000000000000000162E42FEE) >>\\n            128;\\n        if (xSignifier & 0x100000000 > 0)\\n          resultSignifier =\\n            (resultSignifier * 0x1000000000000000000000000B17217F6) >>\\n            128;\\n        if (xSignifier & 0x80000000 > 0)\\n          resultSignifier =\\n            (resultSignifier * 0x100000000000000000000000058B90BFA) >>\\n            128;\\n        if (xSignifier & 0x40000000 > 0)\\n          resultSignifier =\\n            (resultSignifier * 0x10000000000000000000000002C5C85FC) >>\\n            128;\\n        if (xSignifier & 0x20000000 > 0)\\n          resultSignifier =\\n            (resultSignifier * 0x1000000000000000000000000162E42FD) >>\\n            128;\\n        if (xSignifier & 0x10000000 > 0)\\n          resultSignifier =\\n            (resultSignifier * 0x10000000000000000000000000B17217E) >>\\n            128;\\n        if (xSignifier & 0x8000000 > 0)\\n          resultSignifier =\\n            (resultSignifier * 0x1000000000000000000000000058B90BE) >>\\n            128;\\n        if (xSignifier & 0x4000000 > 0)\\n          resultSignifier =\\n            (resultSignifier * 0x100000000000000000000000002C5C85E) >>\\n            128;\\n        if (xSignifier & 0x2000000 > 0)\\n          resultSignifier =\\n            (resultSignifier * 0x10000000000000000000000000162E42E) >>\\n            128;\\n        if (xSignifier & 0x1000000 > 0)\\n          resultSignifier =\\n            (resultSignifier * 0x100000000000000000000000000B17216) >>\\n            128;\\n        if (xSignifier & 0x800000 > 0)\\n          resultSignifier =\\n            (resultSignifier * 0x10000000000000000000000000058B90A) >>\\n            128;\\n        if (xSignifier & 0x400000 > 0)\\n          resultSignifier =\\n            (resultSignifier * 0x1000000000000000000000000002C5C84) >>\\n            128;\\n        if (xSignifier & 0x200000 > 0)\\n          resultSignifier =\\n            (resultSignifier * 0x100000000000000000000000000162E41) >>\\n            128;\\n        if (xSignifier & 0x100000 > 0)\\n          resultSignifier =\\n            (resultSignifier * 0x1000000000000000000000000000B1720) >>\\n            128;\\n        if (xSignifier & 0x80000 > 0)\\n          resultSignifier =\\n            (resultSignifier * 0x100000000000000000000000000058B8F) >>\\n            128;\\n        if (xSignifier & 0x40000 > 0)\\n          resultSignifier =\\n            (resultSignifier * 0x10000000000000000000000000002C5C7) >>\\n            128;\\n        if (xSignifier & 0x20000 > 0)\\n          resultSignifier =\\n            (resultSignifier * 0x1000000000000000000000000000162E3) >>\\n            128;\\n        if (xSignifier & 0x10000 > 0)\\n          resultSignifier =\\n            (resultSignifier * 0x10000000000000000000000000000B171) >>\\n            128;\\n        if (xSignifier & 0x8000 > 0)\\n          resultSignifier =\\n            (resultSignifier * 0x1000000000000000000000000000058B8) >>\\n            128;\\n        if (xSignifier & 0x4000 > 0)\\n          resultSignifier =\\n            (resultSignifier * 0x100000000000000000000000000002C5B) >>\\n            128;\\n        if (xSignifier & 0x2000 > 0)\\n          resultSignifier =\\n            (resultSignifier * 0x10000000000000000000000000000162D) >>\\n            128;\\n        if (xSignifier & 0x1000 > 0)\\n          resultSignifier =\\n            (resultSignifier * 0x100000000000000000000000000000B16) >>\\n            128;\\n        if (xSignifier & 0x800 > 0)\\n          resultSignifier =\\n            (resultSignifier * 0x10000000000000000000000000000058A) >>\\n            128;\\n        if (xSignifier & 0x400 > 0)\\n          resultSignifier =\\n            (resultSignifier * 0x1000000000000000000000000000002C4) >>\\n            128;\\n        if (xSignifier & 0x200 > 0)\\n          resultSignifier =\\n            (resultSignifier * 0x100000000000000000000000000000161) >>\\n            128;\\n        if (xSignifier & 0x100 > 0)\\n          resultSignifier =\\n            (resultSignifier * 0x1000000000000000000000000000000B0) >>\\n            128;\\n        if (xSignifier & 0x80 > 0)\\n          resultSignifier =\\n            (resultSignifier * 0x100000000000000000000000000000057) >>\\n            128;\\n        if (xSignifier & 0x40 > 0)\\n          resultSignifier =\\n            (resultSignifier * 0x10000000000000000000000000000002B) >>\\n            128;\\n        if (xSignifier & 0x20 > 0)\\n          resultSignifier =\\n            (resultSignifier * 0x100000000000000000000000000000015) >>\\n            128;\\n        if (xSignifier & 0x10 > 0)\\n          resultSignifier =\\n            (resultSignifier * 0x10000000000000000000000000000000A) >>\\n            128;\\n        if (xSignifier & 0x8 > 0)\\n          resultSignifier =\\n            (resultSignifier * 0x100000000000000000000000000000004) >>\\n            128;\\n        if (xSignifier & 0x4 > 0)\\n          resultSignifier =\\n            (resultSignifier * 0x100000000000000000000000000000001) >>\\n            128;\\n\\n        if (!xNegative) {\\n          resultSignifier =\\n            (resultSignifier >> 15) &\\n            0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n          resultExponent += 0x3FFF;\\n        } else if (resultExponent <= 0x3FFE) {\\n          resultSignifier =\\n            (resultSignifier >> 15) &\\n            0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n          resultExponent = 0x3FFF - resultExponent;\\n        } else {\\n          resultSignifier = resultSignifier >> (resultExponent - 16367);\\n          resultExponent = 0;\\n        }\\n\\n        return bytes16(uint128((resultExponent << 112) | resultSignifier));\\n      }\\n    }\\n  }\\n\\n  /**\\n   * Calculate e^x.\\n   *\\n   * @param x quadruple precision number\\n   * @return quadruple precision number\\n   */\\n  function exp(bytes16 x) internal pure returns (bytes16) {\\n    unchecked {\\n      return pow_2(mul(x, 0x3FFF71547652B82FE1777D0FFDA0D23A));\\n    }\\n  }\\n\\n  /**\\n   * Get index of the most significant non-zero bit in binary representation of\\n   * x.  Reverts if x is zero.\\n   *\\n   * @return index of the most significant non-zero bit in binary representation\\n   *         of x\\n   */\\n  function mostSignificantBit(uint256 x) private pure returns (uint256) {\\n    unchecked {\\n      require(x > 0);\\n\\n      uint256 result = 0;\\n\\n      if (x >= 0x100000000000000000000000000000000) {\\n        x >>= 128;\\n        result += 128;\\n      }\\n      if (x >= 0x10000000000000000) {\\n        x >>= 64;\\n        result += 64;\\n      }\\n      if (x >= 0x100000000) {\\n        x >>= 32;\\n        result += 32;\\n      }\\n      if (x >= 0x10000) {\\n        x >>= 16;\\n        result += 16;\\n      }\\n      if (x >= 0x100) {\\n        x >>= 8;\\n        result += 8;\\n      }\\n      if (x >= 0x10) {\\n        x >>= 4;\\n        result += 4;\\n      }\\n      if (x >= 0x4) {\\n        x >>= 2;\\n        result += 2;\\n      }\\n      if (x >= 0x2) result += 1; // No need to shift x anymore\\n\\n      return result;\\n    }\\n  }\\n}\\n\",\"keccak256\":\"0x805b2f232c048e00f00b26167538ae30e684fee3e2bef2cde2b6728481619309\",\"license\":\"BSD-4-Clause\"},\"contracts/interfaces/IOptionPricing.sol\":{\"content\":\"//SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.0;\\n\\ninterface IOptionPricing {\\n  function getOptionPrice(\\n    bool isPut,\\n    uint256 expiry,\\n    uint256 strike,\\n    uint256 lastPrice,\\n    uint256 baseIv\\n  ) external view returns (uint256);\\n}\\n\",\"keccak256\":\"0x5b8fc680c84fc7b324e2c5f5f3c03264ddbc367d6abe27bd3d6299120f99aee7\",\"license\":\"UNLICENSED\"},\"contracts/libraries/BlackScholes.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.0;\\n\\n// Libraries\\nimport {ABDKMathQuad} from '../external/libraries/ABDKMathQuad.sol';\\n\\n/// @title Black-Scholes option pricing formula and supporting statistical functions\\n/// @author Dopex\\n/// @notice This library implements the Black-Scholes model to price options.\\n/// See - https://en.wikipedia.org/wiki/Black%E2%80%93Scholes_model\\n/// @dev Implements the following implementation - https://cseweb.ucsd.edu/~goguen/courses/130/SayBlackScholes.html\\n/// Uses the ABDKMathQuad(https://github.com/abdk-consulting/abdk-libraries-solidity/blob/master/ABDKMathQuad.md)\\n/// library to make precise calculations. It uses a DIVISOR (1e16) for maintaining precision in constants.\\nlibrary BlackScholes {\\n    uint8 internal constant OPTION_TYPE_CALL = 0;\\n    uint8 internal constant OPTION_TYPE_PUT = 1;\\n\\n    uint256 internal constant DIVISOR = 10**16;\\n\\n    /**\\n     * @notice The function that uses the Black-Scholes equation to calculate the option price\\n     * See http://en.wikipedia.org/wiki/Black%E2%80%93Scholes_model#Black-Scholes_formula\\n     * NOTE: The different parts of the equation are broken down to separate functions as using\\n     * ABDKMathQuad makes small equations verbose.\\n     * @param optionType Type of option - 0 = call, 1 = put\\n     * @param price Stock price\\n     * @param strike Strike price\\n     * @param timeToExpiry Time to expiry in days\\n     * @param riskFreeRate Risk-free rate\\n     * @param volatility Volatility on the asset\\n     * @return Option price based on the Black-Scholes model\\n     */\\n    function calculate(\\n        uint8 optionType,\\n        uint256 price,\\n        uint256 strike,\\n        uint256 timeToExpiry,\\n        uint256 riskFreeRate,\\n        uint256 volatility\\n    ) internal pure returns (uint256) {\\n        bytes16 S = ABDKMathQuad.fromUInt(price);\\n        bytes16 X = ABDKMathQuad.fromUInt(strike);\\n        bytes16 T = ABDKMathQuad.div(\\n            ABDKMathQuad.fromUInt(timeToExpiry),\\n            ABDKMathQuad.fromUInt(36500) // 365 * 10 ^ DAYS_PRECISION\\n        );\\n        bytes16 r = ABDKMathQuad.div(\\n            ABDKMathQuad.fromUInt(riskFreeRate),\\n            ABDKMathQuad.fromUInt(10000)\\n        );\\n        bytes16 v = ABDKMathQuad.div(\\n            ABDKMathQuad.fromUInt(volatility),\\n            ABDKMathQuad.fromUInt(100)\\n        );\\n        bytes16 d1 = ABDKMathQuad.div(\\n            ABDKMathQuad.add(\\n                ABDKMathQuad.ln(ABDKMathQuad.div(S, X)),\\n                ABDKMathQuad.mul(\\n                    ABDKMathQuad.add(\\n                        r,\\n                        ABDKMathQuad.mul(\\n                            v,\\n                            ABDKMathQuad.div(v, ABDKMathQuad.fromUInt(2))\\n                        )\\n                    ),\\n                    T\\n                )\\n            ),\\n            ABDKMathQuad.mul(v, ABDKMathQuad.sqrt(T))\\n        );\\n        bytes16 d2 = ABDKMathQuad.sub(\\n            d1,\\n            ABDKMathQuad.mul(v, ABDKMathQuad.sqrt(T))\\n        );\\n        if (optionType == OPTION_TYPE_CALL) {\\n            return\\n                ABDKMathQuad.toUInt(\\n                    ABDKMathQuad.mul(\\n                        _calculateCallTimeDecay(S, d1, X, r, T, d2),\\n                        ABDKMathQuad.fromUInt(DIVISOR)\\n                    )\\n                );\\n        } else if (optionType == OPTION_TYPE_PUT) {\\n            return\\n                ABDKMathQuad.toUInt(\\n                    ABDKMathQuad.mul(\\n                        _calculatePutTimeDecay(X, r, T, d2, S, d1),\\n                        ABDKMathQuad.fromUInt(DIVISOR)\\n                    )\\n                );\\n        } else return 0;\\n    }\\n\\n    /// @dev Function to caluclate the call time decay\\n    /// From the implementation page(https://cseweb.ucsd.edu/~goguen/courses/130/SayBlackScholes.html); part of the equation\\n    /// ( S * CND(d1)-X * Math.exp(-r * T) * CND(d2) );\\n    function _calculateCallTimeDecay(\\n        bytes16 S,\\n        bytes16 d1,\\n        bytes16 X,\\n        bytes16 r,\\n        bytes16 T,\\n        bytes16 d2\\n    ) internal pure returns (bytes16) {\\n        return\\n            ABDKMathQuad.sub(\\n                ABDKMathQuad.mul(S, CND(d1)),\\n                ABDKMathQuad.mul(\\n                    ABDKMathQuad.mul(\\n                        X,\\n                        ABDKMathQuad.exp(\\n                            ABDKMathQuad.mul(ABDKMathQuad.neg(r), T)\\n                        )\\n                    ),\\n                    CND(d2)\\n                )\\n            );\\n    }\\n\\n    /// @dev Function to caluclate the put time decay\\n    /// From the implementation page(https://cseweb.ucsd.edu/~goguen/courses/130/SayBlackScholes.html); part of the equation -\\n    /// ( X * Math.exp(-r * T) * CND(-d2) - S * CND(-d1) );\\n    function _calculatePutTimeDecay(\\n        bytes16 X,\\n        bytes16 r,\\n        bytes16 T,\\n        bytes16 d2,\\n        bytes16 S,\\n        bytes16 d1\\n    ) internal pure returns (bytes16) {\\n        bytes16 price_part1 = ABDKMathQuad.mul(\\n            ABDKMathQuad.mul(\\n                X,\\n                ABDKMathQuad.exp(ABDKMathQuad.mul(ABDKMathQuad.neg(r), T))\\n            ),\\n            CND(ABDKMathQuad.neg(d2))\\n        );\\n        bytes16 price_part2 = ABDKMathQuad.mul(S, CND(ABDKMathQuad.neg(d1)));\\n        bytes16 price = ABDKMathQuad.sub(price_part1, price_part2);\\n        return price;\\n    }\\n\\n    /**\\n     * @notice Normal cumulative distribution function.\\n     * See http://en.wikipedia.org/wiki/Normal_distribution#Cumulative_distribution_function\\n     * From the implementation page(https://cseweb.ucsd.edu/~goguen/courses/130/SayBlackScholes.html); part of the equation -\\n     * \\\"k = 1 / (1 + .2316419 * x); return ( 1 - Math.exp(-x * x / 2)/ Math.sqrt(2*Math.PI) * k * (.31938153 + k * (-.356563782 + k * (1.781477937 + k * (-1.821255978 + k * 1.330274429)))) );\\\"\\n     * NOTE: The different parts of the equation are broken down to separate functions as using\\n     * ABDKMathQuad makes small equations verbose.\\n     */\\n    function CND(bytes16 x) internal pure returns (bytes16) {\\n        if (ABDKMathQuad.toInt(x) < 0) {\\n            return (\\n                ABDKMathQuad.sub(\\n                    ABDKMathQuad.fromUInt(1),\\n                    CND(ABDKMathQuad.neg(x))\\n                )\\n            );\\n        } else {\\n            bytes16 k = ABDKMathQuad.div(\\n                ABDKMathQuad.fromUInt(1),\\n                ABDKMathQuad.add(\\n                    ABDKMathQuad.fromUInt(1),\\n                    ABDKMathQuad.mul(\\n                        ABDKMathQuad.div(\\n                            ABDKMathQuad.fromUInt(2316419000000000),\\n                            ABDKMathQuad.fromUInt(DIVISOR)\\n                        ),\\n                        x\\n                    )\\n                )\\n            );\\n            bytes16 CND_part2 = _getCNDPart2(k, x);\\n            return ABDKMathQuad.sub(ABDKMathQuad.fromUInt(1), CND_part2);\\n        }\\n    }\\n\\n    function _getCNDPart2(bytes16 k, bytes16 x)\\n        internal\\n        pure\\n        returns (bytes16)\\n    {\\n        return ABDKMathQuad.mul(_getCNDPart2_1(x), _getCNDPart2_2(k));\\n    }\\n\\n    function _getCNDPart2_1(bytes16 x) internal pure returns (bytes16) {\\n        return\\n            ABDKMathQuad.div(\\n                ABDKMathQuad.exp(\\n                    ABDKMathQuad.mul(\\n                        ABDKMathQuad.neg(x),\\n                        ABDKMathQuad.div(x, ABDKMathQuad.fromUInt(2))\\n                    )\\n                ),\\n                ABDKMathQuad.sqrt(\\n                    ABDKMathQuad.mul(\\n                        ABDKMathQuad.fromUInt(2),\\n                        ABDKMathQuad.div(\\n                            ABDKMathQuad.fromUInt(31415926530000000),\\n                            ABDKMathQuad.fromUInt(DIVISOR)\\n                        )\\n                    )\\n                )\\n            );\\n    }\\n\\n    function _getCNDPart2_2(bytes16 k) internal pure returns (bytes16) {\\n        return\\n            ABDKMathQuad.mul(\\n                ABDKMathQuad.add(\\n                    ABDKMathQuad.div(\\n                        ABDKMathQuad.fromUInt(3193815300000000),\\n                        ABDKMathQuad.fromUInt(DIVISOR)\\n                    ),\\n                    ABDKMathQuad.mul(\\n                        k,\\n                        ABDKMathQuad.add(\\n                            ABDKMathQuad.neg(\\n                                ABDKMathQuad.div(\\n                                    ABDKMathQuad.fromUInt(3565637820000000),\\n                                    ABDKMathQuad.fromUInt(DIVISOR)\\n                                )\\n                            ),\\n                            ABDKMathQuad.mul(\\n                                k,\\n                                ABDKMathQuad.add(\\n                                    ABDKMathQuad.div(\\n                                        ABDKMathQuad.fromUInt(\\n                                            17814779370000000\\n                                        ),\\n                                        ABDKMathQuad.fromUInt(DIVISOR)\\n                                    ),\\n                                    _getCNDPart2_2_1(k)\\n                                )\\n                            )\\n                        )\\n                    )\\n                ),\\n                k\\n            );\\n    }\\n\\n    function _getCNDPart2_2_1(bytes16 k) internal pure returns (bytes16) {\\n        return\\n            ABDKMathQuad.mul(\\n                k,\\n                ABDKMathQuad.add(\\n                    ABDKMathQuad.neg(\\n                        ABDKMathQuad.div(\\n                            ABDKMathQuad.fromUInt(18212559780000000),\\n                            ABDKMathQuad.fromUInt(DIVISOR)\\n                        )\\n                    ),\\n                    ABDKMathQuad.mul(\\n                        k,\\n                        ABDKMathQuad.div(\\n                            ABDKMathQuad.fromUInt(13302744290000000),\\n                            ABDKMathQuad.fromUInt(DIVISOR)\\n                        )\\n                    )\\n                )\\n            );\\n    }\\n}\\n\",\"keccak256\":\"0x16201d5044db4f8c54fdfff00ba3f24b1961abddbfc8178a12039a41364065af\",\"license\":\"UNLICENSED\"},\"contracts/pricing/OptionPricingSimple.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.0;\\n\\n// Libraries\\nimport {SafeMath} from '@openzeppelin/contracts/utils/math/SafeMath.sol';\\nimport {BlackScholes} from '../libraries/BlackScholes.sol';\\nimport {ABDKMathQuad} from '../external/libraries/ABDKMathQuad.sol';\\n\\n// Contracts\\nimport {Ownable} from '@openzeppelin/contracts/access/Ownable.sol';\\n\\n// Interfaces\\nimport {IOptionPricing} from '../interfaces/IOptionPricing.sol';\\n\\ncontract OptionPricingSimple is Ownable, IOptionPricing {\\n    using SafeMath for uint256;\\n\\n    // The max volatility possible\\n    uint256 public volatilityCap;\\n\\n    // The % of the price of asset which is the minimum option price possible in 1e8 precision\\n    uint256 public minOptionPricePercentage;\\n\\n    constructor(uint256 _volatilityCap, uint256 _minOptionPricePercentage) {\\n        volatilityCap = _volatilityCap;\\n        minOptionPricePercentage = _minOptionPricePercentage;\\n    }\\n\\n    /*---- GOVERNANCE FUNCTIONS ----*/\\n\\n    /// @notice updates volatility cap for an option pool\\n    /// @param _volatilityCap the new volatility cap\\n    /// @return whether volatility cap was updated\\n    function updateVolatilityCap(uint256 _volatilityCap)\\n        external\\n        onlyOwner\\n        returns (bool)\\n    {\\n        volatilityCap = _volatilityCap;\\n\\n        return true;\\n    }\\n\\n    /// @notice updates % of the price of asset which is the minimum option price possible\\n    /// @param _minOptionPricePercentage the new %\\n    /// @return whether % was updated\\n    function updateMinOptionPricePercentage(uint256 _minOptionPricePercentage)\\n        external\\n        onlyOwner\\n        returns (bool)\\n    {\\n        minOptionPricePercentage = _minOptionPricePercentage;\\n\\n        return true;\\n    }\\n\\n    /*---- VIEWS ----*/\\n\\n    /**\\n     * @notice computes the option price (with liquidity multiplier)\\n     * @param isPut is put option\\n     * @param expiry expiry timestamp\\n     * @param strike strike price\\n     * @param lastPrice current price\\n     * @param volatility volatility\\n     */\\n    function getOptionPrice(\\n        bool isPut,\\n        uint256 expiry,\\n        uint256 strike,\\n        uint256 lastPrice,\\n        uint256 volatility\\n    ) external view override returns (uint256) {\\n        uint256 timeToExpiry = expiry.sub(block.timestamp).div(864);\\n\\n        uint256 optionPrice = BlackScholes\\n            .calculate(\\n                isPut ? 1 : 0, // 0 - Put, 1 - Call\\n                lastPrice,\\n                strike,\\n                timeToExpiry, // Number of days to expiry mul by 100\\n                0,\\n                volatility\\n            )\\n            .div(BlackScholes.DIVISOR);\\n\\n        uint256 minOptionPrice = lastPrice.mul(minOptionPricePercentage).div(\\n            1e10\\n        );\\n\\n        if (minOptionPrice > optionPrice) {\\n            return minOptionPrice;\\n        }\\n\\n        return optionPrice;\\n    }\\n}\\n\",\"keccak256\":\"0x098f680bc814b04d3a0ff88895ba7c3ddb0f0acd659e11c65b3aeeb2c4baa461\",\"license\":\"UNLICENSED\"}},\"version\":1}",
  "bytecode": "0x60806040523480156200001157600080fd5b5060405162002c0a38038062002c0a833981016040819052620000349162000084565b600080546001600160a01b031916339081178255604051909182917f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0908290a350600191909155600255620000a8565b6000806040838503121562000097578182fd5b505080516020909101519092909150565b612b5280620000b86000396000f3fe608060405234801561001057600080fd5b50600436106100885760003560e01c8063715018a61161005b578063715018a6146100e85780638da5cb5b146100f2578063ad1ad5dc1461010d578063f2fde38b1461012057600080fd5b806305e927df1461008d57806325b2a93b146100a9578063326611f8146100b25780635b7b6d88146100d5575b600080fd5b61009660015481565b6040519081526020015b60405180910390f35b61009660025481565b6100c56100c0366004612a63565b610133565b60405190151581526020016100a0565b6100966100e3366004612a1c565b610170565b6100f06101f9565b005b6000546040516001600160a01b0390911681526020016100a0565b6100c561011b366004612a63565b61026d565b6100f061012e3660046129f5565b6102a1565b600080546001600160a01b031633146101675760405162461bcd60e51b815260040161015e90612a7b565b60405180910390fd5b50600255600190565b600080610189610360610183884261038b565b906103a0565b905060006101b5662386f26fc100006101838a6101a75760006101aa565b60015b888a8760008b6103ac565b905060006101d76402540be400610183600254896104fd90919063ffffffff16565b9050818111156101eb5792506101f0915050565b509150505b95945050505050565b6000546001600160a01b031633146102235760405162461bcd60e51b815260040161015e90612a7b565b600080546040516001600160a01b03909116907f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0908390a3600080546001600160a01b0319169055565b600080546001600160a01b031633146102985760405162461bcd60e51b815260040161015e90612a7b565b50600190815590565b6000546001600160a01b031633146102cb5760405162461bcd60e51b815260040161015e90612a7b565b6001600160a01b0381166103305760405162461bcd60e51b815260206004820152602660248201527f4f776e61626c653a206e6577206f776e657220697320746865207a65726f206160448201526564647265737360d01b606482015260840161015e565b600080546040516001600160a01b03808516939216917f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e091a3600080546001600160a01b0319166001600160a01b0392909216919091179055565b60006103978284612aef565b90505b92915050565b60006103978284612ab0565b6000806103b887610509565b905060006103c587610509565b905060006103e56103d588610509565b6103e0618e94610509565b61056d565b905060006104006103f588610509565b6103e0612710610509565b9050600061041a61041088610509565b6103e06064610509565b9050600061046c61045f610436610431898961056d565b610841565b610454610459876104548861044f8a6103e06002610509565b610864565b610abf565b88610864565b6103e08461044f88610e7f565b90506000610486826104818561044f89610e7f565b6110b3565b905060ff8e166104c7576104b96104b46104a489858a898b886110c5565b61044f662386f26fc10000610509565b61110a565b9750505050505050506104f3565b60ff8e16600114156104e7576104b96104b46104a4888789868d8961118e565b60009750505050505050505b9695505050505050565b60006103978284612ad0565b60008161051857506000919050565b816000610524826111ed565b9050607081101561053d578060700382901b9150610550565b6070811115610550576070810382901c91505b613fff0160701b6001600160701b03919091161760801b92915050565b6000617fff60f084811c8216919084901c8116908214156105b35780617fff14156105a2575061ffff60ef1b915061039a9050565b505050600160ff1b8116821861039a565b80617fff14156105f7576dffffffffffffffffffffffffffff60801b8416156105e6575061ffff60ef1b915061039a9050565b505050808218600160ff1b1661039a565b600160801b600160ff1b03841661064157600160801b600160ff1b038516610629575061ffff60ef1b915061039a9050565b505050808218600160ff1b16617fff60f01b1761039a565b6001600160701b03608085901c168161065d5760019150610664565b600160701b175b6001600160701b03608087901c16836106a357801561069e576000610688826111ed565b6001955060e20393840160711901939190911b90505b6106ad565b600160701b1760721b5b8181816106ca57634e487b7160e01b600052601260045260246000fd5b049050806106f757600160ff1b878718166106e65760006106ec565b600160ff1b5b94505050505061039a565b6001606c1b81101561071957634e487b7160e01b600052600160045260246000fd5b6000600160731b82101561075857600160721b82101561074d57600160711b821015610746576070610750565b6071610750565b60725b60ff16610761565b610761826111ed565b90508361407101818601111561077f57617fff945060009150610812565b83818601613ffc01101561079a576000945060009150610812565b83818601613f8c0110156107e7578385613ffc0111156107c5578385613ffc010382901b91506107de565b8385613ffc0110156107de57613ffc8585030382901c91505b60009450610812565b60708111156107fa576070810382901c91505b6001600160701b038216915083818601613f8d010394505b81607086901b888a186001607f1b60801b1660801c6001600160801b0316171760801b9550505050505061039a565b600061039a61084f8361128b565b6f3ffe62e42fefa39ef35793c7673007e560801b5b6000617fff60f084811c8216919084901c8116908214156109035780617fff14156108e2576001600160801b031985811690851614156108af57505050600160ff1b8116821861039a565b600160ff1b6001600160801b03198686181614156108d25750505081811761039a565b5061ffff60ef1b915061039a9050565b600160801b600160ff1b0384166105a2575061ffff60ef1b915061039a9050565b80617fff141561093f57600160801b600160ff1b03851661092e575061ffff60ef1b915061039a9050565b505050600160ff1b8216811861039a565b6001600160701b03608086901c168261095b5760019250610962565b600160701b175b6001600160701b03608086901c168261097e5760019250610985565b600160701b175b90810290816109a257600160ff1b878718166106e65760006106ec565b928201926000600160e11b8310156109d557600160e01b8310156109ce576109c9836111ed565b6109d8565b60e06109d8565b60e15b905061407081860110156109f3576000945060009250610a90565b6140e08186011015610a3657614070851015610a1857846140700383901c9250610a2d565b614070851115610a2d57614070850383901b92505b60009450610a90565b61c0dd8186011115610a5057617fff945060009250610a90565b6070811115610a67576070810383901c9250610a7a565b6070811015610a7a578060700383901b92505b6001600160701b03831692506140df8186010394505b82607086901b888a186001607f1b60801b1660801c6001600160801b0316171760801b9550505050505061039a565b6000617fff60f084811c8216919084901c811690821415610b0d5780617fff1415610b03576001600160801b031985811690851614156108d257849250505061039a565b849250505061039a565b80617fff1415610b2157839250505061039a565b6001607f1b608086901c90811015906001600160701b031683610b475760019350610b4e565b600160701b175b6001607f1b608087901c90811015906001600160701b031684610b745760019450610b7b565b600160701b175b82610bab576001600160801b03198816600160ff1b14610b9b5787610b9e565b60005b965050505050505061039a565b80610bcb576001600160801b03198916600160ff1b14610b9b5788610b9e565b8486038415158315151415610cd6576070811315610bf2578997505050505050505061039a565b6000811315610c045790811c90610c33565b606f19811215610c1d578897505050505050505061039a565b6000811215610c33578060000384901c93508596505b92810192600160711b8410610c4e576001968701969390931c925b86617fff1415610c805784610c6857617fff60f01b610c72565b6001600160f01b03195b97505050505050505061039a565b600160701b841015610c955760009650610ca2565b6001600160701b03841693505b83607088901b86610cb4576000610cba565b6001607f1b5b6001600160801b0316171760801b97505050505050505061039a565b6000811315610cf157600184901b9350600187039650610d08565b6000811215610d0857600182901b91506001860396505b6070811315610d1a5760019150610d67565b6001811315610d37576001810360018303901c6001019150610d67565b606f19811215610d4a5760019350610d67565b600019811215610d67576001816000030360018503901c60010193505b818410610d78578184039350610d81565b83820393508294505b83610d9757506000965061039a95505050505050565b6000610da2856111ed565b90508060711415610dc857600185901c6001600160701b03169450600188019750610e17565b6070811015610e0a57607081900380891115610df7578086901b6001600160701b031695508089039850610e04565b600098600019019590951b945b50610e17565b6001600160701b03851694505b87617fff1415610e4a5785610e3157617fff60f01b610e3b565b6001600160f01b03195b9850505050505050505061039a565b84607089901b87610e5c576000610e62565b6001607f1b5b6001600160801b0316171760801b9850505050505050505061039a565b60006001607f1b608083901c1115610e9d575061ffff60ef1b919050565b617fff60f083901c811690811415610eb6575090919050565b6001600160701b03608084901c1681610ed25760019150610ed9565b600160701b175b80610ee8575060009392505050565b613fff8201600190811c9216158015610f3a57600160701b8210610f1257607182901b9150610f75565b6000610f1d836111ed565b60e20360fe16606f19810160011c909403939290921b9150610f75565b600160701b8210610f5157607082901b9150610f75565b6000610f5c836111ed565b60e10360fe16606f19810160011c909403939290921b91505b600160701b80830401600190811c90818481610fa157634e487b7160e01b600052601260045260246000fd5b048201901c90506001818481610fc757634e487b7160e01b600052601260045260246000fd5b048201901c90506001818481610fed57634e487b7160e01b600052601260045260246000fd5b048201901c9050600181848161101357634e487b7160e01b600052601260045260246000fd5b048201901c9050600181848161103957634e487b7160e01b600052601260045260246000fd5b048201901c9050600181848161105f57634e487b7160e01b600052601260045260246000fd5b048201901c9050600081848161108557634e487b7160e01b600052601260045260246000fd5b04905081811015611094578091505b816001600160701b0316607086901b1760801b95505050505050919050565b600061039783600160ff1b8418610abf565b60006110ff6110d78861044f8961143b565b6104816110f68861044f6110f1600160ff1b8b188a610864565b6114d6565b61044f8661143b565b979650505050505050565b6000617fff60f083901c16613fff8110156111285750600092915050565b6001607f1b608084901c1061113c57600080fd5b6140fe81111561114b57600080fd5b600160701b6001600160701b03608085901c161761406f8210156111755761406f8290031c611187565b61406f8211156111875761406e1982011b5b9392505050565b6000806111ba6111ab8961044f6110f1600160ff1b8c188b610864565b61044f600160ff1b881861143b565b905060006111d18561044f600160ff1b871861143b565b905060006111df83836110b3565b9a9950505050505050505050565b60008082116111fb57600080fd5b6000600160801b831061121057608092831c92015b600160401b831061122357604092831c92015b640100000000831061123757602092831c92015b62010000831061124957601092831c92015b610100831061125a57600892831c92015b6010831061126a57600492831c92015b6004831061127a57600292831c92015b6002831061039a5760010192915050565b60006001607f1b608083901c11156112a9575061ffff60ef1b919050565b613fff60f01b6001600160801b0319831614156112c857506000919050565b617fff60f083901c8116908114156112e1575090919050565b6001600160701b03608084901c16816112fd5760019150611304565b600160701b175b8061131a57506001600160f01b03199392505050565b600061406f81613fff85106113405750600f9290921b9160009150613ffe19840161137f565b60019250600160701b84106113625784613ffe039050600f84901b935061137f565b600061136d856111ed565b607f8190039590951b9461406d039150505b836001607f1b14156113b3578215611395576001015b60006113a0826111ed565b60700392839003929190911b9050611401565b6000836113c15760006113c4565b60015b60ff1690505b600160701b8210156113ff5793800260ff81901c607f81019190911c94600019939093019260019290921b90821801906113ca565b505b806001600160701b0316607083901b8461141c576000611422565b6001607f1b5b6001600160801b0316171760801b979650505050505050565b600080611447836114fd565b12156114695761039a61145a6001610509565b610481600160ff1b851861143b565b60006114ab6114786001610509565b6103e06114856001610509565b61045461045961149b66083ac553a55e00610509565b6103e0662386f26fc10000610509565b905060006114b982856115a4565b90506114ce6114c86001610509565b826110b3565b949350505050565b600061039a6114f8836f1fffb8aa3b295c17f0bbbe87fed0691d60811b610864565b6115bb565b6000617fff60f083901c166140fe81111561151757600080fd5b613fff81101561152a5750600092915050565b600160701b6001600160701b03608085901c161761406f8210156115545761406f8290031c611566565b61406f8211156115665761406e1982011b5b6001607f1b608085901c1061159057600160ff1b81111561158657600080fd5b6000039392505050565b6001600160ff1b0381111561118757600080fd5b60006103976115b28361290d565b61044f85612955565b60006001607f1b608083901c90811190617fff60f085901c8116916001600160701b031690821480156115ed57508015155b15611601575061ffff60ef1b949350505050565b61400d821115611626578261161b57617fff60f01b6101f0565b600095945050505050565b613f7f82101561163f5750613fff60f01b949350505050565b8161164d5760019150611654565b600160701b175b613fef82111561166a57613fee1982011b61167c565b613fef82101561167c57613fef8290031c5b82801561168d575061203760811b81115b1561169d57506000949350505050565b821580156116bc5750713fffffffffffffffffffffffffffffffffff81115b156116d05750617fff60f01b949350505050565b6001600160801b0381169060801c8380156116ea57508115155b156116f6579019906001015b6001607f1b8281161561171a5770016a09e667f3bcc908b2fb1366ea957d3e0260801c5b6001607e1b83161561173d577001306fe0a31b7152de8d5a46305c85edec0260801c5b6001607d1b831615611760577001172b83c7d517adcdf7c8c50eb14a791f0260801c5b6001607c1b8316156117835770010b5586cf9890f6298b92b71842a983630260801c5b6001607b1b8316156117a6577001059b0d31585743ae7c548eb68ca417fd0260801c5b6001607a1b8316156117c957700102c9a3e778060ee6f7caca4f7a29bde80260801c5b600160791b8316156117ec5770010163da9fb33356d84a66ae336dcdfa3f0260801c5b600160781b83161561180f57700100b1afa5abcbed6129ab13ec11dc95430260801c5b600160771b8316156118325770010058c86da1c09ea1ff19d294cf2f679b0260801c5b600160761b831615611855577001002c605e2e8cec506d21bfc89a23a00f0260801c5b600160751b83161561187857700100162f3904051fa128bca9c55c31e5df0260801c5b600160741b83161561189b577001000b175effdc76ba38e31671ca9397250260801c5b600160731b8316156118be57700100058ba01fb9f96d6cacd4b180917c3d0260801c5b600160721b8316156118e15770010002c5cc37da9491d0985c348c68e7b30260801c5b600160711b831615611904577001000162e525ee054754457d59952920260260801c5b600160701b8316156119275770010000b17255775c040618bf4a4ade83fc0260801c5b6001606f1b83161561194a577001000058b91b5bc9ae2eed81e9b7d4cfab0260801c5b6001606e1b83161561196d57700100002c5c89d5ec6ca4d7c8acc017b7c90260801c5b6001606d1b8316156119905770010000162e43f4f831060e02d839a9d16d0260801c5b6001606c1b8316156119b357700100000b1721bcfc99d9f890ea069117630260801c5b6001606b1b8316156119d65770010000058b90cf1e6d97f9ca14dbcc16280260801c5b6001606a1b8316156119f9577001000002c5c863b73f016468f6bac5ca2b0260801c5b600160691b831615611a1c57700100000162e430e5a18f6119e3c02282a50260801c5b600160681b831615611a3f577001000000b1721835514b86e6d96efd1bfe0260801c5b600160671b831615611a6257700100000058b90c0b48c6be5df846c5b2ef0260801c5b600160661b831615611a855770010000002c5c8601cc6b9e94213c72737a0260801c5b600160651b831615611aa8577001000000162e42fff037df38aa2b219f060260801c5b600160641b831615611acb5770010000000b17217fba9c739aa5819f44f90260801c5b600160631b831615611aee577001000000058b90bfcdee5acd3c1cedc8230260801c5b600160621b831615611b1157700100000002c5c85fe31f35a6a30da1be500260801c5b600160611b831615611b345770010000000162e42ff0999ce3541b9fffcf0260801c5b600160601b831615611b5757700100000000b17217f80f4ef5aadda455540260801c5b6001605f1b831615611b7a5770010000000058b90bfbf8479bd5a81b51ad0260801c5b6001605e1b831615611b9d577001000000002c5c85fdf84bd62ae30a74cc0260801c5b6001605d1b831615611bc057700100000000162e42fefb2fed257559bdaa0260801c5b6001605c1b831615611be3577001000000000b17217f7d5a7716bba4a9ae0260801c5b6001605b1b831615611c0657700100000000058b90bfbe9ddbac5e109cce0260801c5b6001605a1b831615611c295770010000000002c5c85fdf4b15de6f17eb0d0260801c5b600160591b831615611c4c577001000000000162e42fefa494f1478fde050260801c5b600160581b831615611c6f5770010000000000b17217f7d20cf927c8e94c0260801c5b600160571b831615611c92577001000000000058b90bfbe8f71cb4e4b33d0260801c5b600160561b831615611cb557700100000000002c5c85fdf477b662b269450260801c5b600160551b831615611cd85770010000000000162e42fefa3ae53369388c0260801c5b600160541b831615611cfb57700100000000000b17217f7d1d351a389d400260801c5b600160531b831615611d1e5770010000000000058b90bfbe8e8b2d3d4ede0260801c5b600160521b831615611d41577001000000000002c5c85fdf4741bea6e77e0260801c5b600160511b831615611d6457700100000000000162e42fefa39fe95583c20260801c5b600160501b831615611d87577001000000000000b17217f7d1cfb72b45e10260801c5b6980000000000000000000831615611db057700100000000000058b90bfbe8e7cc35c3f00260801c5b6940000000000000000000831615611dd95770010000000000002c5c85fdf473e242ea380260801c5b6920000000000000000000831615611e02577001000000000000162e42fefa39f02b772c0260801c5b6910000000000000000000831615611e2b5770010000000000000b17217f7d1cf7d83c1a0260801c5b6908000000000000000000831615611e54577001000000000000058b90bfbe8e7bdcbe2e0260801c5b6904000000000000000000831615611e7d57700100000000000002c5c85fdf473dea871f0260801c5b6902000000000000000000831615611ea65770010000000000000162e42fefa39ef44d910260801c5b6901000000000000000000831615611ecf57700100000000000000b17217f7d1cf79e9490260801c5b68800000000000000000831615611ef75770010000000000000058b90bfbe8e7bce5440260801c5b68400000000000000000831615611f1f577001000000000000002c5c85fdf473de6eca0260801c5b68200000000000000000831615611f4757700100000000000000162e42fefa39ef366f0260801c5b68100000000000000000831615611f6f577001000000000000000b17217f7d1cf79afa0260801c5b68080000000000000000831615611f9757700100000000000000058b90bfbe8e7bcd6d0260801c5b68040000000000000000831615611fbf5770010000000000000002c5c85fdf473de6b20260801c5b68020000000000000000831615611fe7577001000000000000000162e42fefa39ef3580260801c5b600160401b83161561200a5770010000000000000000b17217f7d1cf79ab0260801c5b678000000000000000831615612031577001000000000000000058b90bfbe8e7bcd50260801c5b67400000000000000083161561205857700100000000000000002c5c85fdf473de6a0260801c5b67200000000000000083161561207f5770010000000000000000162e42fefa39ef340260801c5b6710000000000000008316156120a657700100000000000000000b17217f7d1cf7990260801c5b6708000000000000008316156120cd5770010000000000000000058b90bfbe8e7bcc0260801c5b6704000000000000008316156120f4577001000000000000000002c5c85fdf473de50260801c5b67020000000000000083161561211b57700100000000000000000162e42fefa39ef20260801c5b670100000000000000831615612142577001000000000000000000b17217f7d1cf780260801c5b668000000000000083161561216857700100000000000000000058b90bfbe8e7bb0260801c5b664000000000000083161561218e5770010000000000000000002c5c85fdf473dd0260801c5b66200000000000008316156121b4577001000000000000000000162e42fefa39ee0260801c5b66100000000000008316156121da5770010000000000000000000b17217f7d1cf60260801c5b6608000000000000831615612200577001000000000000000000058b90bfbe8e7a0260801c5b660400000000000083161561222657700100000000000000000002c5c85fdf473c0260801c5b660200000000000083161561224c5770010000000000000000000162e42fefa39d0260801c5b660100000000000083161561227257700100000000000000000000b17217f7d1ce0260801c5b658000000000008316156122975770010000000000000000000058b90bfbe8e60260801c5b654000000000008316156122bc577001000000000000000000002c5c85fdf4720260801c5b652000000000008316156122e157700100000000000000000000162e42fefa380260801c5b65100000000000831615612306577001000000000000000000000b17217f7d1b0260801c5b6508000000000083161561232b57700100000000000000000000058b90bfbe8d0260801c5b650400000000008316156123505770010000000000000000000002c5c85fdf460260801c5b65020000000000831615612375577001000000000000000000000162e42fefa20260801c5b6501000000000083161561239a5770010000000000000000000000b17217f7d00260801c5b6480000000008316156123be577001000000000000000000000058b90bfbe70260801c5b6440000000008316156123e257700100000000000000000000002c5c85fdf30260801c5b6420000000008316156124065770010000000000000000000000162e42fef90260801c5b64100000000083161561242a57700100000000000000000000000b17217f7c0260801c5b64080000000083161561244e5770010000000000000000000000058b90bfbd0260801c5b640400000000831615612472577001000000000000000000000002c5c85fde0260801c5b64020000000083161561249657700100000000000000000000000162e42fee0260801c5b6401000000008316156124ba577001000000000000000000000000b17217f60260801c5b63800000008316156124dd57700100000000000000000000000058b90bfa0260801c5b63400000008316156125005770010000000000000000000000002c5c85fc0260801c5b6320000000831615612523577001000000000000000000000000162e42fd0260801c5b63100000008316156125465770010000000000000000000000000b17217e0260801c5b6308000000831615612569577001000000000000000000000000058b90be0260801c5b630400000083161561258c57700100000000000000000000000002c5c85e0260801c5b63020000008316156125af5770010000000000000000000000000162e42e0260801c5b63010000008316156125d257700100000000000000000000000000b172160260801c5b628000008316156125f45770010000000000000000000000000058b90a0260801c5b62400000831615612616577001000000000000000000000000002c5c840260801c5b6220000083161561263857700100000000000000000000000000162e410260801c5b6210000083161561265a577001000000000000000000000000000b17200260801c5b6208000083161561267c57700100000000000000000000000000058b8f0260801c5b6204000083161561269e5770010000000000000000000000000002c5c70260801c5b620200008316156126c0577001000000000000000000000000000162e30260801c5b620100008316156126e25770010000000000000000000000000000b1710260801c5b618000831615612703577001000000000000000000000000000058b80260801c5b61400083161561272457700100000000000000000000000000002c5b0260801c5b6120008316156127455770010000000000000000000000000000162d0260801c5b61100083161561276657700100000000000000000000000000000b160260801c5b6108008316156127875770010000000000000000000000000000058a0260801c5b6104008316156127a8577001000000000000000000000000000002c40260801c5b6102008316156127c9577001000000000000000000000000000001610260801c5b6101008316156127ea577001000000000000000000000000000000b00260801c5b608083161561280a577001000000000000000000000000000000570260801c5b604083161561282a5770010000000000000000000000000000002b0260801c5b602083161561284a577001000000000000000000000000000000150260801c5b601083161561286a5770010000000000000000000000000000000a0260801c5b600883161561288a577001000000000000000000000000000000040260801c5b60048316156128aa577001000000000000000000000000000000010260801c5b846128cb57600f81901c6001600160701b03169050613fff820191506128fa565b613ffe82116128f057600f81901c6001600160701b0316905081613fff0391506128fa565b600091613fee19011c5b60709190911b1760801b95945050505050565b600061039a61292d6110f1600160ff1b851861044f866103e06002610509565b6103e061295061293d6002610509565b61044f61149b666f9c9e651c4480610509565b610e7f565b600061039a6129b961297061149b660b58c2126f4900610509565b6104548561044f61299661298d61149b660caaedbfa8a700610509565b600160ff1b1890565b6104548961044f6129b061149b663f4a728c19ce80610509565b6104548d6129bf565b83610864565b600061039a8261044f6129de61298d61149b6640b43a04233100610509565b6104548661044f61149b662f42c683f17c80610509565b600060208284031215612a06578081fd5b81356001600160a01b0381168114611187578182fd5b600080600080600060a08688031215612a33578081fd5b85358015158114612a42578182fd5b97602087013597506040870135966060810135965060800135945092505050565b600060208284031215612a74578081fd5b5035919050565b6020808252818101527f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572604082015260600190565b600082612acb57634e487b7160e01b81526012600452602481fd5b500490565b6000816000190483118215151615612aea57612aea612b06565b500290565b600082821015612b0157612b01612b06565b500390565b634e487b7160e01b600052601160045260246000fdfea26469706673582212201231c078f4e9ca7177d1e208bb6bf3581273fe0bc414e3b381ba057fdcd32ae864736f6c63430008040033",
  "deployedBytecode": "0x608060405234801561001057600080fd5b50600436106100885760003560e01c8063715018a61161005b578063715018a6146100e85780638da5cb5b146100f2578063ad1ad5dc1461010d578063f2fde38b1461012057600080fd5b806305e927df1461008d57806325b2a93b146100a9578063326611f8146100b25780635b7b6d88146100d5575b600080fd5b61009660015481565b6040519081526020015b60405180910390f35b61009660025481565b6100c56100c0366004612a63565b610133565b60405190151581526020016100a0565b6100966100e3366004612a1c565b610170565b6100f06101f9565b005b6000546040516001600160a01b0390911681526020016100a0565b6100c561011b366004612a63565b61026d565b6100f061012e3660046129f5565b6102a1565b600080546001600160a01b031633146101675760405162461bcd60e51b815260040161015e90612a7b565b60405180910390fd5b50600255600190565b600080610189610360610183884261038b565b906103a0565b905060006101b5662386f26fc100006101838a6101a75760006101aa565b60015b888a8760008b6103ac565b905060006101d76402540be400610183600254896104fd90919063ffffffff16565b9050818111156101eb5792506101f0915050565b509150505b95945050505050565b6000546001600160a01b031633146102235760405162461bcd60e51b815260040161015e90612a7b565b600080546040516001600160a01b03909116907f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0908390a3600080546001600160a01b0319169055565b600080546001600160a01b031633146102985760405162461bcd60e51b815260040161015e90612a7b565b50600190815590565b6000546001600160a01b031633146102cb5760405162461bcd60e51b815260040161015e90612a7b565b6001600160a01b0381166103305760405162461bcd60e51b815260206004820152602660248201527f4f776e61626c653a206e6577206f776e657220697320746865207a65726f206160448201526564647265737360d01b606482015260840161015e565b600080546040516001600160a01b03808516939216917f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e091a3600080546001600160a01b0319166001600160a01b0392909216919091179055565b60006103978284612aef565b90505b92915050565b60006103978284612ab0565b6000806103b887610509565b905060006103c587610509565b905060006103e56103d588610509565b6103e0618e94610509565b61056d565b905060006104006103f588610509565b6103e0612710610509565b9050600061041a61041088610509565b6103e06064610509565b9050600061046c61045f610436610431898961056d565b610841565b610454610459876104548861044f8a6103e06002610509565b610864565b610abf565b88610864565b6103e08461044f88610e7f565b90506000610486826104818561044f89610e7f565b6110b3565b905060ff8e166104c7576104b96104b46104a489858a898b886110c5565b61044f662386f26fc10000610509565b61110a565b9750505050505050506104f3565b60ff8e16600114156104e7576104b96104b46104a4888789868d8961118e565b60009750505050505050505b9695505050505050565b60006103978284612ad0565b60008161051857506000919050565b816000610524826111ed565b9050607081101561053d578060700382901b9150610550565b6070811115610550576070810382901c91505b613fff0160701b6001600160701b03919091161760801b92915050565b6000617fff60f084811c8216919084901c8116908214156105b35780617fff14156105a2575061ffff60ef1b915061039a9050565b505050600160ff1b8116821861039a565b80617fff14156105f7576dffffffffffffffffffffffffffff60801b8416156105e6575061ffff60ef1b915061039a9050565b505050808218600160ff1b1661039a565b600160801b600160ff1b03841661064157600160801b600160ff1b038516610629575061ffff60ef1b915061039a9050565b505050808218600160ff1b16617fff60f01b1761039a565b6001600160701b03608085901c168161065d5760019150610664565b600160701b175b6001600160701b03608087901c16836106a357801561069e576000610688826111ed565b6001955060e20393840160711901939190911b90505b6106ad565b600160701b1760721b5b8181816106ca57634e487b7160e01b600052601260045260246000fd5b049050806106f757600160ff1b878718166106e65760006106ec565b600160ff1b5b94505050505061039a565b6001606c1b81101561071957634e487b7160e01b600052600160045260246000fd5b6000600160731b82101561075857600160721b82101561074d57600160711b821015610746576070610750565b6071610750565b60725b60ff16610761565b610761826111ed565b90508361407101818601111561077f57617fff945060009150610812565b83818601613ffc01101561079a576000945060009150610812565b83818601613f8c0110156107e7578385613ffc0111156107c5578385613ffc010382901b91506107de565b8385613ffc0110156107de57613ffc8585030382901c91505b60009450610812565b60708111156107fa576070810382901c91505b6001600160701b038216915083818601613f8d010394505b81607086901b888a186001607f1b60801b1660801c6001600160801b0316171760801b9550505050505061039a565b600061039a61084f8361128b565b6f3ffe62e42fefa39ef35793c7673007e560801b5b6000617fff60f084811c8216919084901c8116908214156109035780617fff14156108e2576001600160801b031985811690851614156108af57505050600160ff1b8116821861039a565b600160ff1b6001600160801b03198686181614156108d25750505081811761039a565b5061ffff60ef1b915061039a9050565b600160801b600160ff1b0384166105a2575061ffff60ef1b915061039a9050565b80617fff141561093f57600160801b600160ff1b03851661092e575061ffff60ef1b915061039a9050565b505050600160ff1b8216811861039a565b6001600160701b03608086901c168261095b5760019250610962565b600160701b175b6001600160701b03608086901c168261097e5760019250610985565b600160701b175b90810290816109a257600160ff1b878718166106e65760006106ec565b928201926000600160e11b8310156109d557600160e01b8310156109ce576109c9836111ed565b6109d8565b60e06109d8565b60e15b905061407081860110156109f3576000945060009250610a90565b6140e08186011015610a3657614070851015610a1857846140700383901c9250610a2d565b614070851115610a2d57614070850383901b92505b60009450610a90565b61c0dd8186011115610a5057617fff945060009250610a90565b6070811115610a67576070810383901c9250610a7a565b6070811015610a7a578060700383901b92505b6001600160701b03831692506140df8186010394505b82607086901b888a186001607f1b60801b1660801c6001600160801b0316171760801b9550505050505061039a565b6000617fff60f084811c8216919084901c811690821415610b0d5780617fff1415610b03576001600160801b031985811690851614156108d257849250505061039a565b849250505061039a565b80617fff1415610b2157839250505061039a565b6001607f1b608086901c90811015906001600160701b031683610b475760019350610b4e565b600160701b175b6001607f1b608087901c90811015906001600160701b031684610b745760019450610b7b565b600160701b175b82610bab576001600160801b03198816600160ff1b14610b9b5787610b9e565b60005b965050505050505061039a565b80610bcb576001600160801b03198916600160ff1b14610b9b5788610b9e565b8486038415158315151415610cd6576070811315610bf2578997505050505050505061039a565b6000811315610c045790811c90610c33565b606f19811215610c1d578897505050505050505061039a565b6000811215610c33578060000384901c93508596505b92810192600160711b8410610c4e576001968701969390931c925b86617fff1415610c805784610c6857617fff60f01b610c72565b6001600160f01b03195b97505050505050505061039a565b600160701b841015610c955760009650610ca2565b6001600160701b03841693505b83607088901b86610cb4576000610cba565b6001607f1b5b6001600160801b0316171760801b97505050505050505061039a565b6000811315610cf157600184901b9350600187039650610d08565b6000811215610d0857600182901b91506001860396505b6070811315610d1a5760019150610d67565b6001811315610d37576001810360018303901c6001019150610d67565b606f19811215610d4a5760019350610d67565b600019811215610d67576001816000030360018503901c60010193505b818410610d78578184039350610d81565b83820393508294505b83610d9757506000965061039a95505050505050565b6000610da2856111ed565b90508060711415610dc857600185901c6001600160701b03169450600188019750610e17565b6070811015610e0a57607081900380891115610df7578086901b6001600160701b031695508089039850610e04565b600098600019019590951b945b50610e17565b6001600160701b03851694505b87617fff1415610e4a5785610e3157617fff60f01b610e3b565b6001600160f01b03195b9850505050505050505061039a565b84607089901b87610e5c576000610e62565b6001607f1b5b6001600160801b0316171760801b9850505050505050505061039a565b60006001607f1b608083901c1115610e9d575061ffff60ef1b919050565b617fff60f083901c811690811415610eb6575090919050565b6001600160701b03608084901c1681610ed25760019150610ed9565b600160701b175b80610ee8575060009392505050565b613fff8201600190811c9216158015610f3a57600160701b8210610f1257607182901b9150610f75565b6000610f1d836111ed565b60e20360fe16606f19810160011c909403939290921b9150610f75565b600160701b8210610f5157607082901b9150610f75565b6000610f5c836111ed565b60e10360fe16606f19810160011c909403939290921b91505b600160701b80830401600190811c90818481610fa157634e487b7160e01b600052601260045260246000fd5b048201901c90506001818481610fc757634e487b7160e01b600052601260045260246000fd5b048201901c90506001818481610fed57634e487b7160e01b600052601260045260246000fd5b048201901c9050600181848161101357634e487b7160e01b600052601260045260246000fd5b048201901c9050600181848161103957634e487b7160e01b600052601260045260246000fd5b048201901c9050600181848161105f57634e487b7160e01b600052601260045260246000fd5b048201901c9050600081848161108557634e487b7160e01b600052601260045260246000fd5b04905081811015611094578091505b816001600160701b0316607086901b1760801b95505050505050919050565b600061039783600160ff1b8418610abf565b60006110ff6110d78861044f8961143b565b6104816110f68861044f6110f1600160ff1b8b188a610864565b6114d6565b61044f8661143b565b979650505050505050565b6000617fff60f083901c16613fff8110156111285750600092915050565b6001607f1b608084901c1061113c57600080fd5b6140fe81111561114b57600080fd5b600160701b6001600160701b03608085901c161761406f8210156111755761406f8290031c611187565b61406f8211156111875761406e1982011b5b9392505050565b6000806111ba6111ab8961044f6110f1600160ff1b8c188b610864565b61044f600160ff1b881861143b565b905060006111d18561044f600160ff1b871861143b565b905060006111df83836110b3565b9a9950505050505050505050565b60008082116111fb57600080fd5b6000600160801b831061121057608092831c92015b600160401b831061122357604092831c92015b640100000000831061123757602092831c92015b62010000831061124957601092831c92015b610100831061125a57600892831c92015b6010831061126a57600492831c92015b6004831061127a57600292831c92015b6002831061039a5760010192915050565b60006001607f1b608083901c11156112a9575061ffff60ef1b919050565b613fff60f01b6001600160801b0319831614156112c857506000919050565b617fff60f083901c8116908114156112e1575090919050565b6001600160701b03608084901c16816112fd5760019150611304565b600160701b175b8061131a57506001600160f01b03199392505050565b600061406f81613fff85106113405750600f9290921b9160009150613ffe19840161137f565b60019250600160701b84106113625784613ffe039050600f84901b935061137f565b600061136d856111ed565b607f8190039590951b9461406d039150505b836001607f1b14156113b3578215611395576001015b60006113a0826111ed565b60700392839003929190911b9050611401565b6000836113c15760006113c4565b60015b60ff1690505b600160701b8210156113ff5793800260ff81901c607f81019190911c94600019939093019260019290921b90821801906113ca565b505b806001600160701b0316607083901b8461141c576000611422565b6001607f1b5b6001600160801b0316171760801b979650505050505050565b600080611447836114fd565b12156114695761039a61145a6001610509565b610481600160ff1b851861143b565b60006114ab6114786001610509565b6103e06114856001610509565b61045461045961149b66083ac553a55e00610509565b6103e0662386f26fc10000610509565b905060006114b982856115a4565b90506114ce6114c86001610509565b826110b3565b949350505050565b600061039a6114f8836f1fffb8aa3b295c17f0bbbe87fed0691d60811b610864565b6115bb565b6000617fff60f083901c166140fe81111561151757600080fd5b613fff81101561152a5750600092915050565b600160701b6001600160701b03608085901c161761406f8210156115545761406f8290031c611566565b61406f8211156115665761406e1982011b5b6001607f1b608085901c1061159057600160ff1b81111561158657600080fd5b6000039392505050565b6001600160ff1b0381111561118757600080fd5b60006103976115b28361290d565b61044f85612955565b60006001607f1b608083901c90811190617fff60f085901c8116916001600160701b031690821480156115ed57508015155b15611601575061ffff60ef1b949350505050565b61400d821115611626578261161b57617fff60f01b6101f0565b600095945050505050565b613f7f82101561163f5750613fff60f01b949350505050565b8161164d5760019150611654565b600160701b175b613fef82111561166a57613fee1982011b61167c565b613fef82101561167c57613fef8290031c5b82801561168d575061203760811b81115b1561169d57506000949350505050565b821580156116bc5750713fffffffffffffffffffffffffffffffffff81115b156116d05750617fff60f01b949350505050565b6001600160801b0381169060801c8380156116ea57508115155b156116f6579019906001015b6001607f1b8281161561171a5770016a09e667f3bcc908b2fb1366ea957d3e0260801c5b6001607e1b83161561173d577001306fe0a31b7152de8d5a46305c85edec0260801c5b6001607d1b831615611760577001172b83c7d517adcdf7c8c50eb14a791f0260801c5b6001607c1b8316156117835770010b5586cf9890f6298b92b71842a983630260801c5b6001607b1b8316156117a6577001059b0d31585743ae7c548eb68ca417fd0260801c5b6001607a1b8316156117c957700102c9a3e778060ee6f7caca4f7a29bde80260801c5b600160791b8316156117ec5770010163da9fb33356d84a66ae336dcdfa3f0260801c5b600160781b83161561180f57700100b1afa5abcbed6129ab13ec11dc95430260801c5b600160771b8316156118325770010058c86da1c09ea1ff19d294cf2f679b0260801c5b600160761b831615611855577001002c605e2e8cec506d21bfc89a23a00f0260801c5b600160751b83161561187857700100162f3904051fa128bca9c55c31e5df0260801c5b600160741b83161561189b577001000b175effdc76ba38e31671ca9397250260801c5b600160731b8316156118be57700100058ba01fb9f96d6cacd4b180917c3d0260801c5b600160721b8316156118e15770010002c5cc37da9491d0985c348c68e7b30260801c5b600160711b831615611904577001000162e525ee054754457d59952920260260801c5b600160701b8316156119275770010000b17255775c040618bf4a4ade83fc0260801c5b6001606f1b83161561194a577001000058b91b5bc9ae2eed81e9b7d4cfab0260801c5b6001606e1b83161561196d57700100002c5c89d5ec6ca4d7c8acc017b7c90260801c5b6001606d1b8316156119905770010000162e43f4f831060e02d839a9d16d0260801c5b6001606c1b8316156119b357700100000b1721bcfc99d9f890ea069117630260801c5b6001606b1b8316156119d65770010000058b90cf1e6d97f9ca14dbcc16280260801c5b6001606a1b8316156119f9577001000002c5c863b73f016468f6bac5ca2b0260801c5b600160691b831615611a1c57700100000162e430e5a18f6119e3c02282a50260801c5b600160681b831615611a3f577001000000b1721835514b86e6d96efd1bfe0260801c5b600160671b831615611a6257700100000058b90c0b48c6be5df846c5b2ef0260801c5b600160661b831615611a855770010000002c5c8601cc6b9e94213c72737a0260801c5b600160651b831615611aa8577001000000162e42fff037df38aa2b219f060260801c5b600160641b831615611acb5770010000000b17217fba9c739aa5819f44f90260801c5b600160631b831615611aee577001000000058b90bfcdee5acd3c1cedc8230260801c5b600160621b831615611b1157700100000002c5c85fe31f35a6a30da1be500260801c5b600160611b831615611b345770010000000162e42ff0999ce3541b9fffcf0260801c5b600160601b831615611b5757700100000000b17217f80f4ef5aadda455540260801c5b6001605f1b831615611b7a5770010000000058b90bfbf8479bd5a81b51ad0260801c5b6001605e1b831615611b9d577001000000002c5c85fdf84bd62ae30a74cc0260801c5b6001605d1b831615611bc057700100000000162e42fefb2fed257559bdaa0260801c5b6001605c1b831615611be3577001000000000b17217f7d5a7716bba4a9ae0260801c5b6001605b1b831615611c0657700100000000058b90bfbe9ddbac5e109cce0260801c5b6001605a1b831615611c295770010000000002c5c85fdf4b15de6f17eb0d0260801c5b600160591b831615611c4c577001000000000162e42fefa494f1478fde050260801c5b600160581b831615611c6f5770010000000000b17217f7d20cf927c8e94c0260801c5b600160571b831615611c92577001000000000058b90bfbe8f71cb4e4b33d0260801c5b600160561b831615611cb557700100000000002c5c85fdf477b662b269450260801c5b600160551b831615611cd85770010000000000162e42fefa3ae53369388c0260801c5b600160541b831615611cfb57700100000000000b17217f7d1d351a389d400260801c5b600160531b831615611d1e5770010000000000058b90bfbe8e8b2d3d4ede0260801c5b600160521b831615611d41577001000000000002c5c85fdf4741bea6e77e0260801c5b600160511b831615611d6457700100000000000162e42fefa39fe95583c20260801c5b600160501b831615611d87577001000000000000b17217f7d1cfb72b45e10260801c5b6980000000000000000000831615611db057700100000000000058b90bfbe8e7cc35c3f00260801c5b6940000000000000000000831615611dd95770010000000000002c5c85fdf473e242ea380260801c5b6920000000000000000000831615611e02577001000000000000162e42fefa39f02b772c0260801c5b6910000000000000000000831615611e2b5770010000000000000b17217f7d1cf7d83c1a0260801c5b6908000000000000000000831615611e54577001000000000000058b90bfbe8e7bdcbe2e0260801c5b6904000000000000000000831615611e7d57700100000000000002c5c85fdf473dea871f0260801c5b6902000000000000000000831615611ea65770010000000000000162e42fefa39ef44d910260801c5b6901000000000000000000831615611ecf57700100000000000000b17217f7d1cf79e9490260801c5b68800000000000000000831615611ef75770010000000000000058b90bfbe8e7bce5440260801c5b68400000000000000000831615611f1f577001000000000000002c5c85fdf473de6eca0260801c5b68200000000000000000831615611f4757700100000000000000162e42fefa39ef366f0260801c5b68100000000000000000831615611f6f577001000000000000000b17217f7d1cf79afa0260801c5b68080000000000000000831615611f9757700100000000000000058b90bfbe8e7bcd6d0260801c5b68040000000000000000831615611fbf5770010000000000000002c5c85fdf473de6b20260801c5b68020000000000000000831615611fe7577001000000000000000162e42fefa39ef3580260801c5b600160401b83161561200a5770010000000000000000b17217f7d1cf79ab0260801c5b678000000000000000831615612031577001000000000000000058b90bfbe8e7bcd50260801c5b67400000000000000083161561205857700100000000000000002c5c85fdf473de6a0260801c5b67200000000000000083161561207f5770010000000000000000162e42fefa39ef340260801c5b6710000000000000008316156120a657700100000000000000000b17217f7d1cf7990260801c5b6708000000000000008316156120cd5770010000000000000000058b90bfbe8e7bcc0260801c5b6704000000000000008316156120f4577001000000000000000002c5c85fdf473de50260801c5b67020000000000000083161561211b57700100000000000000000162e42fefa39ef20260801c5b670100000000000000831615612142577001000000000000000000b17217f7d1cf780260801c5b668000000000000083161561216857700100000000000000000058b90bfbe8e7bb0260801c5b664000000000000083161561218e5770010000000000000000002c5c85fdf473dd0260801c5b66200000000000008316156121b4577001000000000000000000162e42fefa39ee0260801c5b66100000000000008316156121da5770010000000000000000000b17217f7d1cf60260801c5b6608000000000000831615612200577001000000000000000000058b90bfbe8e7a0260801c5b660400000000000083161561222657700100000000000000000002c5c85fdf473c0260801c5b660200000000000083161561224c5770010000000000000000000162e42fefa39d0260801c5b660100000000000083161561227257700100000000000000000000b17217f7d1ce0260801c5b658000000000008316156122975770010000000000000000000058b90bfbe8e60260801c5b654000000000008316156122bc577001000000000000000000002c5c85fdf4720260801c5b652000000000008316156122e157700100000000000000000000162e42fefa380260801c5b65100000000000831615612306577001000000000000000000000b17217f7d1b0260801c5b6508000000000083161561232b57700100000000000000000000058b90bfbe8d0260801c5b650400000000008316156123505770010000000000000000000002c5c85fdf460260801c5b65020000000000831615612375577001000000000000000000000162e42fefa20260801c5b6501000000000083161561239a5770010000000000000000000000b17217f7d00260801c5b6480000000008316156123be577001000000000000000000000058b90bfbe70260801c5b6440000000008316156123e257700100000000000000000000002c5c85fdf30260801c5b6420000000008316156124065770010000000000000000000000162e42fef90260801c5b64100000000083161561242a57700100000000000000000000000b17217f7c0260801c5b64080000000083161561244e5770010000000000000000000000058b90bfbd0260801c5b640400000000831615612472577001000000000000000000000002c5c85fde0260801c5b64020000000083161561249657700100000000000000000000000162e42fee0260801c5b6401000000008316156124ba577001000000000000000000000000b17217f60260801c5b63800000008316156124dd57700100000000000000000000000058b90bfa0260801c5b63400000008316156125005770010000000000000000000000002c5c85fc0260801c5b6320000000831615612523577001000000000000000000000000162e42fd0260801c5b63100000008316156125465770010000000000000000000000000b17217e0260801c5b6308000000831615612569577001000000000000000000000000058b90be0260801c5b630400000083161561258c57700100000000000000000000000002c5c85e0260801c5b63020000008316156125af5770010000000000000000000000000162e42e0260801c5b63010000008316156125d257700100000000000000000000000000b172160260801c5b628000008316156125f45770010000000000000000000000000058b90a0260801c5b62400000831615612616577001000000000000000000000000002c5c840260801c5b6220000083161561263857700100000000000000000000000000162e410260801c5b6210000083161561265a577001000000000000000000000000000b17200260801c5b6208000083161561267c57700100000000000000000000000000058b8f0260801c5b6204000083161561269e5770010000000000000000000000000002c5c70260801c5b620200008316156126c0577001000000000000000000000000000162e30260801c5b620100008316156126e25770010000000000000000000000000000b1710260801c5b618000831615612703577001000000000000000000000000000058b80260801c5b61400083161561272457700100000000000000000000000000002c5b0260801c5b6120008316156127455770010000000000000000000000000000162d0260801c5b61100083161561276657700100000000000000000000000000000b160260801c5b6108008316156127875770010000000000000000000000000000058a0260801c5b6104008316156127a8577001000000000000000000000000000002c40260801c5b6102008316156127c9577001000000000000000000000000000001610260801c5b6101008316156127ea577001000000000000000000000000000000b00260801c5b608083161561280a577001000000000000000000000000000000570260801c5b604083161561282a5770010000000000000000000000000000002b0260801c5b602083161561284a577001000000000000000000000000000000150260801c5b601083161561286a5770010000000000000000000000000000000a0260801c5b600883161561288a577001000000000000000000000000000000040260801c5b60048316156128aa577001000000000000000000000000000000010260801c5b846128cb57600f81901c6001600160701b03169050613fff820191506128fa565b613ffe82116128f057600f81901c6001600160701b0316905081613fff0391506128fa565b600091613fee19011c5b60709190911b1760801b95945050505050565b600061039a61292d6110f1600160ff1b851861044f866103e06002610509565b6103e061295061293d6002610509565b61044f61149b666f9c9e651c4480610509565b610e7f565b600061039a6129b961297061149b660b58c2126f4900610509565b6104548561044f61299661298d61149b660caaedbfa8a700610509565b600160ff1b1890565b6104548961044f6129b061149b663f4a728c19ce80610509565b6104548d6129bf565b83610864565b600061039a8261044f6129de61298d61149b6640b43a04233100610509565b6104548661044f61149b662f42c683f17c80610509565b600060208284031215612a06578081fd5b81356001600160a01b0381168114611187578182fd5b600080600080600060a08688031215612a33578081fd5b85358015158114612a42578182fd5b97602087013597506040870135966060810135965060800135945092505050565b600060208284031215612a74578081fd5b5035919050565b6020808252818101527f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572604082015260600190565b600082612acb57634e487b7160e01b81526012600452602481fd5b500490565b6000816000190483118215151615612aea57612aea612b06565b500290565b600082821015612b0157612b01612b06565b500390565b634e487b7160e01b600052601160045260246000fdfea26469706673582212201231c078f4e9ca7177d1e208bb6bf3581273fe0bc414e3b381ba057fdcd32ae864736f6c63430008040033",
  "devdoc": {
    "kind": "dev",
    "methods": {
      "getOptionPrice(bool,uint256,uint256,uint256,uint256)": {
        "params": {
          "expiry": "expiry timestamp",
          "isPut": "is put option",
          "lastPrice": "current price",
          "strike": "strike price",
          "volatility": "volatility"
        }
      },
      "owner()": {
        "details": "Returns the address of the current owner."
      },
      "renounceOwnership()": {
        "details": "Leaves the contract without owner. It will not be possible to call `onlyOwner` functions anymore. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby removing any functionality that is only available to the owner."
      },
      "transferOwnership(address)": {
        "details": "Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner."
      },
      "updateMinOptionPricePercentage(uint256)": {
        "params": {
          "_minOptionPricePercentage": "the new %"
        },
        "returns": {
          "_0": "whether % was updated"
        }
      },
      "updateVolatilityCap(uint256)": {
        "params": {
          "_volatilityCap": "the new volatility cap"
        },
        "returns": {
          "_0": "whether volatility cap was updated"
        }
      }
    },
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {
      "getOptionPrice(bool,uint256,uint256,uint256,uint256)": {
        "notice": "computes the option price (with liquidity multiplier)"
      },
      "updateMinOptionPricePercentage(uint256)": {
        "notice": "updates % of the price of asset which is the minimum option price possible"
      },
      "updateVolatilityCap(uint256)": {
        "notice": "updates volatility cap for an option pool"
      }
    },
    "version": 1
  },
  "storageLayout": {
    "storage": [
      {
        "astId": 3145,
        "contract": "contracts/pricing/OptionPricingSimple.sol:OptionPricingSimple",
        "label": "_owner",
        "offset": 0,
        "slot": "0",
        "type": "t_address"
      },
      {
        "astId": 22507,
        "contract": "contracts/pricing/OptionPricingSimple.sol:OptionPricingSimple",
        "label": "volatilityCap",
        "offset": 0,
        "slot": "1",
        "type": "t_uint256"
      },
      {
        "astId": 22509,
        "contract": "contracts/pricing/OptionPricingSimple.sol:OptionPricingSimple",
        "label": "minOptionPricePercentage",
        "offset": 0,
        "slot": "2",
        "type": "t_uint256"
      }
    ],
    "types": {
      "t_address": {
        "encoding": "inplace",
        "label": "address",
        "numberOfBytes": "20"
      },
      "t_uint256": {
        "encoding": "inplace",
        "label": "uint256",
        "numberOfBytes": "32"
      }
    }
  }
}