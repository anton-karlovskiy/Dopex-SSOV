{
  "language": "Solidity",
  "sources": {
    "contracts/delegator/Delegator.sol": {
      "content": "//SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.0;\n\n// Interfaces\nimport {IERC20} from '../external/interfaces/IERC20.sol';\nimport {IStakingRewards} from '../interfaces/IStakingRewards.sol';\n\n// Contracts\nimport {Ownable} from '@openzeppelin/contracts/access/Ownable.sol';\nimport {ISSOV} from '../interfaces/ISSOV.sol';\n\n// Libraries\nimport {BokkyPooBahsDateTimeLibrary} from '../external/libraries/BokkyPooBahsDateTimeLibrary.sol';\nimport {SafeERC20} from '../external/libraries/SafeERC20.sol';\n\ncontract Delegator is Ownable {\n    using SafeERC20 for IERC20;\n\n    /// @dev exerciseFee % denominator\n    uint256 public constant denominator = 1000;\n\n    /// @dev fee incentive for exercising CALL Options in SSOV\n    uint256 public exerciseFee;\n\n    /// @dev SSOV address\n    ISSOV public immutable ssov;\n\n    /// @dev epoch => strike => total balance\n    mapping(uint256 => mapping(uint256 => uint256)) public totalBalances;\n\n    /// @dev epoch => strike => total $DPX pnl (pnl)\n    mapping(uint256 => mapping(uint256 => uint256)) public totalDpxPnl;\n\n    /// @dev abi.encodePacked(user, strike) => epoch => user balance\n    mapping(bytes32 => mapping(uint256 => uint256)) public balances;\n\n    /// @dev Events\n    event Delegate(\n        address indexed user,\n        uint256 indexed epoch,\n        uint256 strike,\n        address sender,\n        uint256 indexed amount\n    );\n\n    event SetExerciseFee(address indexed sender, uint256 exerciseFee);\n\n    event Exercise(\n        address indexed user,\n        uint256 epoch,\n        uint256 strike,\n        uint256 pnl,\n        uint256 exerciseFee\n    );\n\n    event Withdrawal(\n        address indexed user,\n        uint256 epoch,\n        uint256 strike,\n        uint256 amount\n    );\n\n    event Claim(\n        address indexed user,\n        uint256 epoch,\n        address sender,\n        uint256 amount\n    );\n\n    constructor(address _ssov, uint256 _exerciseFee) {\n        require(\n            address(_ssov) != address(0),\n            'Delegator: Invalid Delegator address'\n        );\n        require(_exerciseFee < denominator, 'Delegator: Invalid exercise fee');\n        ssov = ISSOV(_ssov);\n        exerciseFee = _exerciseFee;\n        emit SetExerciseFee(msg.sender, exerciseFee);\n    }\n\n    /// @notice Set Exercise fee\n    /// @dev Owner sets the exercise fee\n    /// @param _exerciseFee exercise fee% for option exercise\n    function setExerciseFee(uint256 _exerciseFee) external onlyOwner {\n        // Add governance address check modifier here\n        require(_exerciseFee < denominator, 'Delegator: Invalid exercise fee');\n        exerciseFee = _exerciseFee;\n        emit SetExerciseFee(msg.sender, exerciseFee);\n    }\n\n    /// @notice Delegate on behalf of user\n    /// @dev Transfer doTokens for auto-exercise of $DPX calls\n    /// @param _epoch current ssov epoch\n    /// @param _strike strike of the option to auto-exercise\n    /// @param _amount amount of doTokens to transfer to delegator\n    function delegate(\n        uint256 _epoch,\n        uint256 _strike,\n        uint256 _amount\n    ) external returns (bool) {\n        bytes32 userStrike = keccak256(abi.encodePacked(tx.origin, _strike));\n        require(\n            totalBalances[_epoch][_strike] == 0,\n            'Delegator: Cannot deposit after exercise'\n        );\n        balances[userStrike][_epoch] += _amount;\n        IERC20(ssov.epochStrikeTokens(_epoch, _strike)).safeTransferFrom(\n            msg.sender,\n            address(this),\n            _amount\n        );\n        emit Delegate(tx.origin, _epoch, _strike, address(this), _amount);\n        return true;\n    }\n\n    /// @notice Exercise an option on behalf of the user for a given epoch and strike\n    /// @dev this function is not complete\n    /// @param _epoch current ssov epoch\n    /// @param _strike strike of the option to exercise\n    /// @param _strikeIndex strike index of strikes[] array\n    function exercise(\n        uint256 _epoch,\n        uint256 _strike,\n        uint256 _strikeIndex\n    ) external returns (uint256) {\n        require(\n            totalBalances[_epoch][_strike] == 0,\n            'Delegator: Cannot exercise more than once'\n        );\n        uint256 amount = IERC20(ssov.epochStrikeTokens(_epoch, _strike))\n            .balanceOf(address(this));\n        require(amount > 0, 'Delegator: Balance cannot be 0');\n        totalBalances[_epoch][_strike] = amount;\n        IERC20(ssov.epochStrikeTokens(_epoch, _strike)).safeApprove(\n            address(ssov),\n            amount\n        );\n        uint256 pnl = IERC20(ssov.getAddress('DPX')).balanceOf(address(this));\n        ssov.exercise(_strikeIndex, amount, address(this));\n        pnl = IERC20(ssov.getAddress('DPX')).balanceOf(address(this)) - pnl;\n        uint256 fee = (pnl * exerciseFee) / denominator;\n        pnl = pnl - fee;\n        totalDpxPnl[_epoch][_strike] = pnl;\n        IERC20(ssov.getAddress('DPX')).safeTransfer(msg.sender, fee);\n        emit Exercise(msg.sender, _epoch, _strike, pnl, fee);\n        return pnl;\n    }\n\n    /// @notice Withdraw doTokens from the ssov before monthly expiry\n    /// @dev Cannot withdraw from the ssov if user balance = 0\n    /// or balance<deposited amount\n    /// @param _epoch epoch to withdraw doTokens from\n    /// @param _strike strike price\n    /// @param _amount amount of doTokens to withdraw\n    function withdraw(\n        uint256 _epoch,\n        uint256 _strike,\n        uint256 _amount\n    ) external returns (uint256) {\n        require(\n            totalBalances[_epoch][_strike] == 0,\n            'Delegator: Cannot withdraw after exercise'\n        );\n        bytes32 userStrike = keccak256(abi.encodePacked(msg.sender, _strike));\n        balances[userStrike][_epoch] = balances[userStrike][_epoch] - _amount;\n        IERC20(ssov.epochStrikeTokens(_epoch, _strike)).safeTransfer(\n            msg.sender,\n            _amount\n        );\n        emit Withdrawal(msg.sender, _epoch, _strike, _amount);\n        return _amount;\n    }\n\n    /// @notice get pnl to claim from user's doToken deposit\n    /// @param _epoch epoch to claim pnl from\n    /// @param _strike strike price\n    /// @param _user user claiming pnl\n    function claimableAmount(\n        uint256 _epoch,\n        uint256 _strike,\n        address _user\n    ) public view returns (uint256) {\n        bytes32 userStrike = keccak256(abi.encodePacked(_user, _strike));\n        uint256 totalBalance = totalBalances[_epoch][_strike];\n        if (totalBalance == 0) {\n            return 0;\n        } else {\n            return\n                (balances[userStrike][_epoch] * totalDpxPnl[_epoch][_strike]) /\n                totalBalance;\n        }\n    }\n\n    /// @notice claim pnl for user\n    /// @param _epoch epoch to claim pnl from\n    /// @param _strike strike price\n    /// @param _user user claiming pnl\n    function claim(\n        uint256 _epoch,\n        uint256 _strike,\n        address _user\n    ) external returns (uint256) {\n        uint256 claimAmount = claimableAmount(_epoch, _strike, _user);\n        bytes32 userStrike = keccak256(abi.encodePacked(_user, _strike));\n        require(claimAmount > 0, 'Delegator: Already claimed');\n        balances[userStrike][_epoch] = 0;\n        IERC20(ssov.getAddress('DPX')).safeTransfer(_user, claimAmount);\n        emit Claim(_user, _epoch, msg.sender, claimAmount);\n        return claimAmount;\n    }\n}\n"
    },
    "contracts/external/interfaces/IERC20.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n * NOTE: Modified to include symbols and decimals.\n */\ninterface IERC20 {\n  function totalSupply() external view returns (uint256);\n\n  function symbol() external view returns (string memory);\n\n  function decimals() external view returns (uint8);\n\n  function balanceOf(address account) external view returns (uint256);\n\n  function transfer(address recipient, uint256 amount) external returns (bool);\n\n  function allowance(address owner, address spender)\n    external\n    view\n    returns (uint256);\n\n  function approve(address spender, uint256 amount) external returns (bool);\n\n  function transferFrom(\n    address sender,\n    address recipient,\n    uint256 amount\n  ) external returns (bool);\n\n  event Transfer(address indexed from, address indexed to, uint256 value);\n  event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "contracts/interfaces/IStakingRewards.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.0;\n\ninterface IStakingRewards {\n  // Views\n  function lastTimeRewardApplicable() external view returns (uint256);\n\n  function rewardPerToken() external view returns (uint256, uint256);\n\n  function earned(address account) external view returns (uint256, uint256);\n\n  function getRewardForDuration() external view returns (uint256, uint256);\n\n  function totalSupply() external view returns (uint256);\n\n  function balanceOf(address account) external view returns (uint256);\n\n  function rewardsDPX(address account) external view returns  (uint256);\n  \n  function compound() external;\n\n  // Mutative\n\n  function stake(uint256 amount) external payable;\n\n  function withdraw(uint256 amount) external;\n\n  function getReward(uint256 rewardsTokenID) external;\n\n  function exit() external;\n\n}\n"
    },
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor () {\n        address msgSender = _msgSender();\n        _owner = msgSender;\n        emit OwnershipTransferred(address(0), msgSender);\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n"
    },
    "contracts/interfaces/ISSOV.sol": {
      "content": "//SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.0;\n\ninterface ISSOV {\n    function epochStrikeTokens(uint256 epoch, uint256 strike)\n        external\n        view\n        returns (address);\n\n    function purchase(uint256 strikeIndex, uint256 amount)\n        external\n        returns (uint256, uint256);\n\n    function exercise(\n        uint256 strikeIndex,\n        uint256 amount,\n        address user\n    ) external returns (uint256, uint256);\n\n    function getAddress(bytes32 name) external view returns (address);\n}\n"
    },
    "contracts/external/libraries/BokkyPooBahsDateTimeLibrary.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.0;\n\n// ----------------------------------------------------------------------------\n// BokkyPooBah's DateTime Library v1.01\n//\n// A gas-efficient Solidity date and time library\n//\n// https://github.com/bokkypoobah/BokkyPooBahsDateTimeLibrary\n//\n// Tested date range 1970/01/01 to 2345/12/31\n//\n// Conventions:\n// Unit      | Range         | Notes\n// :-------- |:-------------:|:-----\n// timestamp | >= 0          | Unix timestamp, number of seconds since 1970/01/01 00:00:00 UTC\n// year      | 1970 ... 2345 |\n// month     | 1 ... 12      |\n// day       | 1 ... 31      |\n// hour      | 0 ... 23      |\n// minute    | 0 ... 59      |\n// second    | 0 ... 59      |\n// dayOfWeek | 1 ... 7       | 1 = Monday, ..., 7 = Sunday\n//\n//\n// Enjoy. (c) BokkyPooBah / Bok Consulting Pty Ltd 2018-2019. The MIT Licence.\n// ----------------------------------------------------------------------------\n\nlibrary BokkyPooBahsDateTimeLibrary {\n  uint256 constant SECONDS_PER_DAY = 24 * 60 * 60;\n  uint256 constant SECONDS_PER_HOUR = 60 * 60;\n  uint256 constant SECONDS_PER_MINUTE = 60;\n  int256 constant OFFSET19700101 = 2440588;\n\n  uint256 constant DOW_MON = 1;\n  uint256 constant DOW_TUE = 2;\n  uint256 constant DOW_WED = 3;\n  uint256 constant DOW_THU = 4;\n  uint256 constant DOW_FRI = 5;\n  uint256 constant DOW_SAT = 6;\n  uint256 constant DOW_SUN = 7;\n\n  // ------------------------------------------------------------------------\n  // Calculate the number of days from 1970/01/01 to year/month/day using\n  // the date conversion algorithm from\n  //   http://aa.usno.navy.mil/faq/docs/JD_Formula.php\n  // and subtracting the offset 2440588 so that 1970/01/01 is day 0\n  //\n  // days = day\n  //      - 32075\n  //      + 1461 * (year + 4800 + (month - 14) / 12) / 4\n  //      + 367 * (month - 2 - (month - 14) / 12 * 12) / 12\n  //      - 3 * ((year + 4900 + (month - 14) / 12) / 100) / 4\n  //      - offset\n  // ------------------------------------------------------------------------\n  function _daysFromDate(\n    uint256 year,\n    uint256 month,\n    uint256 day\n  ) internal pure returns (uint256 _days) {\n    require(year >= 1970);\n    int256 _year = int256(year);\n    int256 _month = int256(month);\n    int256 _day = int256(day);\n\n    int256 __days = _day -\n      32075 +\n      (1461 * (_year + 4800 + (_month - 14) / 12)) /\n      4 +\n      (367 * (_month - 2 - ((_month - 14) / 12) * 12)) /\n      12 -\n      (3 * ((_year + 4900 + (_month - 14) / 12) / 100)) /\n      4 -\n      OFFSET19700101;\n\n    _days = uint256(__days);\n  }\n\n  // ------------------------------------------------------------------------\n  // Calculate year/month/day from the number of days since 1970/01/01 using\n  // the date conversion algorithm from\n  //   http://aa.usno.navy.mil/faq/docs/JD_Formula.php\n  // and adding the offset 2440588 so that 1970/01/01 is day 0\n  //\n  // int L = days + 68569 + offset\n  // int N = 4 * L / 146097\n  // L = L - (146097 * N + 3) / 4\n  // year = 4000 * (L + 1) / 1461001\n  // L = L - 1461 * year / 4 + 31\n  // month = 80 * L / 2447\n  // dd = L - 2447 * month / 80\n  // L = month / 11\n  // month = month + 2 - 12 * L\n  // year = 100 * (N - 49) + year + L\n  // ------------------------------------------------------------------------\n  function _daysToDate(uint256 _days)\n    internal\n    pure\n    returns (\n      uint256 year,\n      uint256 month,\n      uint256 day\n    )\n  {\n    int256 __days = int256(_days);\n\n    int256 L = __days + 68569 + OFFSET19700101;\n    int256 N = (4 * L) / 146097;\n    L = L - (146097 * N + 3) / 4;\n    int256 _year = (4000 * (L + 1)) / 1461001;\n    L = L - (1461 * _year) / 4 + 31;\n    int256 _month = (80 * L) / 2447;\n    int256 _day = L - (2447 * _month) / 80;\n    L = _month / 11;\n    _month = _month + 2 - 12 * L;\n    _year = 100 * (N - 49) + _year + L;\n\n    year = uint256(_year);\n    month = uint256(_month);\n    day = uint256(_day);\n  }\n\n  function timestampFromDate(\n    uint256 year,\n    uint256 month,\n    uint256 day\n  ) internal pure returns (uint256 timestamp) {\n    timestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY;\n  }\n\n  function timestampFromDateTime(\n    uint256 year,\n    uint256 month,\n    uint256 day,\n    uint256 hour,\n    uint256 minute,\n    uint256 second\n  ) internal pure returns (uint256 timestamp) {\n    timestamp =\n      _daysFromDate(year, month, day) *\n      SECONDS_PER_DAY +\n      hour *\n      SECONDS_PER_HOUR +\n      minute *\n      SECONDS_PER_MINUTE +\n      second;\n  }\n\n  function timestampToDate(uint256 timestamp)\n    internal\n    pure\n    returns (\n      uint256 year,\n      uint256 month,\n      uint256 day\n    )\n  {\n    (year, month, day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n  }\n\n  function timestampToDateTime(uint256 timestamp)\n    internal\n    pure\n    returns (\n      uint256 year,\n      uint256 month,\n      uint256 day,\n      uint256 hour,\n      uint256 minute,\n      uint256 second\n    )\n  {\n    (year, month, day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n    uint256 secs = timestamp % SECONDS_PER_DAY;\n    hour = secs / SECONDS_PER_HOUR;\n    secs = secs % SECONDS_PER_HOUR;\n    minute = secs / SECONDS_PER_MINUTE;\n    second = secs % SECONDS_PER_MINUTE;\n  }\n\n  function isValidDate(\n    uint256 year,\n    uint256 month,\n    uint256 day\n  ) internal pure returns (bool valid) {\n    if (year >= 1970 && month > 0 && month <= 12) {\n      uint256 daysInMonth = _getDaysInMonth(year, month);\n      if (day > 0 && day <= daysInMonth) {\n        valid = true;\n      }\n    }\n  }\n\n  function isValidDateTime(\n    uint256 year,\n    uint256 month,\n    uint256 day,\n    uint256 hour,\n    uint256 minute,\n    uint256 second\n  ) internal pure returns (bool valid) {\n    if (isValidDate(year, month, day)) {\n      if (hour < 24 && minute < 60 && second < 60) {\n        valid = true;\n      }\n    }\n  }\n\n  function isLeapYear(uint256 timestamp) internal pure returns (bool leapYear) {\n    (uint256 year, , ) = _daysToDate(timestamp / SECONDS_PER_DAY);\n    leapYear = _isLeapYear(year);\n  }\n\n  function _isLeapYear(uint256 year) internal pure returns (bool leapYear) {\n    leapYear = ((year % 4 == 0) && (year % 100 != 0)) || (year % 400 == 0);\n  }\n\n  function isWeekDay(uint256 timestamp) internal pure returns (bool weekDay) {\n    weekDay = getDayOfWeek(timestamp) <= DOW_FRI;\n  }\n\n  function isWeekEnd(uint256 timestamp) internal pure returns (bool weekEnd) {\n    weekEnd = getDayOfWeek(timestamp) >= DOW_SAT;\n  }\n\n  function getDaysInMonth(uint256 timestamp)\n    internal\n    pure\n    returns (uint256 daysInMonth)\n  {\n    (uint256 year, uint256 month, ) = _daysToDate(timestamp / SECONDS_PER_DAY);\n    daysInMonth = _getDaysInMonth(year, month);\n  }\n\n  function _getDaysInMonth(uint256 year, uint256 month)\n    internal\n    pure\n    returns (uint256 daysInMonth)\n  {\n    if (\n      month == 1 ||\n      month == 3 ||\n      month == 5 ||\n      month == 7 ||\n      month == 8 ||\n      month == 10 ||\n      month == 12\n    ) {\n      daysInMonth = 31;\n    } else if (month != 2) {\n      daysInMonth = 30;\n    } else {\n      daysInMonth = _isLeapYear(year) ? 29 : 28;\n    }\n  }\n\n  // 1 = Monday, 7 = Sunday\n  function getDayOfWeek(uint256 timestamp)\n    internal\n    pure\n    returns (uint256 dayOfWeek)\n  {\n    uint256 _days = timestamp / SECONDS_PER_DAY;\n    dayOfWeek = ((_days + 3) % 7) + 1;\n  }\n\n  // 1 = Monday, 7 = Sunday\n  function getDayOfWeek(uint256 timestamp, uint256 index)\n    internal\n    pure\n    returns (uint256 dayOfWeek)\n  {\n    uint256 _days = timestamp / SECONDS_PER_DAY;\n    dayOfWeek = ((_days + index) % 7) + 1;\n  }\n\n  function getYear(uint256 timestamp) internal pure returns (uint256 year) {\n    (year, , ) = _daysToDate(timestamp / SECONDS_PER_DAY);\n  }\n\n  function getMonth(uint256 timestamp) internal pure returns (uint256 month) {\n    (, month, ) = _daysToDate(timestamp / SECONDS_PER_DAY);\n  }\n\n  function getDay(uint256 timestamp) internal pure returns (uint256 day) {\n    (, , day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n  }\n\n  function getHour(uint256 timestamp) internal pure returns (uint256 hour) {\n    uint256 secs = timestamp % SECONDS_PER_DAY;\n    hour = secs / SECONDS_PER_HOUR;\n  }\n\n  function getMinute(uint256 timestamp) internal pure returns (uint256 minute) {\n    uint256 secs = timestamp % SECONDS_PER_HOUR;\n    minute = secs / SECONDS_PER_MINUTE;\n  }\n\n  function getSecond(uint256 timestamp) internal pure returns (uint256 second) {\n    second = timestamp % SECONDS_PER_MINUTE;\n  }\n\n  function addYears(uint256 timestamp, uint256 _years)\n    internal\n    pure\n    returns (uint256 newTimestamp)\n  {\n    (uint256 year, uint256 month, uint256 day) = _daysToDate(\n      timestamp / SECONDS_PER_DAY\n    );\n    year += _years;\n    uint256 daysInMonth = _getDaysInMonth(year, month);\n    if (day > daysInMonth) {\n      day = daysInMonth;\n    }\n    newTimestamp =\n      _daysFromDate(year, month, day) *\n      SECONDS_PER_DAY +\n      (timestamp % SECONDS_PER_DAY);\n    require(newTimestamp >= timestamp);\n  }\n\n  function addMonths(uint256 timestamp, uint256 _months)\n    internal\n    pure\n    returns (uint256 newTimestamp)\n  {\n    (uint256 year, uint256 month, uint256 day) = _daysToDate(\n      timestamp / SECONDS_PER_DAY\n    );\n    month += _months;\n    year += (month - 1) / 12;\n    month = ((month - 1) % 12) + 1;\n    uint256 daysInMonth = _getDaysInMonth(year, month);\n    if (day > daysInMonth) {\n      day = daysInMonth;\n    }\n    newTimestamp =\n      _daysFromDate(year, month, day) *\n      SECONDS_PER_DAY +\n      (timestamp % SECONDS_PER_DAY);\n    require(newTimestamp >= timestamp);\n  }\n\n  function addDays(uint256 timestamp, uint256 _days)\n    internal\n    pure\n    returns (uint256 newTimestamp)\n  {\n    newTimestamp = timestamp + _days * SECONDS_PER_DAY;\n    require(newTimestamp >= timestamp);\n  }\n\n  function addHours(uint256 timestamp, uint256 _hours)\n    internal\n    pure\n    returns (uint256 newTimestamp)\n  {\n    newTimestamp = timestamp + _hours * SECONDS_PER_HOUR;\n    require(newTimestamp >= timestamp);\n  }\n\n  function addMinutes(uint256 timestamp, uint256 _minutes)\n    internal\n    pure\n    returns (uint256 newTimestamp)\n  {\n    newTimestamp = timestamp + _minutes * SECONDS_PER_MINUTE;\n    require(newTimestamp >= timestamp);\n  }\n\n  function addSeconds(uint256 timestamp, uint256 _seconds)\n    internal\n    pure\n    returns (uint256 newTimestamp)\n  {\n    newTimestamp = timestamp + _seconds;\n    require(newTimestamp >= timestamp);\n  }\n\n  function subYears(uint256 timestamp, uint256 _years)\n    internal\n    pure\n    returns (uint256 newTimestamp)\n  {\n    (uint256 year, uint256 month, uint256 day) = _daysToDate(\n      timestamp / SECONDS_PER_DAY\n    );\n    year -= _years;\n    uint256 daysInMonth = _getDaysInMonth(year, month);\n    if (day > daysInMonth) {\n      day = daysInMonth;\n    }\n    newTimestamp =\n      _daysFromDate(year, month, day) *\n      SECONDS_PER_DAY +\n      (timestamp % SECONDS_PER_DAY);\n    require(newTimestamp <= timestamp);\n  }\n\n  function subMonths(uint256 timestamp, uint256 _months)\n    internal\n    pure\n    returns (uint256 newTimestamp)\n  {\n    (uint256 year, uint256 month, uint256 day) = _daysToDate(\n      timestamp / SECONDS_PER_DAY\n    );\n    uint256 yearMonth = year * 12 + (month - 1) - _months;\n    year = yearMonth / 12;\n    month = (yearMonth % 12) + 1;\n    uint256 daysInMonth = _getDaysInMonth(year, month);\n    if (day > daysInMonth) {\n      day = daysInMonth;\n    }\n    newTimestamp =\n      _daysFromDate(year, month, day) *\n      SECONDS_PER_DAY +\n      (timestamp % SECONDS_PER_DAY);\n    require(newTimestamp <= timestamp);\n  }\n\n  function subDays(uint256 timestamp, uint256 _days)\n    internal\n    pure\n    returns (uint256 newTimestamp)\n  {\n    newTimestamp = timestamp - _days * SECONDS_PER_DAY;\n    require(newTimestamp <= timestamp);\n  }\n\n  function subHours(uint256 timestamp, uint256 _hours)\n    internal\n    pure\n    returns (uint256 newTimestamp)\n  {\n    newTimestamp = timestamp - _hours * SECONDS_PER_HOUR;\n    require(newTimestamp <= timestamp);\n  }\n\n  function subMinutes(uint256 timestamp, uint256 _minutes)\n    internal\n    pure\n    returns (uint256 newTimestamp)\n  {\n    newTimestamp = timestamp - _minutes * SECONDS_PER_MINUTE;\n    require(newTimestamp <= timestamp);\n  }\n\n  function subSeconds(uint256 timestamp, uint256 _seconds)\n    internal\n    pure\n    returns (uint256 newTimestamp)\n  {\n    newTimestamp = timestamp - _seconds;\n    require(newTimestamp <= timestamp);\n  }\n\n  function diffYears(uint256 fromTimestamp, uint256 toTimestamp)\n    internal\n    pure\n    returns (uint256 _years)\n  {\n    require(fromTimestamp <= toTimestamp);\n    (uint256 fromYear, , ) = _daysToDate(fromTimestamp / SECONDS_PER_DAY);\n    (uint256 toYear, , ) = _daysToDate(toTimestamp / SECONDS_PER_DAY);\n    _years = toYear - fromYear;\n  }\n\n  function diffMonths(uint256 fromTimestamp, uint256 toTimestamp)\n    internal\n    pure\n    returns (uint256 _months)\n  {\n    require(fromTimestamp <= toTimestamp);\n    (uint256 fromYear, uint256 fromMonth, ) = _daysToDate(\n      fromTimestamp / SECONDS_PER_DAY\n    );\n    (uint256 toYear, uint256 toMonth, ) = _daysToDate(\n      toTimestamp / SECONDS_PER_DAY\n    );\n    _months = toYear * 12 + toMonth - fromYear * 12 - fromMonth;\n  }\n\n  function diffDays(uint256 fromTimestamp, uint256 toTimestamp)\n    internal\n    pure\n    returns (uint256 _days)\n  {\n    require(fromTimestamp <= toTimestamp);\n    _days = (toTimestamp - fromTimestamp) / SECONDS_PER_DAY;\n  }\n\n  function diffHours(uint256 fromTimestamp, uint256 toTimestamp)\n    internal\n    pure\n    returns (uint256 _hours)\n  {\n    require(fromTimestamp <= toTimestamp);\n    _hours = (toTimestamp - fromTimestamp) / SECONDS_PER_HOUR;\n  }\n\n  function diffMinutes(uint256 fromTimestamp, uint256 toTimestamp)\n    internal\n    pure\n    returns (uint256 _minutes)\n  {\n    require(fromTimestamp <= toTimestamp);\n    _minutes = (toTimestamp - fromTimestamp) / SECONDS_PER_MINUTE;\n  }\n\n  function diffSeconds(uint256 fromTimestamp, uint256 toTimestamp)\n    internal\n    pure\n    returns (uint256 _seconds)\n  {\n    require(fromTimestamp <= toTimestamp);\n    _seconds = toTimestamp - fromTimestamp;\n  }\n}\n"
    },
    "contracts/external/libraries/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IERC20} from '../interfaces/IERC20.sol';\nimport {SafeMath} from '@openzeppelin/contracts/utils/math/SafeMath.sol';\nimport {Address} from '@openzeppelin/contracts/utils/Address.sol';\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using SafeMath for uint256;\n    using Address for address;\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(\n            token,\n            abi.encodeWithSelector(token.transfer.selector, to, value)\n        );\n    }\n\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(\n            token,\n            abi.encodeWithSelector(token.transferFrom.selector, from, to, value)\n        );\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        // solhint-disable-next-line max-line-length\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            'SafeERC20: approve from non-zero to non-zero allowance'\n        );\n        _callOptionalReturn(\n            token,\n            abi.encodeWithSelector(token.approve.selector, spender, value)\n        );\n    }\n\n    function safeIncreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).add(\n            value\n        );\n        _callOptionalReturn(\n            token,\n            abi.encodeWithSelector(\n                token.approve.selector,\n                spender,\n                newAllowance\n            )\n        );\n    }\n\n    function safeDecreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).sub(\n            value,\n            'SafeERC20: decreased allowance below zero'\n        );\n        _callOptionalReturn(\n            token,\n            abi.encodeWithSelector(\n                token.approve.selector,\n                spender,\n                newAllowance\n            )\n        );\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(\n            data,\n            'SafeERC20: low-level call failed'\n        );\n        if (returndata.length > 0) {\n            // Return data is optional\n            // solhint-disable-next-line max-line-length\n            require(\n                abi.decode(returndata, (bool)),\n                'SafeERC20: ERC20 operation did not succeed'\n            );\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/math/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n// CAUTION\n// This version of SafeMath should only be used with Solidity 0.8 or later,\n// because it relies on the compiler's built in overflow checks.\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations.\n *\n * NOTE: `SafeMath` is no longer needed starting with Solidity 0.8. The compiler\n * now has built in overflow checking.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n            // benefit is lost if 'b' is also tested.\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a + b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a * b;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator.\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a % b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {trySub}.\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        unchecked {\n            require(b <= a, errorMessage);\n            return a - b;\n        }\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        unchecked {\n            require(b > 0, errorMessage);\n            return a / b;\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting with custom message when dividing by zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryMod}.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        unchecked {\n            require(b > 0, errorMessage);\n            return a % b;\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        // solhint-disable-next-line no-inline-assembly\n        assembly { size := extcodesize(account) }\n        return size > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n        (bool success, ) = recipient.call{ value: amount }(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain`call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n      return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                // solhint-disable-next-line no-inline-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "contracts/router/Router.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity ^0.8.0;\n\n// Interfaces\nimport {IERC20} from '../external/interfaces/IERC20.sol';\nimport {IAssetSwapper} from '../external/asset-swapper/interfaces/IAssetSwapper.sol';\n\n// Libraries\nimport {BokkyPooBahsDateTimeLibrary} from '../external/libraries/BokkyPooBahsDateTimeLibrary.sol';\nimport {SafeERC20} from '../external/libraries/SafeERC20.sol';\n\n// Contracts\nimport {Delegator} from '../delegator/Delegator.sol';\nimport {AssetSwapper} from '../external/asset-swapper/AssetSwapper.sol';\nimport {ISSOV} from '../interfaces/ISSOV.sol';\n\ncontract Router {\n    using SafeERC20 for IERC20;\n\n    ISSOV immutable ssov;\n    AssetSwapper immutable assetSwapper;\n    Delegator immutable delegator;\n\n    struct PurchaseOption {\n        bool delegated;\n        uint256 strike;\n        uint256 strikeIndex;\n        uint256 epoch;\n        uint256 amount;\n        address to;\n    }\n\n    /// @notice Constructor\n    /// @param _ssov address of Vault\n    /// @param _assetSwapper address of Asset Swapper contract\n    /// @param _delegator address of Delegator contract\n    constructor(\n        address _ssov,\n        address _assetSwapper,\n        address _delegator\n    ) {\n        ssov = ISSOV(_ssov);\n        assetSwapper = AssetSwapper(_assetSwapper);\n        delegator = Delegator(_delegator);\n    }\n\n    /// @notice purchase DPX option tokens via ssov\n    /// @param _maxAmount maximum amount of DPX to purchase option tokens\n    /// @param _params PurchaseOption parameters to purchase option\n    function purchase(uint256 _maxAmount, PurchaseOption calldata _params)\n        external\n        returns (bool)\n    {\n        IERC20(ssov.getAddress('DPX')).safeTransferFrom(\n            msg.sender,\n            address(this),\n            _maxAmount\n        );\n        IERC20(ssov.getAddress('DPX')).safeIncreaseAllowance(\n            address(ssov),\n            _maxAmount\n        );\n\n        ssov.purchase(_params.strikeIndex, _params.amount);\n\n        _delegate(_params);\n\n        return true;\n    }\n\n    /// @notice Swap any token to the quote asset, then purchase option\n    /// @param _fromAmount amount of tokens to swap from\n    /// @param _minAmountOut minimum amount of tokens to receive\n    /// @param _tokenFrom token that is to be swapped from\n    /// @param _params PurchaseOption struct parameters to purchase option\n    function swapAndPurchase(\n        uint256 _fromAmount,\n        uint256 _minAmountOut,\n        address _tokenFrom,\n        PurchaseOption calldata _params\n    ) external returns (bool) {\n        IERC20(_tokenFrom).safeTransferFrom(\n            msg.sender,\n            address(this),\n            _fromAmount\n        );\n        IERC20(_tokenFrom).safeApprove(address(assetSwapper), _fromAmount);\n        uint256 dpxAmount = assetSwapper.swapAsset(\n            _tokenFrom,\n            ssov.getAddress('DPX'),\n            _fromAmount,\n            _minAmountOut\n        );\n        IERC20(ssov.getAddress('DPX')).safeIncreaseAllowance(\n            address(ssov),\n            dpxAmount\n        );\n        ssov.purchase(_params.strikeIndex, _params.amount);\n        _delegate(_params);\n\n        return true;\n    }\n\n    /// @notice transfer purchased option tokens to delegator for auto-exercise\n    /// @param _params PurchaseOption struct parameters\n    function _delegate(PurchaseOption calldata _params)\n        internal\n        returns (bool)\n    {\n        if (_params.delegated) {\n            IERC20(ssov.epochStrikeTokens(_params.epoch, _params.strike))\n                .safeApprove(address(delegator), _params.amount);\n            delegator.delegate(_params.epoch, _params.strike, _params.amount);\n        } else {\n            IERC20(ssov.epochStrikeTokens(_params.epoch, _params.strike))\n                .safeTransfer(_params.to, _params.amount);\n            return false;\n        }\n        if (IERC20(ssov.getAddress('DPX')).balanceOf(address(this)) > 0) {\n            IERC20(ssov.getAddress('DPX')).safeTransfer(\n                msg.sender,\n                IERC20(ssov.getAddress('DPX')).balanceOf(address(this))\n            );\n        }\n        return true;\n    }\n}\n"
    },
    "contracts/external/asset-swapper/interfaces/IAssetSwapper.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity >=0.7.0;\n\n/// @title AssetSwapper Interface\n/// @author Dopex\ninterface IAssetSwapper {\n    /// @dev Swaps between given `from` and `to` assets\n    /// @param from From token address\n    /// @param to To token address\n    /// @param amount From token amount\n    /// @param minAmountOut Minimum token amount to receive out\n    /// @return To token amuount received\n    function swapAsset(\n        address from,\n        address to,\n        uint256 amount,\n        uint256 minAmountOut\n    ) external returns (uint256);\n}\n"
    },
    "contracts/external/asset-swapper/AssetSwapper.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity ^0.8.0;\n\n// Libraries\nimport {SafeERC20} from '../libraries/SafeERC20.sol';\n\n// Interfaces\nimport {IERC20} from '../interfaces/IERC20.sol';\nimport {IUniswapV2Router02} from '../interfaces/IUniswapV2Router02.sol';\nimport {IAssetSwapper} from './interfaces/IAssetSwapper.sol';\n\n// Contracts\nimport {Ownable} from '@openzeppelin/contracts/access/Ownable.sol';\n\n/// @title Swaps tokens on Uniswap V3\n/// @author Dopex\ncontract AssetSwapper is IAssetSwapper, Ownable {\n    using SafeERC20 for IERC20;\n\n    /// @dev Uniswap V2 SwapRouter\n    IUniswapV2Router02 public uniV2Router;\n\n    /// @dev weth address\n    address public immutable weth;\n\n    event NewSwapperAddress(address indexed swapper);\n\n    constructor(address _router, address _weth) {\n        require(\n            _router != address(0),\n            'Uniswap v2 router address cannot be 0 address'\n        );\n        require(_weth != address(0), 'WETH address cannot be 0 address');\n        uniV2Router = IUniswapV2Router02(_router);\n        weth = _weth;\n    }\n\n    function setSwapperContract(address _address)\n        public\n        onlyOwner\n        returns (bool)\n    {\n        //check for zero address\n        require(_address != address(0), 'E54');\n\n        uniV2Router = IUniswapV2Router02(_address);\n        emit NewSwapperAddress(_address);\n        return true;\n    }\n\n    /// @dev Swaps between given `from` and `to` assets\n    /// @param from From token address\n    /// @param to To token address\n    /// @param amount From token amount\n    /// @param minAmountOut Minimum token amount to receive out\n    /// @return To token amuount received\n    function swapAsset(\n        address from,\n        address to,\n        uint256 amount,\n        uint256 minAmountOut\n    ) public override returns (uint256) {\n        IERC20(from).safeTransferFrom(msg.sender, address(this), amount);\n        address[] memory path;\n        if (from == weth || to == weth) {\n            path = new address[](2);\n            path[0] = from;\n            path[1] = to;\n        } else {\n            path = new address[](3);\n            path[0] = from;\n            path[1] = weth;\n            path[2] = to;\n        }\n        IERC20(from).safeApprove(address(uniV2Router), amount);\n        uint256 amountOut = uniV2Router.swapExactTokensForTokens(\n            amount,\n            minAmountOut,\n            path,\n            address(this),\n            block.timestamp\n        )[path.length - 1];\n        IERC20(to).safeTransfer(msg.sender, amountOut);\n        return amountOut;\n    }\n}\n"
    },
    "contracts/external/interfaces/IUniswapV2Router02.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity ^0.8.0;\n\nimport './IUniswapV2Router01.sol';\n\ninterface IUniswapV2Router02 is IUniswapV2Router01 {\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\n        address token,\n        uint256 liquidity,\n        uint256 amountTokenMin,\n        uint256 amountETHMin,\n        address to,\n        uint256 deadline\n    ) external returns (uint256 amountETH);\n\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\n        address token,\n        uint256 liquidity,\n        uint256 amountTokenMin,\n        uint256 amountETHMin,\n        address to,\n        uint256 deadline,\n        bool approveMax,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external returns (uint256 amountETH);\n\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external;\n\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external payable;\n\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external;\n}\n"
    },
    "contracts/external/interfaces/IUniswapV2Router01.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity ^0.8.0;\n\ninterface IUniswapV2Router01 {\n    function factory() external pure returns (address);\n\n    function WETH() external pure returns (address);\n\n    function addLiquidity(\n        address tokenA,\n        address tokenB,\n        uint256 amountADesired,\n        uint256 amountBDesired,\n        uint256 amountAMin,\n        uint256 amountBMin,\n        address to,\n        uint256 deadline\n    )\n        external\n        returns (\n            uint256 amountA,\n            uint256 amountB,\n            uint256 liquidity\n        );\n\n    function addLiquidityETH(\n        address token,\n        uint256 amountTokenDesired,\n        uint256 amountTokenMin,\n        uint256 amountETHMin,\n        address to,\n        uint256 deadline\n    )\n        external\n        payable\n        returns (\n            uint256 amountToken,\n            uint256 amountETH,\n            uint256 liquidity\n        );\n\n    function removeLiquidity(\n        address tokenA,\n        address tokenB,\n        uint256 liquidity,\n        uint256 amountAMin,\n        uint256 amountBMin,\n        address to,\n        uint256 deadline\n    ) external returns (uint256 amountA, uint256 amountB);\n\n    function removeLiquidityETH(\n        address token,\n        uint256 liquidity,\n        uint256 amountTokenMin,\n        uint256 amountETHMin,\n        address to,\n        uint256 deadline\n    ) external returns (uint256 amountToken, uint256 amountETH);\n\n    function removeLiquidityWithPermit(\n        address tokenA,\n        address tokenB,\n        uint256 liquidity,\n        uint256 amountAMin,\n        uint256 amountBMin,\n        address to,\n        uint256 deadline,\n        bool approveMax,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external returns (uint256 amountA, uint256 amountB);\n\n    function removeLiquidityETHWithPermit(\n        address token,\n        uint256 liquidity,\n        uint256 amountTokenMin,\n        uint256 amountETHMin,\n        address to,\n        uint256 deadline,\n        bool approveMax,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external returns (uint256 amountToken, uint256 amountETH);\n\n    function swapExactTokensForTokens(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external returns (uint256[] memory amounts);\n\n    function swapTokensForExactTokens(\n        uint256 amountOut,\n        uint256 amountInMax,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external returns (uint256[] memory amounts);\n\n    function swapExactETHForTokens(\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external payable returns (uint256[] memory amounts);\n\n    function swapTokensForExactETH(\n        uint256 amountOut,\n        uint256 amountInMax,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external returns (uint256[] memory amounts);\n\n    function swapExactTokensForETH(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external returns (uint256[] memory amounts);\n\n    function swapETHForExactTokens(\n        uint256 amountOut,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external payable returns (uint256[] memory amounts);\n\n    function quote(\n        uint256 amountA,\n        uint256 reserveA,\n        uint256 reserveB\n    ) external pure returns (uint256 amountB);\n\n    function getAmountOut(\n        uint256 amountIn,\n        uint256 reserveIn,\n        uint256 reserveOut\n    ) external pure returns (uint256 amountOut);\n\n    function getAmountIn(\n        uint256 amountOut,\n        uint256 reserveIn,\n        uint256 reserveOut\n    ) external pure returns (uint256 amountIn);\n\n    function getAmountsOut(uint256 amountIn, address[] calldata path)\n        external\n        view\n        returns (uint256[] memory amounts);\n\n    function getAmountsIn(uint256 amountOut, address[] calldata path)\n        external\n        view\n        returns (uint256[] memory amounts);\n}\n"
    },
    "contracts/SSOV/SSOVDpx.sol": {
      "content": "//SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.0;\n\n/**                             .                    .                             \n                           .'.                    .'.                           \n                         .;:.                      .;:.                         \n                       .:o:.                        .;l:.                       \n                     .:dd,                            ,od:.                     \n                   .:dxo'                              .lxd:.                   \n                 .:dkxc.                                .:xkd:.                 \n               .:dkkx:.                                  .;dkkd:.               \n              .ckkkkxl:,'..                            ..':dkkkkl.              \n               'codxxkkkxxdol,                     .,cldxkkkxdoc,               \n                  ..',;coxkkkl.                  .;dxkxdol:;'..                 \n                       .cxkxl.                   ;dkxl,..                       \n                      .:xxxc.                   .cxxd'                          \n                      ;dxd:.    ;c,.            .:dxo'                          \n                     .lddc.    .cdoc.            'odd:.                         \n                     .loo;.     .clol'           .;ool,                         \n                     .:loc,.      ..'.            .:loc'                        \n                      .,cllc;'.                    .;llc'                       \n                        .';cccc:'.                  .;cc:.                      \n                           ..,;::;'                  .;::;.                     \n                              .';::,.                 .;:;.                     \n                                .,;;,.                .;;;.                     \n                                  .,,,'..            .,,,'.                     \n                                   ..',,,'..      ..'','.                       \n                                     ...'''''.....'''...                        \n                                         ............                           \n                            DOPEX SINGLE STAKING OPTION VAULT\n            Mints covered calls while farming yield on single sided DPX staking farm                                                           \n*/\n\n// Libraries\nimport {Strings} from '@openzeppelin/contracts/utils/Strings.sol';\nimport {Clones} from '@openzeppelin/contracts/proxy/Clones.sol';\nimport {BokkyPooBahsDateTimeLibrary} from '../external/libraries/BokkyPooBahsDateTimeLibrary.sol';\nimport {SafeERC20} from '../external/libraries/SafeERC20.sol';\n\n// Contracts\nimport {Ownable} from '@openzeppelin/contracts/access/Ownable.sol';\nimport {ERC20PresetMinterPauserUpgradeable} from '@openzeppelin/contracts-upgradeable/token/ERC20/presets/ERC20PresetMinterPauserUpgradeable.sol';\nimport {IVolatilityOracle} from '../interfaces/IVolatilityOracle.sol';\n\n// Interfaces\nimport {IERC20} from '../external/interfaces/IERC20.sol';\nimport {IStakingRewards} from '../interfaces/IStakingRewards.sol';\nimport {IOptionPricing} from '../interfaces/IOptionPricing.sol';\nimport {IPriceOracleAggregator} from '../interfaces/IPriceOracleAggregator.sol';\nimport {ISSOV} from '../interfaces/ISSOV.sol';\n\ncontract SSOVDpx is Ownable, ISSOV {\n    using BokkyPooBahsDateTimeLibrary for uint256;\n    using Strings for uint256;\n    using SafeERC20 for IERC20;\n\n    /// @dev ERC20PresetMinterPauserUpgradeable implementation address\n    address public immutable erc20Implementation;\n\n    /// @dev Boolean of whether the vault is shutdown\n    bool public isVaultShutdown;\n\n    /// @dev Current epoch for ssov\n    uint256 public currentEpoch;\n\n    /// @dev Exercise Window Size\n    uint256 public windowSize = 1 hours;\n\n    /// @dev The list of contract addresses the contract uses\n    mapping(bytes32 => address) public addresses;\n\n    /// @dev epoch => the epoch start time\n    mapping(uint256 => uint256) public epochStartTimes;\n\n    /// @notice Is epoch expired\n    /// @dev epoch => whether the epoch is expired\n    mapping(uint256 => bool) public isEpochExpired;\n\n    /// @notice Is vault ready for next epoch\n    /// @dev epoch => whether the vault is ready (boostrapped)\n    mapping(uint256 => bool) public isVaultReady;\n\n    /// @dev Mapping of strikes for each epoch\n    mapping(uint256 => uint256[]) public epochStrikes;\n\n    /// @dev Mapping of (epoch => (strike => tokens))\n    mapping(uint256 => mapping(uint256 => address))\n        public\n        override epochStrikeTokens;\n\n    /// @notice Total epoch deposits for specific strikes\n    /// @dev mapping (epoch => (strike => deposits))\n    mapping(uint256 => mapping(uint256 => uint256))\n        public totalEpochStrikeDeposits;\n\n    /// @notice Total epoch deposits across all strikes\n    /// @dev mapping (epoch => deposits)\n    mapping(uint256 => uint256) public totalEpochDeposits;\n\n    /// @notice Total epoch deposits for specific strikes\n    /// @dev mapping (epoch => (strike => deposits))\n    mapping(uint256 => mapping(uint256 => uint256))\n        public totalEpochStrikeBalance;\n\n    /// @notice Total epoch deposits across all strikes\n    /// @dev mapping (epoch => deposits)\n    mapping(uint256 => uint256) public totalEpochBalance;\n\n    /// @notice Epoch deposits by user for each strike\n    /// @dev mapping (epoch => (abi.encodePacked(user, strike) => user deposits))\n    mapping(uint256 => mapping(bytes32 => uint256)) public userEpochDeposits;\n\n    /// @notice Epoch DPX balance per strike after accounting for rewards\n    /// @dev mapping (epoch => (strike => balance))\n    mapping(uint256 => mapping(uint256 => uint256))\n        public totalEpochStrikeDpxBalance;\n\n    /// @notice Epoch rDPX balance per strike after accounting for rewards\n    /// @dev mapping (epoch => (strike => balance))\n    mapping(uint256 => mapping(uint256 => uint256))\n        public totalEpochStrikeRdpxBalance;\n\n    // Calls purchased for each strike in an epoch\n    /// @dev mapping (epoch => (strike => calls purchased))\n    mapping(uint256 => mapping(uint256 => uint256))\n        public totalEpochCallsPurchased;\n\n    /// @notice Calls purchased by user for each strike\n    /// @dev mapping (epoch => (abi.encodePacked(user, strike) => user calls purchased))\n    mapping(uint256 => mapping(bytes32 => uint256))\n        public userEpochCallsPurchased;\n\n    /// @notice Premium (and fees) collected per strike for an epoch\n    /// @dev mapping (epoch => (strike => premium))\n    mapping(uint256 => mapping(uint256 => uint256)) public totalEpochPremium;\n\n    /// @notice User premium (and fees) collected per strike for an epoch\n    /// @dev mapping (epoch => (abi.encodePacked(user, strike) => user premium))\n    mapping(uint256 => mapping(bytes32 => uint256)) public userEpochPremium;\n\n    /// @notice Total dpx tokens that were sent back to the buyer when a options is exercised for a certain strike\n    /// @dev mapping (epoch => (strike => amount))\n    mapping(uint256 => mapping(uint256 => uint256))\n        public totalTokenVaultExercises;\n\n    bytes32 public constant PURCHASE_FEE = keccak256('purchaseFee');\n    bytes32 public constant PURCHASE_FEE_CAP = keccak256('purchaseFeeCap');\n    bytes32 public constant EXERCISE_FEE = keccak256('exerciseFee');\n    bytes32 public constant EXERCISE_FEE_CAP = keccak256('exerciseFeeCap');\n    mapping(bytes32 => uint256) public fees;\n\n    /*==== EVENTS ====*/\n\n    event LogAddressSet(bytes32 indexed name, address indexed destination);\n\n    event LogNewStrike(uint256 epoch, uint256 strike);\n\n    event LogBootstrap(uint256 epoch);\n\n    event LogNewDeposit(uint256 epoch, uint256 strike, address user);\n\n    event LogNewPurchase(\n        uint256 epoch,\n        uint256 strike,\n        address user,\n        uint256 amount,\n        uint256 premium,\n        uint256 feesToUser,\n        uint256 feeToFeeDistributor\n    );\n\n    event LogNewExercise(\n        uint256 epoch,\n        uint256 strike,\n        address user,\n        uint256 amount,\n        uint256 pnl,\n        uint256 feeTouser,\n        uint256 feeToFeeDistributor\n    );\n\n    event LogCompound(\n        uint256 epoch,\n        uint256 rewards,\n        uint256 oldBalance,\n        uint256 newBalance\n    );\n\n    event LogNewWithdrawForStrike(\n        uint256 epoch,\n        uint256 strike,\n        address user,\n        uint256 amount,\n        uint256 rdpxAmount\n    );\n\n    event LogFeesUpdate(bytes32 feeKey, uint256 amount);\n\n    event LogWindowSizeUpdate(uint256 windowSizeInHours);\n\n    event LogVaultShutdown(bool isVaultShutdown);\n\n    event LogEmergencySettle(\n        uint256 epoch,\n        uint256 strike,\n        address user,\n        uint256 amount, // of options\n        uint256 premiumReturned\n    );\n\n    /*==== CONSTRUCTOR ====*/\n\n    constructor(\n        address _dpx,\n        address _rdpx,\n        address _stakingRewards,\n        address _optionPricing,\n        address _priceOracleAggregator,\n        address _volatilityOracle,\n        address _feeDistributor\n    ) {\n        require(_dpx != address(0), 'E1');\n        require(_rdpx != address(0), 'E2');\n        require(_stakingRewards != address(0), 'E3');\n        require(_optionPricing != address(0), 'E4');\n        require(_priceOracleAggregator != address(0), 'E5');\n\n        addresses['FeeDistributor'] = _feeDistributor;\n        addresses['DPX'] = _dpx;\n        addresses['RDPX'] = _rdpx;\n        addresses['StakingRewards'] = _stakingRewards;\n        addresses['OptionPricing'] = _optionPricing;\n        addresses['PriceOracleAggregator'] = _priceOracleAggregator;\n        addresses['VolatilityOracle'] = _volatilityOracle;\n\n        fees[PURCHASE_FEE] = 2e8 / 100; // 0.02% of the price of the base asset\n        fees[PURCHASE_FEE_CAP] = 10e8; // 10% of the option price\n        fees[EXERCISE_FEE] = 1e8 / 100; // 0.01% of the price of the base asset\n        fees[EXERCISE_FEE_CAP] = 10e8; // 10% of the option price\n\n        erc20Implementation = address(new ERC20PresetMinterPauserUpgradeable());\n\n        // Max approve to stakingRewards\n        IERC20(getAddress('DPX')).safeApprove(\n            getAddress('StakingRewards'),\n            type(uint256).max\n        );\n    }\n\n    /*==== SETTER METHODS ====*/\n\n    /// @notice Shutdown the vault\n    /// @dev Can only be called by owner\n    /// @return Whether it was successfully shutdown\n    function shutdownVault() external onlyOwner returns (bool) {\n        isVaultShutdown = true;\n\n        _updateFinalEpochBalances(false);\n\n        emit LogVaultShutdown(true);\n\n        return true;\n    }\n\n    /// @notice Open the vault\n    /// @dev Can only be called by owner\n    /// @return Whether it was successfully opened\n    function openVault() external onlyOwner returns (bool) {\n        isVaultShutdown = false;\n\n        emit LogVaultShutdown(false);\n\n        return true;\n    }\n\n    /// @notice Update the fee percentage in the vault\n    /// @dev Can only be called by owner\n    /// @param feeKey The key of the fee to be updated\n    /// @param feeAmount The new amount\n    /// @return Whether it was successfully updated\n    function updateFees(bytes32 feeKey, uint256 feeAmount)\n        external\n        onlyOwner\n        returns (bool)\n    {\n        fees[feeKey] = feeAmount;\n\n        emit LogFeesUpdate(feeKey, feeAmount);\n\n        return true;\n    }\n\n    /// @notice Update the exercise window size of an option\n    /// @dev Can only be called by owner\n    /// @param _windowSize The window size\n    /// @return Whether it was successfully updated\n    function updateWindowSize(uint256 _windowSize)\n        external\n        onlyOwner\n        returns (bool)\n    {\n        windowSize = _windowSize;\n        emit LogWindowSizeUpdate(_windowSize);\n        return true;\n    }\n\n    /// @notice Sets (adds) a list of addresses to the address list\n    /// @param names Names of the contracts\n    /// @param destinations Addresses of the contract\n    /// @return Whether the addresses were set\n    function setAddresses(\n        bytes32[] calldata names,\n        address[] calldata destinations\n    ) external onlyOwner returns (bool) {\n        require(\n            names.length == destinations.length,\n            'Input lengths must match'\n        );\n        for (uint256 i = 0; i < names.length; i++) {\n            bytes32 name = names[i];\n            address destination = destinations[i];\n            addresses[name] = destination;\n            emit LogAddressSet(name, destination);\n        }\n        return true;\n    }\n\n    /*==== METHODS ====*/\n\n    /// @notice Sets the current epoch as expired.\n    /// @return Whether expire was successful\n    function expireEpoch() external onlyOwner returns (bool) {\n        // Vault must not be shutdown\n        require(!isVaultShutdown, 'E24');\n\n        // Epoch must not be expired\n        require(!isEpochExpired[currentEpoch], 'E6');\n\n        (, uint256 epochExpiry) = getEpochTimes(currentEpoch);\n        // Current timestamp should be past expiry\n        require((block.timestamp > epochExpiry), 'E7');\n\n        isEpochExpired[currentEpoch] = true;\n\n        _updateFinalEpochBalances(true);\n\n        return true;\n    }\n\n    /// @dev Updates the final epoch DPX/rDPX balances per strike of the vault\n    /// @param accountPremiums Should the fn account for premiums\n    function _updateFinalEpochBalances(bool accountPremiums) internal {\n        IStakingRewards stakingRewards = IStakingRewards(\n            getAddress('StakingRewards')\n        );\n\n        IERC20 dpx = IERC20(getAddress('DPX'));\n        IERC20 rdpx = IERC20(getAddress('RDPX'));\n\n        if (stakingRewards.balanceOf(address(this)) > 0) {\n            // Unstake all tokens from previous epoch\n            stakingRewards.withdraw(stakingRewards.balanceOf(address(this)));\n        }\n\n        uint256 totalDpxRewardsClaimed = dpx.balanceOf(address(this));\n        uint256 totalRdpxRewardsClaimed = rdpx.balanceOf(address(this));\n\n        // Claim DPX and RDPX rewards\n        stakingRewards.getReward(2);\n\n        totalDpxRewardsClaimed =\n            dpx.balanceOf(address(this)) -\n            totalDpxRewardsClaimed;\n        totalRdpxRewardsClaimed =\n            rdpx.balanceOf(address(this)) -\n            totalRdpxRewardsClaimed;\n\n        if (totalEpochBalance[currentEpoch] > 0) {\n            uint256[] memory strikes = epochStrikes[currentEpoch];\n\n            for (uint256 i = 0; i < strikes.length; i++) {\n                uint256 dpxRewards = (totalDpxRewardsClaimed *\n                    totalEpochStrikeBalance[currentEpoch][strikes[i]]) /\n                    totalEpochBalance[currentEpoch];\n\n                // Update final dpx and rdpx balances for epoch and strike\n                totalEpochStrikeDpxBalance[currentEpoch][strikes[i]] +=\n                    totalEpochStrikeDeposits[currentEpoch][strikes[i]] +\n                    dpxRewards -\n                    totalTokenVaultExercises[currentEpoch][strikes[i]];\n\n                if (accountPremiums) {\n                    totalEpochStrikeDpxBalance[currentEpoch][\n                        strikes[i]\n                    ] += totalEpochPremium[currentEpoch][strikes[i]];\n                }\n\n                totalEpochStrikeRdpxBalance[currentEpoch][strikes[i]] =\n                    (totalRdpxRewardsClaimed *\n                        totalEpochStrikeBalance[currentEpoch][strikes[i]]) /\n                    totalEpochBalance[currentEpoch];\n            }\n        }\n    }\n\n    /**\n     * @notice Bootstraps a new epoch and mints option tokens equivalent to user deposits for the epoch\n     * @return Whether bootstrap was successful\n     */\n    function bootstrap() external onlyOwner returns (bool) {\n        uint256 nextEpoch = currentEpoch + 1;\n\n        // Vault must not be ready\n        require(!isVaultReady[nextEpoch], 'E8');\n\n        // Next epoch strike must be set\n        require(epochStrikes[nextEpoch].length > 0, 'E9');\n\n        if (currentEpoch > 0) {\n            // Previous epoch must be expired\n            require(isEpochExpired[currentEpoch], 'E10');\n        }\n\n        for (uint256 i = 0; i < epochStrikes[nextEpoch].length; i++) {\n            uint256 strike = epochStrikes[nextEpoch][i];\n            string memory name = concatenate('DPX-CALL', strike.toString());\n            name = concatenate(name, '-EPOCH-');\n            name = concatenate(name, (nextEpoch).toString());\n            // Create doTokens representing calls for selected strike in epoch\n            ERC20PresetMinterPauserUpgradeable _erc20 = ERC20PresetMinterPauserUpgradeable(\n                    Clones.clone(erc20Implementation)\n                );\n            _erc20.initialize(name, name);\n            epochStrikeTokens[nextEpoch][strike] = address(_erc20);\n            // Mint tokens equivalent to deposits for strike in epoch\n            _erc20.mint(\n                address(this),\n                totalEpochStrikeDeposits[nextEpoch][strike]\n            );\n        }\n\n        // Mark vault as ready for epoch\n        isVaultReady[nextEpoch] = true;\n        // Increase the current epoch\n        currentEpoch = nextEpoch;\n\n        emit LogBootstrap(nextEpoch);\n\n        return true;\n    }\n\n    /**\n     * @notice Sets strikes for next epoch\n     * @param strikes Strikes to set for next epoch\n     * @return Whether strikes were set\n     */\n    function setStrikes(uint256[] memory strikes)\n        external\n        onlyOwner\n        returns (bool)\n    {\n        require(!isVaultShutdown, 'E24');\n        uint256 nextEpoch = currentEpoch + 1;\n\n        require(totalEpochDeposits[nextEpoch] == 0, 'E11');\n\n        if (currentEpoch > 0) {\n            (, uint256 epochExpiry) = getEpochTimes(currentEpoch);\n            // Current timestamp should be past expiry\n            require((block.timestamp > epochExpiry), 'E12');\n        }\n\n        // Set the next epoch strikes\n        epochStrikes[nextEpoch] = strikes;\n        // Set the next epoch start time\n        epochStartTimes[nextEpoch] = block.timestamp;\n\n        for (uint256 i = 0; i < strikes.length; i++)\n            emit LogNewStrike(nextEpoch, strikes[i]);\n        return true;\n    }\n\n    /**\n     * @notice Deposits dpx into the ssov to mint options in the next epoch for selected strikes\n     * @param strikeIndex Index of strike\n     * @param amount Amout of DPX to deposit\n     * @return Whether deposit was successful\n     */\n    function deposit(uint256 strikeIndex, uint256 amount)\n        public\n        returns (bool)\n    {\n        require(!isVaultShutdown, 'E24');\n\n        uint256 nextEpoch = currentEpoch + 1;\n\n        if (currentEpoch > 0) {\n            require(\n                isEpochExpired[currentEpoch] && !isVaultReady[nextEpoch],\n                'E26'\n            );\n        }\n\n        // Must be a valid strikeIndex\n        require(strikeIndex < epochStrikes[nextEpoch].length, 'E13');\n\n        // Must +ve amount\n        require(amount > 0, 'E14');\n\n        // Must be a valid strike\n        uint256 strike = epochStrikes[nextEpoch][strikeIndex];\n        require(strike != 0, 'E15');\n\n        bytes32 userStrike = keccak256(abi.encodePacked(msg.sender, strike));\n\n        // Transfer DPX from user to ssov\n        IERC20(getAddress('DPX')).safeTransferFrom(\n            msg.sender,\n            address(this),\n            amount\n        );\n\n        // Add to user epoch deposits\n        userEpochDeposits[nextEpoch][userStrike] += amount;\n        // Add to total epoch strike deposits\n        totalEpochStrikeDeposits[nextEpoch][strike] += amount;\n        // Add to total epoch deposits\n        totalEpochDeposits[nextEpoch] += amount;\n        // Add to total epoch strike deposits\n        totalEpochStrikeBalance[nextEpoch][strike] += amount;\n        // Add to total epoch deposits\n        totalEpochBalance[nextEpoch] += amount;\n        // Deposit into staking rewards\n        IStakingRewards(getAddress('StakingRewards')).stake(amount);\n\n        emit LogNewDeposit(nextEpoch, strike, msg.sender);\n\n        return true;\n    }\n\n    /**\n     * @notice Deposit DPX multiple times\n     * @param strikeIndices Indices of strikes to deposit into\n     * @param amounts Amount of DPX to deposit into each strike index\n     * @return Whether deposits went through successfully\n     */\n    function depositMultiple(\n        uint256[] memory strikeIndices,\n        uint256[] memory amounts\n    ) public returns (bool) {\n        require(strikeIndices.length == amounts.length, 'E16');\n\n        for (uint256 i = 0; i < strikeIndices.length; i++)\n            deposit(strikeIndices[i], amounts[i]);\n        return true;\n    }\n\n    /**\n     * @notice Purchases calls for the current epoch\n     * @param strikeIndex Strike index for current epoch\n     * @param amount Amount of calls to purchase\n     * @return Whether purchase was successful\n     */\n    function purchase(uint256 strikeIndex, uint256 amount)\n        external\n        override\n        returns (uint256, uint256)\n    {\n        require(!isVaultShutdown, 'E24');\n        require(currentEpoch > 0, 'E17');\n\n        // Must be a valid strikeIndex\n        require(strikeIndex < epochStrikes[currentEpoch].length, 'E13');\n\n        // Must positive amount\n        require(amount > 0, 'E14');\n\n        // Must be a valid strike\n        uint256 strike = epochStrikes[currentEpoch][strikeIndex];\n        require(strike != 0, 'E15');\n        bytes32 userStrike = keccak256(abi.encodePacked(msg.sender, strike));\n\n        address dpx = getAddress('DPX');\n        uint256 currentPrice = getUsdPrice(dpx);\n        // Get total premium for all calls being purchased\n        uint256 premium = (IOptionPricing(getAddress('OptionPricing'))\n            .getOptionPrice(\n                false,\n                getMonthlyExpiryFromTimestamp(block.timestamp),\n                strike,\n                currentPrice,\n                IVolatilityOracle(getAddress('VolatilityOracle')).getVolatility()\n            ) * amount) / currentPrice;\n\n        // total fees charged\n        uint256 totalFees = calculateFees(premium, currentPrice, true);\n\n        // 30% ( number * 0.3 ) of fees for FeeDistributor\n        uint256 feetoFeeDistrubutor = (totalFees * 3) / 10;\n\n        // Add to total epoch calls purchased\n        totalEpochCallsPurchased[currentEpoch][strike] += amount;\n        // Add to user epoch calls purchased\n        userEpochCallsPurchased[currentEpoch][userStrike] += amount;\n        // Add to total epoch premium + fees\n        totalEpochPremium[currentEpoch][strike] +=\n            premium +\n            (totalFees - feetoFeeDistrubutor);\n        // Add to user epoch premium + fees\n        userEpochPremium[currentEpoch][userStrike] +=\n            premium +\n            (totalFees - feetoFeeDistrubutor);\n\n        // Compound before updating new strike balance\n        compound();\n\n        // Add to total epoch strike balance premium + fee to vault\n        totalEpochStrikeBalance[currentEpoch][strike] +=\n            premium +\n            (totalFees - feetoFeeDistrubutor);\n\n        // Add to total epoch balance premium + fee\n        totalEpochBalance[currentEpoch] +=\n            premium +\n            (totalFees - feetoFeeDistrubutor);\n\n        // Transfer usd equivalent to premium from user\n        IERC20(dpx).safeTransferFrom(\n            msg.sender,\n            address(this),\n            premium + totalFees\n        );\n\n        IERC20(dpx).safeTransfer(\n            getAddress('FeeDistributor'),\n            feetoFeeDistrubutor\n        );\n\n        // Transfer doTokens to user\n        IERC20(epochStrikeTokens[currentEpoch][strike]).safeTransfer(\n            msg.sender,\n            amount\n        );\n\n        // Stake premium into farming\n        IStakingRewards(getAddress('StakingRewards')).stake(\n            premium + (totalFees - feetoFeeDistrubutor)\n        );\n\n        emit LogNewPurchase(\n            currentEpoch,\n            strike,\n            msg.sender,\n            amount,\n            premium,\n            totalFees,\n            feetoFeeDistrubutor\n        );\n\n        return (premium, totalFees);\n    }\n\n    /**\n     * @notice Exercise calculates the PnL for the user. Withdraw the PnL in DPX from the SSF and transfer it to the user. Will also the burn the doTokens from the user.\n     * @param strikeIndex Strike index for current epoch\n     * @param amount Amount of calls to exercise\n     * @param user Address of the user\n     * @return Pnl and Fee\n     */\n    function exercise(\n        uint256 strikeIndex,\n        uint256 amount,\n        address user\n    ) external override returns (uint256, uint256) {\n        require(!isVaultShutdown, 'E24');\n\n        uint256 epoch = currentEpoch;\n\n        (, uint256 expiry) = getEpochTimes(epoch);\n\n        // Must be in exercise window\n        require(isExerciseWindow(expiry), 'E18');\n\n        // Must be a valid strikeIndex\n        require(strikeIndex < epochStrikes[epoch].length, 'E13');\n\n        // Must positive amount\n        require(amount > 0, 'E14');\n\n        // Must be a valid strike\n        uint256 strike = epochStrikes[epoch][strikeIndex];\n        require(strike != 0, 'E15');\n\n        uint256 currentPrice = getUsdPrice(getAddress('DPX'));\n\n        // Revert if strike price is higher than current price\n        require(strike < currentPrice, 'E19');\n\n        // Revert if user is zero address\n        require(user != address(0), 'E20');\n\n        // Revert if user does not have enough option token balance for the amount specified\n        require(\n            IERC20(epochStrikeTokens[epoch][strike]).balanceOf(user) >= amount,\n            'E21'\n        );\n\n        // Calculate PnL (in DPX)\n        uint256 PnL = (((currentPrice - strike) * amount) / currentPrice);\n\n        // fee to deduct from users PnL\n        uint256 feeToUser = calculateFees(PnL, currentPrice, false);\n\n        // 30% fees to fee distributor\n        uint256 feeToFeeDistributor = (feeToUser * 3) / 10;\n\n        // Burn user option tokens\n        ERC20PresetMinterPauserUpgradeable(epochStrikeTokens[epoch][strike])\n            .burnFrom(user, amount);\n\n        // Update state to account for exercised options (amount of DPX used in exercising)\n        totalTokenVaultExercises[epoch][strike] += PnL;\n\n        if (!isVaultShutdown) {\n            IStakingRewards(getAddress('StakingRewards')).withdraw(PnL);\n        }\n\n        // Transfer PnL to user\n        IERC20(getAddress('DPX')).safeTransfer(user, PnL - feeToUser);\n\n        // transfer fees to FeeDistributor\n        IERC20(getAddress('DPX')).safeTransfer(\n            getAddress('FeeDistributor'),\n            feeToFeeDistributor\n        );\n\n        emit LogNewExercise(\n            epoch,\n            strike,\n            user,\n            amount,\n            PnL,\n            feeToUser,\n            feeToFeeDistributor\n        );\n\n        return (PnL, feeToUser);\n    }\n\n    /**\n     * @notice Allows a user to settle their options due to an emergency shutdown. Returns the premium to the user.\n     * @param strikeIndex Strike index for current epoch\n     * @param amount Amount of calls to exercise\n     * @param user Address of the user\n     */\n    function emergencySettle(\n        uint256 strikeIndex,\n        uint256 amount,\n        address user\n    ) external returns (uint256) {\n        // Vault must be shutdown\n        require(isVaultShutdown, 'E25');\n\n        uint256 epoch = currentEpoch;\n\n        // Must be a valid strikeIndex\n        require(strikeIndex < epochStrikes[epoch].length, 'E13');\n\n        // Must positive amount\n        require(amount > 0, 'E14');\n\n        // Must be a valid strike\n        uint256 strike = epochStrikes[epoch][strikeIndex];\n        require(strike != 0, 'E15');\n\n        // Revert if user is zero address\n        require(user != address(0), 'E20');\n\n        // Revert if user does not have enough option token balance for the amount specified\n        require(\n            IERC20(epochStrikeTokens[epoch][strike]).balanceOf(user) >= amount,\n            'E21'\n        );\n\n        // Burn user option tokens\n        ERC20PresetMinterPauserUpgradeable(epochStrikeTokens[epoch][strike])\n            .burnFrom(user, amount);\n\n        bytes32 userStrike = keccak256(abi.encodePacked(msg.sender, strike));\n\n        uint256 userPremium = userEpochPremium[epoch][userStrike];\n\n        userEpochPremium[epoch][userStrike] = 0;\n\n        // Transfer premium to user\n        IERC20(getAddress('DPX')).safeTransfer(user, userPremium);\n\n        emit LogEmergencySettle(epoch, strike, user, amount, userPremium);\n\n        return userPremium;\n    }\n\n    /**\n     * @notice Allows anyone to call compound()\n     * @return Whether compound was successful\n     */\n    function compound() public returns (bool) {\n        require(!isVaultShutdown, 'E24');\n        require(!isEpochExpired[currentEpoch], 'E6');\n        require(isVaultReady[currentEpoch], 'E27');\n\n        if (currentEpoch == 0) {\n            return false;\n        }\n\n        IStakingRewards stakingRewards = IStakingRewards(\n            getAddress('StakingRewards')\n        );\n\n        uint256 oldBalance = stakingRewards.balanceOf(address(this));\n\n        (uint256 rewardsDPX, ) = stakingRewards.earned(address(this));\n\n        // Account for DPX rewards per strike deposit\n        uint256[] memory strikes = epochStrikes[currentEpoch];\n        for (uint256 i = 0; i < strikes.length; i++) {\n            uint256 strikeRewards = (rewardsDPX *\n                totalEpochStrikeDeposits[currentEpoch][strikes[i]]) /\n                totalEpochDeposits[currentEpoch];\n\n            totalEpochStrikeDpxBalance[currentEpoch][\n                strikes[i]\n            ] += strikeRewards;\n\n            totalEpochStrikeBalance[currentEpoch][strikes[i]] += strikeRewards;\n        }\n\n        totalEpochBalance[currentEpoch] += rewardsDPX;\n        if (rewardsDPX > 0) {\n            // Compound staking rewards\n            stakingRewards.compound();\n        }\n\n        emit LogCompound(\n            currentEpoch,\n            rewardsDPX,\n            oldBalance,\n            stakingRewards.balanceOf(address(this))\n        );\n\n        return true;\n    }\n\n    /**\n     * @notice Withdraws balances for a strike in a completed epoch\n     * @param withdrawEpoch Epoch to withdraw from\n     * @param strikeIndex Index of strike\n     * @return Whether withdraw was successful\n     */\n    function withdrawForStrike(uint256 withdrawEpoch, uint256 strikeIndex)\n        external\n        returns (bool)\n    {\n        // Epoch must be expired\n        require(isEpochExpired[withdrawEpoch], 'E22');\n\n        _withdraw(withdrawEpoch, strikeIndex);\n\n        return true;\n    }\n\n    /**\n     * @notice Emergency withdraws balances for a strike\n     * @dev Vault must be shutdown for this\n     * @param strikeIndex Index of strike\n     * @return Whether withdraw was successful\n     */\n    function emergencyWithdrawForStrike(uint256 strikeIndex)\n        external\n        returns (bool)\n    {\n        require(isVaultShutdown, 'E25');\n\n        _withdraw(currentEpoch, strikeIndex);\n\n        return true;\n    }\n\n    /// @dev Internal function to handle a withdraw\n    /// @param withdrawEpoch Epoch to withdraw from\n    /// @param strikeIndex Index of strike\n    function _withdraw(uint256 withdrawEpoch, uint256 strikeIndex) internal {\n        // Must be a valid strikeIndex\n        require(strikeIndex < epochStrikes[withdrawEpoch].length, 'E13');\n\n        // Must be a valid strike\n        uint256 strike = epochStrikes[withdrawEpoch][strikeIndex];\n        require(strike != 0, 'E15');\n\n        // Must be a valid user strike deposit amount\n        bytes32 userStrike = keccak256(abi.encodePacked(msg.sender, strike));\n        uint256 userStrikeDeposits = userEpochDeposits[withdrawEpoch][\n            userStrike\n        ];\n\n        require(userStrikeDeposits > 0, 'E23');\n\n        address rdpx = getAddress('RDPX');\n        // Transfer RDPX tokens to user\n        uint256 userRdpxAmount = (totalEpochStrikeRdpxBalance[withdrawEpoch][\n            strike\n        ] * userStrikeDeposits) /\n            totalEpochStrikeDeposits[withdrawEpoch][strike];\n\n        // Transfer DPX tokens to user\n        address dpx = getAddress('DPX');\n        uint256 userDpxAmount = (totalEpochStrikeDpxBalance[withdrawEpoch][\n            strike\n        ] * userStrikeDeposits) /\n            totalEpochStrikeDeposits[withdrawEpoch][strike];\n\n        userEpochDeposits[withdrawEpoch][userStrike] = 0;\n\n        IERC20(rdpx).safeTransfer(msg.sender, userRdpxAmount);\n\n        IERC20(dpx).safeTransfer(msg.sender, userDpxAmount);\n\n        emit LogNewWithdrawForStrike(\n            withdrawEpoch,\n            strike,\n            msg.sender,\n            userStrikeDeposits,\n            userRdpxAmount\n        );\n    }\n\n    /*==== PURE FUNCTIONS ====*/\n\n    /// @notice Calculates the monthly expiry from a solidity date\n    /// @param timestamp Timestamp from which the monthly expiry is to be calculated\n    /// @return The monthly expiry\n    function getMonthlyExpiryFromTimestamp(uint256 timestamp)\n        public\n        pure\n        returns (uint256)\n    {\n        uint256 lastDay = BokkyPooBahsDateTimeLibrary.timestampFromDate(\n            timestamp.getYear(),\n            timestamp.getMonth() + 1,\n            0\n        );\n\n        if (lastDay.getDayOfWeek() < 5) {\n            lastDay = BokkyPooBahsDateTimeLibrary.timestampFromDate(\n                lastDay.getYear(),\n                lastDay.getMonth(),\n                lastDay.getDay() - 7\n            );\n        }\n\n        uint256 lastFridayOfMonth = BokkyPooBahsDateTimeLibrary\n            .timestampFromDateTime(\n                lastDay.getYear(),\n                lastDay.getMonth(),\n                lastDay.getDay() + 5 - lastDay.getDayOfWeek(),\n                8,\n                0,\n                0\n            );\n\n        if (lastFridayOfMonth <= timestamp) {\n            uint256 temp = BokkyPooBahsDateTimeLibrary.timestampFromDate(\n                timestamp.getYear(),\n                timestamp.getMonth() + 2,\n                0\n            );\n\n            if (temp.getDayOfWeek() < 5) {\n                temp = BokkyPooBahsDateTimeLibrary.timestampFromDate(\n                    temp.getYear(),\n                    temp.getMonth(),\n                    temp.getDay() - 7\n                );\n            }\n\n            lastFridayOfMonth = BokkyPooBahsDateTimeLibrary\n                .timestampFromDateTime(\n                    temp.getYear(),\n                    temp.getMonth(),\n                    temp.getDay() + 5 - temp.getDayOfWeek(),\n                    8,\n                    0,\n                    0\n                );\n        }\n        return lastFridayOfMonth;\n    }\n\n    /**\n     * @notice Returns a concatenated string of a and b\n     * @param a string a\n     * @param b string b\n     */\n    function concatenate(string memory a, string memory b)\n        internal\n        pure\n        returns (string memory)\n    {\n        return string(abi.encodePacked(a, b));\n    }\n\n    /*==== VIEWS ====*/\n\n    /// @notice calculates fees for a given amount\n    /// @param amountToCharge amount from which fees is charged from\n    /// @param dpxPrice last price of DPX in USDT\n    /// @param isPurchase if true, uses purchase fees values, if false, uses exercise fees values\n    function calculateFees(\n        uint256 amountToCharge,\n        uint256 dpxPrice,\n        bool isPurchase\n    ) public view returns (uint256) {\n        uint256 fee = isPurchase ? fees[PURCHASE_FEE] : fees[EXERCISE_FEE];\n        uint256 feeCap = isPurchase\n            ? fees[PURCHASE_FEE_CAP]\n            : fees[EXERCISE_FEE_CAP];\n\n        uint256 baseAssetFees = (dpxPrice * fee) / 1e10;\n        uint256 optionPriceFees = (amountToCharge * feeCap * dpxPrice) / 1e28;\n\n        if (baseAssetFees > optionPriceFees) {\n            return (optionPriceFees * 1e18) / dpxPrice;\n        } else {\n            return (baseAssetFees * 1e18) / dpxPrice;\n        }\n    }\n\n    /**\n     * @notice Returns start and end times for an epoch\n     * @param epoch Target epoch\n     */\n    function getEpochTimes(uint256 epoch)\n        public\n        view\n        returns (uint256 start, uint256 end)\n    {\n        require(epoch > 0, 'E17');\n\n        return (\n            epochStartTimes[epoch],\n            getMonthlyExpiryFromTimestamp(epochStartTimes[epoch])\n        );\n    }\n\n    /**\n     * @notice Returns epoch strikes array for an epoch\n     * @param epoch Target epoch\n     */\n    function getEpochStrikes(uint256 epoch)\n        external\n        view\n        returns (uint256[] memory)\n    {\n        require(epoch > 0, 'E17');\n\n        return epochStrikes[epoch];\n    }\n\n    /**\n     * Returns epoch strike tokens array for an epoch\n     * @param epoch Target epoch\n     */\n    function getEpochStrikeTokens(uint256 epoch)\n        external\n        view\n        returns (address[] memory)\n    {\n        require(epoch > 0, 'E17');\n\n        uint256 length = epochStrikes[epoch].length;\n        address[] memory _epochStrikeTokens = new address[](length);\n\n        for (uint256 i = 0; i < length; i++) {\n            _epochStrikeTokens[i] = epochStrikeTokens[epoch][\n                epochStrikes[epoch][i]\n            ];\n        }\n\n        return _epochStrikeTokens;\n    }\n\n    /**\n     * @notice Returns total epoch strike deposits array for an epoch\n     * @param epoch Target epoch\n     */\n    function getTotalEpochStrikeDeposits(uint256 epoch)\n        external\n        view\n        returns (uint256[] memory)\n    {\n        require(epoch > 0, 'E17');\n\n        uint256 length = epochStrikes[epoch].length;\n        uint256[] memory _totalEpochStrikeDeposits = new uint256[](length);\n\n        for (uint256 i = 0; i < length; i++) {\n            _totalEpochStrikeDeposits[i] = totalEpochStrikeDeposits[epoch][\n                epochStrikes[epoch][i]\n            ];\n        }\n\n        return _totalEpochStrikeDeposits;\n    }\n\n    /**\n     * @notice Returns user epoch deposits array for an epoch\n     * @param epoch Target epoch\n     * @param user Address of the user\n     */\n    function getUserEpochDeposits(uint256 epoch, address user)\n        external\n        view\n        returns (uint256[] memory)\n    {\n        require(epoch > 0, 'E17');\n\n        uint256 length = epochStrikes[epoch].length;\n        uint256[] memory _userEpochDeposits = new uint256[](length);\n\n        for (uint256 i = 0; i < length; i++) {\n            uint256 strike = epochStrikes[epoch][i];\n            bytes32 userStrike = keccak256(abi.encodePacked(user, strike));\n\n            _userEpochDeposits[i] = userEpochDeposits[epoch][userStrike];\n        }\n\n        return _userEpochDeposits;\n    }\n\n    /**\n     * @notice Returns total epoch calls purchased array for an epoch\n     * @param epoch Target epoch\n     */\n    function getTotalEpochCallsPurchased(uint256 epoch)\n        external\n        view\n        returns (uint256[] memory)\n    {\n        require(epoch > 0, 'E17');\n\n        uint256 length = epochStrikes[epoch].length;\n        uint256[] memory _totalEpochCallsPurchased = new uint256[](length);\n\n        for (uint256 i = 0; i < length; i++) {\n            _totalEpochCallsPurchased[i] = totalEpochCallsPurchased[epoch][\n                epochStrikes[epoch][i]\n            ];\n        }\n\n        return _totalEpochCallsPurchased;\n    }\n\n    /**\n     * @notice Returns user epoch calls purchased array for an epoch\n     * @param epoch Target epoch\n     * @param user Address of the user\n     */\n    function getUserEpochCallsPurchased(uint256 epoch, address user)\n        external\n        view\n        returns (uint256[] memory)\n    {\n        require(epoch > 0, 'E17');\n\n        uint256 length = epochStrikes[epoch].length;\n        uint256[] memory _userEpochCallsPurchased = new uint256[](length);\n\n        for (uint256 i = 0; i < length; i++) {\n            uint256 strike = epochStrikes[epoch][i];\n            bytes32 userStrike = keccak256(abi.encodePacked(user, strike));\n\n            _userEpochCallsPurchased[i] = userEpochCallsPurchased[epoch][\n                userStrike\n            ];\n        }\n\n        return _userEpochCallsPurchased;\n    }\n\n    /**\n     * @notice Returns total epoch premium array for an epoch\n     * @param epoch Target epoch\n     */\n    function getTotalEpochPremium(uint256 epoch)\n        external\n        view\n        returns (uint256[] memory)\n    {\n        require(epoch > 0, 'E17');\n\n        uint256 length = epochStrikes[epoch].length;\n        uint256[] memory _totalEpochPremium = new uint256[](length);\n\n        for (uint256 i = 0; i < length; i++) {\n            _totalEpochPremium[i] = totalEpochPremium[epoch][\n                epochStrikes[epoch][i]\n            ];\n        }\n\n        return _totalEpochPremium;\n    }\n\n    /**\n     * @notice Returns user epoch premium array for an epoch\n     * @param epoch Target epoch\n     * @param user Address of the user\n     */\n    function getUserEpochPremium(uint256 epoch, address user)\n        external\n        view\n        returns (uint256[] memory)\n    {\n        require(epoch > 0, 'E17');\n\n        uint256 length = epochStrikes[epoch].length;\n        uint256[] memory _userEpochPremium = new uint256[](length);\n\n        for (uint256 i = 0; i < length; i++) {\n            uint256 strike = epochStrikes[epoch][i];\n            bytes32 userStrike = keccak256(abi.encodePacked(user, strike));\n\n            _userEpochPremium[i] = userEpochPremium[epoch][userStrike];\n        }\n\n        return _userEpochPremium;\n    }\n\n    /**\n     * @notice Update & Returns token's price in USD\n     * @param _token Address of the token\n     */\n    function getUsdPrice(address _token) public returns (uint256) {\n        return\n            IPriceOracleAggregator(getAddress('PriceOracleAggregator'))\n                .getPriceInUSD(_token);\n    }\n\n    /**\n     * @notice Returns token's price in USD\n     * @param _token Address of the token\n     */\n    function viewUsdPrice(address _token) external view returns (uint256) {\n        return\n            IPriceOracleAggregator(getAddress('PriceOracleAggregator'))\n                .viewPriceInUSD(_token);\n    }\n\n    /**\n     * @notice Returns true if exercise can be called\n     * @param expiry The expiry of the option\n     */\n    function isExerciseWindow(uint256 expiry) public view returns (bool) {\n        return ((block.timestamp >= expiry - windowSize) &&\n            (block.timestamp < expiry));\n    }\n\n    /**\n     * @notice Gets the address of a set contract\n     * @param name Name of the contract\n     * @return The address of the contract\n     */\n    function getAddress(bytes32 name) public view override returns (address) {\n        return addresses[name];\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant alphabet = \"0123456789abcdef\";\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI's implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0x00\";\n        }\n        uint256 temp = value;\n        uint256 length = 0;\n        while (temp != 0) {\n            length++;\n            temp >>= 8;\n        }\n        return toHexString(value, length);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = alphabet[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n\n}\n"
    },
    "@openzeppelin/contracts/proxy/Clones.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev https://eips.ethereum.org/EIPS/eip-1167[EIP 1167] is a standard for\n * deploying minimal proxy contracts, also known as \"clones\".\n *\n * > To simply and cheaply clone contract functionality in an immutable way, this standard specifies\n * > a minimal bytecode implementation that delegates all calls to a known, fixed address.\n *\n * The library includes functions to deploy a proxy using either `create` (traditional deployment) or `create2`\n * (salted deterministic deployment). It also includes functions to predict the addresses of clones deployed using the\n * deterministic method.\n *\n * _Available since v3.4._\n */\nlibrary Clones {\n    /**\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\n     *\n     * This function uses the create opcode, which should never revert.\n     */\n    function clone(address implementation) internal returns (address instance) {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\n            instance := create(0, ptr, 0x37)\n        }\n        require(instance != address(0), \"ERC1167: create failed\");\n    }\n\n    /**\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\n     *\n     * This function uses the create2 opcode and a `salt` to deterministically deploy\n     * the clone. Using the same `implementation` and `salt` multiple time will revert, since\n     * the clones cannot be deployed twice at the same address.\n     */\n    function cloneDeterministic(address implementation, bytes32 salt) internal returns (address instance) {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\n            instance := create2(0, ptr, 0x37, salt)\n        }\n        require(instance != address(0), \"ERC1167: create2 failed\");\n    }\n\n    /**\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\n     */\n    function predictDeterministicAddress(address implementation, bytes32 salt, address deployer) internal pure returns (address predicted) {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf3ff00000000000000000000000000000000)\n            mstore(add(ptr, 0x38), shl(0x60, deployer))\n            mstore(add(ptr, 0x4c), salt)\n            mstore(add(ptr, 0x6c), keccak256(ptr, 0x37))\n            predicted := keccak256(add(ptr, 0x37), 0x55)\n        }\n    }\n\n    /**\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\n     */\n    function predictDeterministicAddress(address implementation, bytes32 salt) internal view returns (address predicted) {\n        return predictDeterministicAddress(implementation, salt, address(this));\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/presets/ERC20PresetMinterPauserUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../ERC20Upgradeable.sol\";\nimport \"../extensions/ERC20BurnableUpgradeable.sol\";\nimport \"../extensions/ERC20PausableUpgradeable.sol\";\nimport \"../../../access/AccessControlEnumerableUpgradeable.sol\";\nimport \"../../../utils/ContextUpgradeable.sol\";\nimport \"../../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev {ERC20} token, including:\n *\n *  - ability for holders to burn (destroy) their tokens\n *  - a minter role that allows for token minting (creation)\n *  - a pauser role that allows to stop all token transfers\n *\n * This contract uses {AccessControl} to lock permissioned functions using the\n * different roles - head to its documentation for details.\n *\n * The account that deploys the contract will be granted the minter and pauser\n * roles, as well as the default admin role, which will let it grant both minter\n * and pauser roles to other accounts.\n */\ncontract ERC20PresetMinterPauserUpgradeable is Initializable, ContextUpgradeable, AccessControlEnumerableUpgradeable, ERC20BurnableUpgradeable, ERC20PausableUpgradeable {\n    function initialize(string memory name, string memory symbol) public virtual initializer {\n        __ERC20PresetMinterPauser_init(name, symbol);\n    }\n    bytes32 public constant MINTER_ROLE = keccak256(\"MINTER_ROLE\");\n    bytes32 public constant PAUSER_ROLE = keccak256(\"PAUSER_ROLE\");\n\n    /**\n     * @dev Grants `DEFAULT_ADMIN_ROLE`, `MINTER_ROLE` and `PAUSER_ROLE` to the\n     * account that deploys the contract.\n     *\n     * See {ERC20-constructor}.\n     */\n    function __ERC20PresetMinterPauser_init(string memory name, string memory symbol) internal initializer {\n        __Context_init_unchained();\n        __ERC165_init_unchained();\n        __AccessControl_init_unchained();\n        __AccessControlEnumerable_init_unchained();\n        __ERC20_init_unchained(name, symbol);\n        __ERC20Burnable_init_unchained();\n        __Pausable_init_unchained();\n        __ERC20Pausable_init_unchained();\n        __ERC20PresetMinterPauser_init_unchained(name, symbol);\n    }\n\n    function __ERC20PresetMinterPauser_init_unchained(string memory name, string memory symbol) internal initializer {\n        _setupRole(DEFAULT_ADMIN_ROLE, _msgSender());\n\n        _setupRole(MINTER_ROLE, _msgSender());\n        _setupRole(PAUSER_ROLE, _msgSender());\n    }\n\n    /**\n     * @dev Creates `amount` new tokens for `to`.\n     *\n     * See {ERC20-_mint}.\n     *\n     * Requirements:\n     *\n     * - the caller must have the `MINTER_ROLE`.\n     */\n    function mint(address to, uint256 amount) public virtual {\n        require(hasRole(MINTER_ROLE, _msgSender()), \"ERC20PresetMinterPauser: must have minter role to mint\");\n        _mint(to, amount);\n    }\n\n    /**\n     * @dev Pauses all token transfers.\n     *\n     * See {ERC20Pausable} and {Pausable-_pause}.\n     *\n     * Requirements:\n     *\n     * - the caller must have the `PAUSER_ROLE`.\n     */\n    function pause() public virtual {\n        require(hasRole(PAUSER_ROLE, _msgSender()), \"ERC20PresetMinterPauser: must have pauser role to pause\");\n        _pause();\n    }\n\n    /**\n     * @dev Unpauses all token transfers.\n     *\n     * See {ERC20Pausable} and {Pausable-_unpause}.\n     *\n     * Requirements:\n     *\n     * - the caller must have the `PAUSER_ROLE`.\n     */\n    function unpause() public virtual {\n        require(hasRole(PAUSER_ROLE, _msgSender()), \"ERC20PresetMinterPauser: must have pauser role to unpause\");\n        _unpause();\n    }\n\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual override(ERC20Upgradeable, ERC20PausableUpgradeable) {\n        super._beforeTokenTransfer(from, to, amount);\n    }\n    uint256[50] private __gap;\n}\n"
    },
    "contracts/interfaces/IVolatilityOracle.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.0;\n\ninterface IVolatilityOracle {\n    function getVolatility() external returns (uint256);\n}\n"
    },
    "contracts/interfaces/IOptionPricing.sol": {
      "content": "//SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.0;\n\ninterface IOptionPricing {\n  function getOptionPrice(\n    bool isPut,\n    uint256 expiry,\n    uint256 strike,\n    uint256 lastPrice,\n    uint256 baseIv\n  ) external view returns (uint256);\n}\n"
    },
    "contracts/interfaces/IPriceOracleAggregator.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.0;\n\nimport { IOracle } from \"./IOracle.sol\";\n\ninterface IPriceOracleAggregator {\n  event UpdateOracle(address token, IOracle oracle);\n\n  function getPriceInUSD(address _token) external returns (uint256);\n\n  function updateOracleForAsset(address _asset, IOracle _oracle) external;\n\n  function viewPriceInUSD(address _token) external view returns (uint256);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20Upgradeable.sol\";\nimport \"./extensions/IERC20MetadataUpgradeable.sol\";\nimport \"../../utils/ContextUpgradeable.sol\";\nimport \"../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin guidelines: functions revert instead\n * of returning `false` on failure. This behavior is nonetheless conventional\n * and does not conflict with the expectations of ERC20 applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20Upgradeable is Initializable, ContextUpgradeable, IERC20Upgradeable, IERC20MetadataUpgradeable {\n    mapping (address => uint256) private _balances;\n\n    mapping (address => mapping (address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * The defaut value of {decimals} is 18. To select a different value for\n     * {decimals} you should overload it.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    function __ERC20_init(string memory name_, string memory symbol_) internal initializer {\n        __Context_init_unchained();\n        __ERC20_init_unchained(name_, symbol_);\n    }\n\n    function __ERC20_init_unchained(string memory name_, string memory symbol_) internal initializer {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\n     * overridden;\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * Requirements:\n     *\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``sender``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(sender, recipient, amount);\n\n        uint256 currentAllowance = _allowances[sender][_msgSender()];\n        require(currentAllowance >= amount, \"ERC20: transfer amount exceeds allowance\");\n        _approve(sender, _msgSender(), currentAllowance - amount);\n\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender] + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        uint256 currentAllowance = _allowances[_msgSender()][spender];\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        _approve(_msgSender(), spender, currentAllowance - subtractedValue);\n\n        return true;\n    }\n\n    /**\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\n     *\n     * This is internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(sender, recipient, amount);\n\n        uint256 senderBalance = _balances[sender];\n        require(senderBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        _balances[sender] = senderBalance - amount;\n        _balances[recipient] += amount;\n\n        emit Transfer(sender, recipient, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        _balances[account] += amount;\n        emit Transfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        _balances[account] = accountBalance - amount;\n        _totalSupply -= amount;\n\n        emit Transfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be to transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }\n    uint256[45] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/extensions/ERC20BurnableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../ERC20Upgradeable.sol\";\nimport \"../../../utils/ContextUpgradeable.sol\";\nimport \"../../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Extension of {ERC20} that allows token holders to destroy both their own\n * tokens and those that they have an allowance for, in a way that can be\n * recognized off-chain (via event analysis).\n */\nabstract contract ERC20BurnableUpgradeable is Initializable, ContextUpgradeable, ERC20Upgradeable {\n    function __ERC20Burnable_init() internal initializer {\n        __Context_init_unchained();\n        __ERC20Burnable_init_unchained();\n    }\n\n    function __ERC20Burnable_init_unchained() internal initializer {\n    }\n    /**\n     * @dev Destroys `amount` tokens from the caller.\n     *\n     * See {ERC20-_burn}.\n     */\n    function burn(uint256 amount) public virtual {\n        _burn(_msgSender(), amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, deducting from the caller's\n     * allowance.\n     *\n     * See {ERC20-_burn} and {ERC20-allowance}.\n     *\n     * Requirements:\n     *\n     * - the caller must have allowance for ``accounts``'s tokens of at least\n     * `amount`.\n     */\n    function burnFrom(address account, uint256 amount) public virtual {\n        uint256 currentAllowance = allowance(account, _msgSender());\n        require(currentAllowance >= amount, \"ERC20: burn amount exceeds allowance\");\n        _approve(account, _msgSender(), currentAllowance - amount);\n        _burn(account, amount);\n    }\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/extensions/ERC20PausableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../ERC20Upgradeable.sol\";\nimport \"../../../security/PausableUpgradeable.sol\";\nimport \"../../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev ERC20 token with pausable token transfers, minting and burning.\n *\n * Useful for scenarios such as preventing trades until the end of an evaluation\n * period, or having an emergency switch for freezing all token transfers in the\n * event of a large bug.\n */\nabstract contract ERC20PausableUpgradeable is Initializable, ERC20Upgradeable, PausableUpgradeable {\n    function __ERC20Pausable_init() internal initializer {\n        __Context_init_unchained();\n        __Pausable_init_unchained();\n        __ERC20Pausable_init_unchained();\n    }\n\n    function __ERC20Pausable_init_unchained() internal initializer {\n    }\n    /**\n     * @dev See {ERC20-_beforeTokenTransfer}.\n     *\n     * Requirements:\n     *\n     * - the contract must not be paused.\n     */\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual override {\n        super._beforeTokenTransfer(from, to, amount);\n\n        require(!paused(), \"ERC20Pausable: token transfer while paused\");\n    }\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/access/AccessControlEnumerableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./AccessControlUpgradeable.sol\";\nimport \"../utils/structs/EnumerableSetUpgradeable.sol\";\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev External interface of AccessControlEnumerable declared to support ERC165 detection.\n */\ninterface IAccessControlEnumerableUpgradeable {\n    function getRoleMember(bytes32 role, uint256 index) external view returns (address);\n    function getRoleMemberCount(bytes32 role) external view returns (uint256);\n}\n\n/**\n * @dev Extension of {AccessControl} that allows enumerating the members of each role.\n */\nabstract contract AccessControlEnumerableUpgradeable is Initializable, IAccessControlEnumerableUpgradeable, AccessControlUpgradeable {\n    function __AccessControlEnumerable_init() internal initializer {\n        __Context_init_unchained();\n        __ERC165_init_unchained();\n        __AccessControl_init_unchained();\n        __AccessControlEnumerable_init_unchained();\n    }\n\n    function __AccessControlEnumerable_init_unchained() internal initializer {\n    }\n    using EnumerableSetUpgradeable for EnumerableSetUpgradeable.AddressSet;\n\n    mapping (bytes32 => EnumerableSetUpgradeable.AddressSet) private _roleMembers;\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControlEnumerableUpgradeable).interfaceId\n            || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns one of the accounts that have `role`. `index` must be a\n     * value between 0 and {getRoleMemberCount}, non-inclusive.\n     *\n     * Role bearers are not sorted in any particular way, and their ordering may\n     * change at any point.\n     *\n     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\n     * you perform all queries on the same block. See the following\n     * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]\n     * for more information.\n     */\n    function getRoleMember(bytes32 role, uint256 index) public view override returns (address) {\n        return _roleMembers[role].at(index);\n    }\n\n    /**\n     * @dev Returns the number of accounts that have `role`. Can be used\n     * together with {getRoleMember} to enumerate all bearers of a role.\n     */\n    function getRoleMemberCount(bytes32 role) public view override returns (uint256) {\n        return _roleMembers[role].length();\n    }\n\n    /**\n     * @dev Overload {grantRole} to track enumerable memberships\n     */\n    function grantRole(bytes32 role, address account) public virtual override {\n        super.grantRole(role, account);\n        _roleMembers[role].add(account);\n    }\n\n    /**\n     * @dev Overload {revokeRole} to track enumerable memberships\n     */\n    function revokeRole(bytes32 role, address account) public virtual override {\n        super.revokeRole(role, account);\n        _roleMembers[role].remove(account);\n    }\n\n    /**\n     * @dev Overload {renounceRole} to track enumerable memberships\n     */\n    function renounceRole(bytes32 role, address account) public virtual override {\n        super.renounceRole(role, account);\n        _roleMembers[role].remove(account);\n    }\n\n    /**\n     * @dev Overload {_setupRole} to track enumerable memberships\n     */\n    function _setupRole(bytes32 role, address account) internal virtual override {\n        super._setupRole(role, account);\n        _roleMembers[role].add(account);\n    }\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\nimport \"../proxy/utils/Initializable.sol\";\n\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract ContextUpgradeable is Initializable {\n    function __Context_init() internal initializer {\n        __Context_init_unchained();\n    }\n\n    function __Context_init_unchained() internal initializer {\n    }\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\n// solhint-disable-next-line compiler-version\npragma solidity ^0.8.0;\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since a proxied contract can't have a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n */\nabstract contract Initializable {\n\n    /**\n     * @dev Indicates that the contract has been initialized.\n     */\n    bool private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Modifier to protect an initializer function from being invoked twice.\n     */\n    modifier initializer() {\n        require(_initializing || !_initialized, \"Initializable: contract is already initialized\");\n\n        bool isTopLevelCall = !_initializing;\n        if (isTopLevelCall) {\n            _initializing = true;\n            _initialized = true;\n        }\n\n        _;\n\n        if (isTopLevelCall) {\n            _initializing = false;\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20Upgradeable {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/extensions/IERC20MetadataUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20Upgradeable.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20MetadataUpgradeable is IERC20Upgradeable {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../utils/ContextUpgradeable.sol\";\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module which allows children to implement an emergency stop\n * mechanism that can be triggered by an authorized account.\n *\n * This module is used through inheritance. It will make available the\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n * the functions of your contract. Note that they will not be pausable by\n * simply including this module, only once the modifiers are put in place.\n */\nabstract contract PausableUpgradeable is Initializable, ContextUpgradeable {\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    bool private _paused;\n\n    /**\n     * @dev Initializes the contract in unpaused state.\n     */\n    function __Pausable_init() internal initializer {\n        __Context_init_unchained();\n        __Pausable_init_unchained();\n    }\n\n    function __Pausable_init_unchained() internal initializer {\n        _paused = false;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view virtual returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        require(!paused(), \"Pausable: paused\");\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        require(paused(), \"Pausable: not paused\");\n        _;\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../utils/ContextUpgradeable.sol\";\nimport \"../utils/StringsUpgradeable.sol\";\nimport \"../utils/introspection/ERC165Upgradeable.sol\";\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev External interface of AccessControl declared to support ERC165 detection.\n */\ninterface IAccessControlUpgradeable {\n    function hasRole(bytes32 role, address account) external view returns (bool);\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n    function grantRole(bytes32 role, address account) external;\n    function revokeRole(bytes32 role, address account) external;\n    function renounceRole(bytes32 role, address account) external;\n}\n\n/**\n * @dev Contract module that allows children to implement role-based access\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\n * members except through off-chain means by accessing the contract event logs. Some\n * applications may benefit from on-chain enumerability, for those cases see\n * {AccessControlEnumerable}.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```\n * function foo() public {\n *     require(hasRole(MY_ROLE, msg.sender));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n *\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it.\n */\nabstract contract AccessControlUpgradeable is Initializable, ContextUpgradeable, IAccessControlUpgradeable, ERC165Upgradeable {\n    function __AccessControl_init() internal initializer {\n        __Context_init_unchained();\n        __ERC165_init_unchained();\n        __AccessControl_init_unchained();\n    }\n\n    function __AccessControl_init_unchained() internal initializer {\n    }\n    struct RoleData {\n        mapping (address => bool) members;\n        bytes32 adminRole;\n    }\n\n    mapping (bytes32 => RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     *\n     * _Available since v3.1._\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {_setupRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with a standardized message including the required role.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{20}) is missing role (0x[0-9a-f]{32})$/\n     *\n     * _Available since v4.1._\n     */\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role, _msgSender());\n        _;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControlUpgradeable).interfaceId\n            || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view override returns (bool) {\n        return _roles[role].members[account];\n    }\n\n    /**\n     * @dev Revert with a standard message if `account` is missing `role`.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{20}) is missing role (0x[0-9a-f]{32})$/\n     */\n    function _checkRole(bytes32 role, address account) internal view {\n        if(!hasRole(role, account)) {\n            revert(string(abi.encodePacked(\n                \"AccessControl: account \",\n                StringsUpgradeable.toHexString(uint160(account), 20),\n                \" is missing role \",\n                StringsUpgradeable.toHexString(uint256(role), 32)\n            )));\n        }\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view override returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     */\n    function renounceRole(bytes32 role, address account) public virtual override {\n        require(account == _msgSender(), \"AccessControl: can only renounce roles for self\");\n\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event. Note that unlike {grantRole}, this function doesn't perform any\n     * checks on the calling account.\n     *\n     * [WARNING]\n     * ====\n     * This function should only be called from the constructor when setting\n     * up the initial roles for the system.\n     *\n     * Using this function in any other way is effectively circumventing the admin\n     * system imposed by {AccessControl}.\n     * ====\n     */\n    function _setupRole(bytes32 role, address account) internal virtual {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        emit RoleAdminChanged(role, getRoleAdmin(role), adminRole);\n        _roles[role].adminRole = adminRole;\n    }\n\n    function _grantRole(bytes32 role, address account) private {\n        if (!hasRole(role, account)) {\n            _roles[role].members[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n        }\n    }\n\n    function _revokeRole(bytes32 role, address account) private {\n        if (hasRole(role, account)) {\n            _roles[role].members[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n        }\n    }\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/structs/EnumerableSetUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n */\nlibrary EnumerableSetUpgradeable {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n\n        // Position of the value in the `values` array, plus 1 because index 0\n        // means a value is not in the set.\n        mapping (bytes32 => uint256) _indexes;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We read and store the value's index to prevent multiple reads from the same storage slot\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) { // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            // When the value to delete is the last one, the swap operation is unnecessary. However, since this occurs\n            // so rarely, we still do the swap anyway to avoid the gas cost of adding an 'if' statement.\n\n            bytes32 lastvalue = set._values[lastIndex];\n\n            // Move the last value to the index where the value to delete is\n            set._values[toDeleteIndex] = lastvalue;\n            // Update the index for the moved value\n            set._indexes[lastvalue] = valueIndex; // Replace lastvalue's index to valueIndex\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the index for the deleted slot\n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n   /**\n    * @dev Returns the value stored at position `index` in the set. O(1).\n    *\n    * Note that there are no guarantees on the ordering of values inside the\n    * array, and it may change when more values are added or removed.\n    *\n    * Requirements:\n    *\n    * - `index` must be strictly less than {length}.\n    */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        require(set._values.length > index, \"EnumerableSet: index out of bounds\");\n        return set._values[index];\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n   /**\n    * @dev Returns the value stored at position `index` in the set. O(1).\n    *\n    * Note that there are no guarantees on the ordering of values inside the\n    * array, and it may change when more values are added or removed.\n    *\n    * Requirements:\n    *\n    * - `index` must be strictly less than {length}.\n    */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n   /**\n    * @dev Returns the value stored at position `index` in the set. O(1).\n    *\n    * Note that there are no guarantees on the ordering of values inside the\n    * array, and it may change when more values are added or removed.\n    *\n    * Requirements:\n    *\n    * - `index` must be strictly less than {length}.\n    */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n   /**\n    * @dev Returns the value stored at position `index` in the set. O(1).\n    *\n    * Note that there are no guarantees on the ordering of values inside the\n    * array, and it may change when more values are added or removed.\n    *\n    * Requirements:\n    *\n    * - `index` must be strictly less than {length}.\n    */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/StringsUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev String operations.\n */\nlibrary StringsUpgradeable {\n    bytes16 private constant alphabet = \"0123456789abcdef\";\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI's implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0x00\";\n        }\n        uint256 temp = value;\n        uint256 length = 0;\n        while (temp != 0) {\n            length++;\n            temp >>= 8;\n        }\n        return toHexString(value, length);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = alphabet[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/introspection/ERC165Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165Upgradeable.sol\";\nimport \"../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165Upgradeable is Initializable, IERC165Upgradeable {\n    function __ERC165_init() internal initializer {\n        __ERC165_init_unchained();\n    }\n\n    function __ERC165_init_unchained() internal initializer {\n    }\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165Upgradeable).interfaceId;\n    }\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/introspection/IERC165Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165Upgradeable {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "contracts/interfaces/IOracle.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.0;\n\ninterface IOracle {\n  event PriceUpdated(address asset, uint256 newPrice);\n\n  function getPriceInUSD() external returns (uint256);\n\n  function viewPriceInUSD() external view returns (uint256);\n}\n"
    },
    "contracts/oracle/PriceOracleAggregator.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.0;\n\n// Interfaces\nimport {IERC20} from '../external/interfaces/IERC20.sol';\nimport {IPriceOracleAggregator} from '../interfaces/IPriceOracleAggregator.sol';\nimport {IOracle} from '../interfaces/IOracle.sol';\n\n// Contracts\nimport {Ownable} from '@openzeppelin/contracts/access/Ownable.sol';\n\ncontract PriceOracleAggregator is IPriceOracleAggregator, Ownable {\n    /// @notice token to the oracle address\n    mapping(address => IOracle) public assetToOracle;\n\n    /// @notice adds oracle for an asset e.g. ETH\n    /// @param _asset the oracle for the asset\n    /// @param _oracle the oracle address\n    function updateOracleForAsset(address _asset, IOracle _oracle)\n        external\n        override\n        onlyOwner\n    {\n        require(\n            address(_oracle) != address(0),\n            'PriceOracleAggregator: Oracle address cannot be zero address'\n        );\n        assetToOracle[_asset] = _oracle;\n        emit UpdateOracle(_asset, _oracle);\n    }\n\n    /// @notice returns price of token in USD in 1e8 decimals\n    /// @param _token token to fetch price\n    function getPriceInUSD(address _token) external override returns (uint256) {\n        require(\n            address(assetToOracle[_token]) != address(0),\n            'PriceOracleAggregator: Oracle address cannot be zero address'\n        );\n\n        uint256 price = assetToOracle[_token].getPriceInUSD();\n\n        require(price > 0, 'PriceOracleAggregator: Price cannot be 0');\n\n        return price;\n    }\n\n    /// @notice returns price of token in USD\n    /// @param _token view price of token\n    function viewPriceInUSD(address _token)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        require(\n            address(assetToOracle[_token]) != address(0),\n            'PriceOracleAggregator: Oracle address cannot be zero address'\n        );\n        return assetToOracle[_token].viewPriceInUSD();\n    }\n}\n"
    },
    "contracts/test/staking-rewards/StakingRewardsFactory.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.0;\n\n// Libraries\nimport {SafeMath} from '@openzeppelin/contracts/utils/math/SafeMath.sol';\nimport {SafeERC20} from '@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol';\n\n// Interfaces\nimport {IERC20} from'@openzeppelin/contracts/token/ERC20/IERC20.sol';\n\n// Contracts\nimport {Ownable} from '@openzeppelin/contracts/access/Ownable.sol';\nimport {ReentrancyGuard} from '@openzeppelin/contracts/security/ReentrancyGuard.sol';\nimport {StakingRewards} from './StakingRewards.sol';\n\ncontract StakingRewardsFactory is Ownable, ReentrancyGuard {\n  using SafeMath for uint256;\n  using SafeERC20 for IERC20;\n\n  // immutables\n  address public immutable rewardsTokenDPX;\n  address public immutable rewardsTokenRDPX;\n  uint256 public immutable stakingRewardsGenesis;\n\n  // the staking tokens for which the rewards contract has been deployed\n  uint256[] public stakingID;\n\n  // info about rewards for a particular staking token\n  struct StakingRewardsInfo {\n    address stakingRewards;\n    uint256 rewardAmountDPX;\n    uint256 rewardAmountRDPX;\n    uint256 id;\n  }\n\n  // rewards info by staking token\n  mapping(uint256 => StakingRewardsInfo) public stakingRewardsInfoByStakingToken;\n\n  constructor(\n    address _rewardsTokenDPX,\n    address _rewardsTokenRDPX,\n    uint256 _stakingRewardsGenesis\n  ) Ownable() {\n    require(\n      _stakingRewardsGenesis >= block.timestamp,\n      'StakingRewardsFactory::constructor: genesis too soon'\n    );\n    rewardsTokenDPX = _rewardsTokenDPX;\n    rewardsTokenRDPX = _rewardsTokenRDPX;\n    stakingRewardsGenesis = _stakingRewardsGenesis;\n  }\n\n  // deploy a staking reward contract for the staking token, and store the reward amount\n  // the reward will be distributed to the staking reward contract no sooner than the genesis\n  function deploy(\n    address stakingToken,\n    uint256 rewardAmountDPX,\n    uint256 rewardAmountRDPX,\n    uint256 rewardsDuration,\n    uint256 boostedTimePeriod,\n    uint256 boost,\n    uint256 id\n  ) public onlyOwner {\n    StakingRewardsInfo storage info = stakingRewardsInfoByStakingToken[id];\n    require(info.id != id, 'StakingID already taken');\n    require(rewardAmountDPX > 0, 'Invalid DPX reward amount');\n    require(rewardAmountRDPX > 0, 'Invalid rDPX reward amount');\n    info.stakingRewards = address(\n      new StakingRewards(\n        address(this),\n        rewardsTokenDPX,\n        rewardsTokenRDPX,\n        stakingToken,\n        rewardsDuration,\n        boostedTimePeriod,\n        boost,\n        id\n      )\n    );\n    info.rewardAmountDPX = rewardAmountDPX;\n    info.rewardAmountRDPX = rewardAmountRDPX;\n    info.id = id;\n    stakingID.push(id);\n  }\n\n  // Withdraw tokens in case functions exceed gas cost\n  function withdrawRewardToken(uint256 amountDPX, uint256 amountRDPX)\n    public\n    onlyOwner\n    returns (uint256, uint256)\n  {\n    address OwnerAddress = owner();\n    if (OwnerAddress == msg.sender) {\n      IERC20(rewardsTokenDPX).transfer(OwnerAddress, amountDPX);\n      IERC20(rewardsTokenRDPX).transfer(OwnerAddress, amountRDPX);\n    }\n    return (amountDPX, amountRDPX);\n  }\n\n  function withdrawRewardTokensFromContract(\n    uint256 amountDPX,\n    uint256 amountRDPX,\n    uint256 id\n  ) public onlyOwner {\n    address OwnerAddress = owner();\n    if (OwnerAddress == msg.sender) {\n      StakingRewardsInfo storage info = stakingRewardsInfoByStakingToken[id];\n      require(\n        info.stakingRewards != address(0),\n        'StakingRewardsFactory::notifyRewardAmount: not deployed'\n      );\n      StakingRewards(info.stakingRewards).withdrawRewardTokens(amountDPX, amountRDPX);\n    }\n  }\n\n  // notify reward amount for an individual staking token.\n  // this is a fallback in case the notifyRewardAmounts costs too much gas to call for all contracts\n  function notifyRewardAmount(uint256 id) public onlyOwner {\n    require(\n      block.timestamp >= stakingRewardsGenesis,\n      'StakingRewardsFactory::notifyRewardAmount: not ready'\n    );\n    StakingRewardsInfo storage info = stakingRewardsInfoByStakingToken[id];\n    require(\n      info.stakingRewards != address(0),\n      'StakingRewardsFactory::notifyRewardAmount: not deployed'\n    );\n    require(info.rewardAmountDPX > 0, 'Reward amount must be greater than 0');\n    uint256 rewardAmountDPX = 0;\n    uint256 rewardAmountRDPX = 0;\n    if (info.rewardAmountDPX > 0) {\n      rewardAmountDPX = info.rewardAmountDPX;\n      info.rewardAmountDPX = 0;\n      require(\n        IERC20(rewardsTokenDPX).transfer(info.stakingRewards, rewardAmountDPX),\n        'StakingRewardsFactory::notifyRewardAmount: transfer failed'\n      );\n    }\n    if (info.rewardAmountRDPX > 0) {\n      rewardAmountRDPX = info.rewardAmountRDPX;\n      info.rewardAmountRDPX = 0;\n      require(\n        IERC20(rewardsTokenRDPX).transfer(info.stakingRewards, rewardAmountRDPX),\n        'StakingRewardsFactory::notifyRewardAmount: transfer failed'\n      );\n    }\n    StakingRewards(info.stakingRewards).notifyRewardAmount(rewardAmountDPX, rewardAmountRDPX);\n  }\n\n  // call notifyRewardAmount for all staking tokens.\n  function notifyRewardAmounts() public onlyOwner {\n    require(\n      stakingID.length > 0,\n      'StakingRewardsFactory::notifyRewardAmounts: called before any deploys'\n    );\n    for (uint256 i = 0; i < stakingID.length; i++) {\n      notifyRewardAmount(stakingID[i]);\n    }\n  }\n\n  function addToContractWhitelist(address _contract, uint256 id) external onlyOwner {\n    StakingRewardsInfo storage info = stakingRewardsInfoByStakingToken[id];\n    require(\n      info.stakingRewards != address(0),\n      'StakingRewardsFactory: StakingRewards not deployed'\n    );\n    StakingRewards(info.stakingRewards).addToContractWhitelist(_contract);\n  }\n\n  function removeFromContractWhitelist(address _contract, uint256 id) external onlyOwner {\n    StakingRewardsInfo storage info = stakingRewardsInfoByStakingToken[id];\n    require(\n      info.stakingRewards != address(0),\n      'StakingRewardsFactory: StakingRewards not deployed'\n    );\n    StakingRewards(info.stakingRewards).removeFromContractWhitelist(_contract);\n  }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\nimport \"../../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        // solhint-disable-next-line max-line-length\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) { // Return data is optional\n            // solhint-disable-next-line max-line-length\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "@openzeppelin/contracts/security/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor () {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and make it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}\n"
    },
    "contracts/test/staking-rewards/StakingRewards.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.0;\n\n// Libraries\nimport {Math} from '@openzeppelin/contracts/utils/math/Math.sol';\nimport {SafeMath} from '@openzeppelin/contracts/utils/math/SafeMath.sol';\nimport {SafeERC20} from '@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol';\n\n// Interfaces\nimport {IERC20} from'@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport {IStakingRewards} from '../../interfaces/IStakingRewards.sol';\n\n// Contracts\nimport {ReentrancyGuard} from '@openzeppelin/contracts/security/ReentrancyGuard.sol';\nimport {Ownable} from '@openzeppelin/contracts/access/Ownable.sol';\nimport {RewardsDistributionRecipient} from './RewardsDistributionRecipient.sol';\n\ncontract StakingRewards is RewardsDistributionRecipient, ReentrancyGuard, Ownable {\n  using SafeMath for uint256;\n  using SafeERC20 for IERC20;\n\n  /* ========== STATE VARIABLES ========== */\n\n  IERC20 public rewardsTokenDPX;\n  IERC20 public rewardsTokenRDPX;\n  IERC20 public stakingToken;\n  uint256 public boost = 0;\n  uint256 public periodFinish = 0;\n  uint256 public boostedFinish = 0;\n  uint256 public rewardRateDPX = 0;\n  uint256 public rewardRateRDPX = 0;\n  uint256 public rewardsDuration;\n  uint256 public lastUpdateTime;\n  uint256 public rewardPerTokenStoredDPX;\n  uint256 public rewardPerTokenStoredRDPX;\n  uint256 public boostedTimePeriod;\n  uint256 public id;\n\n  mapping(address => bool) public whitelistedContracts;\n  mapping(address => uint256) public userDPXRewardPerTokenPaid;\n  mapping(address => uint256) public userRDPXRewardPerTokenPaid;\n  mapping(address => uint256) public rewardsDPX;\n  mapping(address => uint256) public rewardsRDPX;\n  mapping(address => uint256) private _balances;\n\n  uint256 private _totalSupply;\n\n  /* ========== CONSTRUCTOR ========== */\n\n  constructor(\n    address _rewardsDistribution,\n    address _rewardsTokenDPX,\n    address _rewardsTokenRDPX,\n    address _stakingToken,\n    uint256 _rewardsDuration,\n    uint256 _boostedTimePeriod,\n    uint256 _boost,\n    uint256 _id\n  ) Ownable() {\n    rewardsTokenDPX = IERC20(_rewardsTokenDPX);\n    rewardsTokenRDPX = IERC20(_rewardsTokenRDPX);\n    stakingToken = IERC20(_stakingToken);\n    rewardsDistribution = _rewardsDistribution;\n    rewardsDuration = _rewardsDuration;\n    boostedTimePeriod = _boostedTimePeriod;\n    boost = _boost;\n    id = _id;\n  }\n\n  /* ========== VIEWS ========== */\n\n  function isContract(address addr) public view returns (bool) {\n    uint256 size;\n    assembly {\n      size := extcodesize(addr)\n    }\n    return size > 0;\n  }\n\n  function totalSupply() external view returns (uint256) {\n    return _totalSupply;\n  }\n\n  function balanceOf(address account) external view returns (uint256) {\n    return _balances[account];\n  }\n\n  function lastTimeRewardApplicable() public view returns (uint256) {\n    uint256 timeApp = Math.min(block.timestamp, periodFinish);\n    return timeApp;\n  }\n\n  function rewardPerToken() public view returns (uint256, uint256) {\n    if (_totalSupply == 0) {\n      uint256 perTokenRateDPX = rewardPerTokenStoredDPX;\n      uint256 perTokenRateRDPX = rewardPerTokenStoredRDPX;\n      return (perTokenRateDPX, perTokenRateRDPX);\n    }\n    if (block.timestamp < boostedFinish) {\n      uint256 perTokenRateDPX = rewardPerTokenStoredDPX.add(\n        lastTimeRewardApplicable().sub(lastUpdateTime).mul(rewardRateDPX.mul(boost)).mul(1e18).div(\n          _totalSupply\n        )\n      );\n      uint256 perTokenRateRDPX = rewardPerTokenStoredRDPX.add(\n        lastTimeRewardApplicable().sub(lastUpdateTime).mul(rewardRateRDPX.mul(boost)).mul(1e18).div(\n          _totalSupply\n        )\n      );\n      return (perTokenRateDPX, perTokenRateRDPX);\n    } else {\n      if (lastUpdateTime < boostedFinish) {\n        uint256 perTokenRateDPX = rewardPerTokenStoredDPX\n          .add(\n            boostedFinish.sub(lastUpdateTime).mul(rewardRateDPX.mul(boost)).mul(1e18).div(\n              _totalSupply\n            )\n          )\n          .add(\n            lastTimeRewardApplicable().sub(boostedFinish).mul(rewardRateDPX).mul(1e18).div(\n              _totalSupply\n            )\n          );\n        uint256 perTokenRateRDPX = rewardPerTokenStoredRDPX\n          .add(\n            boostedFinish.sub(lastUpdateTime).mul(rewardRateRDPX.mul(boost)).mul(1e18).div(\n              _totalSupply\n            )\n          )\n          .add(\n            lastTimeRewardApplicable().sub(boostedFinish).mul(rewardRateRDPX).mul(1e18).div(\n              _totalSupply\n            )\n          );\n        return (perTokenRateDPX, perTokenRateRDPX);\n      } else {\n        uint256 perTokenRateDPX = rewardPerTokenStoredDPX.add(\n          lastTimeRewardApplicable().sub(lastUpdateTime).mul(rewardRateDPX).mul(1e18).div(\n            _totalSupply\n          )\n        );\n        uint256 perTokenRateRDPX = rewardPerTokenStoredRDPX.add(\n          lastTimeRewardApplicable().sub(lastUpdateTime).mul(rewardRateRDPX).mul(1e18).div(\n            _totalSupply\n          )\n        );\n        return (perTokenRateDPX, perTokenRateRDPX);\n      }\n    }\n  }\n\n  function earned(address account)\n    public\n    view\n    returns (uint256 DPXtokensEarned, uint256 RDPXtokensEarned)\n  {\n    uint256 perTokenRateDPX;\n    uint256 perTokenRateRDPX;\n    (perTokenRateDPX, perTokenRateRDPX) = rewardPerToken();\n    DPXtokensEarned = _balances[account]\n      .mul(perTokenRateDPX.sub(userDPXRewardPerTokenPaid[account]))\n      .div(1e18)\n      .add(rewardsDPX[account]);\n    RDPXtokensEarned = _balances[account]\n      .mul(perTokenRateRDPX.sub(userRDPXRewardPerTokenPaid[account]))\n      .div(1e18)\n      .add(rewardsRDPX[account]);\n  }\n\n  /* ========== MUTATIVE FUNCTIONS ========== */\n\n  function stake(uint256 amount)\n    external\n    payable\n    isEligibleSender\n    nonReentrant\n    updateReward(msg.sender)\n  {\n    require(amount > 0, 'Cannot stake 0');\n    _totalSupply = _totalSupply.add(amount);\n    _balances[msg.sender] = _balances[msg.sender].add(amount);\n    stakingToken.safeTransferFrom(msg.sender, address(this), amount);\n    emit Staked(msg.sender, amount);\n  }\n\n  function withdraw(uint256 amount) public nonReentrant updateReward(msg.sender) {\n    require(amount > 0, 'Cannot withdraw 0');\n    require(amount <= _balances[msg.sender], 'Insufficent balance');\n    _totalSupply = _totalSupply.sub(amount);\n    _balances[msg.sender] = _balances[msg.sender].sub(amount);\n    stakingToken.safeTransfer(msg.sender, amount);\n    emit Withdrawn(msg.sender, amount);\n  }\n\n  function withdrawRewardTokens(uint256 amountDPX, uint256 amountRDPX)\n    public\n    onlyOwner\n    returns (uint256, uint256)\n  {\n    address OwnerAddress = owner();\n    if (OwnerAddress == msg.sender) {\n      IERC20(rewardsTokenDPX).safeTransfer(OwnerAddress, amountDPX);\n      IERC20(rewardsTokenRDPX).safeTransfer(OwnerAddress, amountRDPX);\n    }\n    return (amountDPX, amountRDPX);\n  }\n\n  function compound() public nonReentrant updateReward(msg.sender) {\n    uint256 rewardDPX = rewardsDPX[msg.sender];\n    require(rewardDPX > 0, 'stake address not found');\n    require(rewardsTokenDPX == stakingToken, \"Can't stake the reward token.\");\n    rewardsDPX[msg.sender] = 0;\n    _totalSupply = _totalSupply.add(rewardDPX);\n    _balances[msg.sender] = _balances[msg.sender].add(rewardDPX);\n    emit RewardCompounded(msg.sender, rewardDPX);\n  }\n\n  function getReward(uint256 rewardsTokenID) public nonReentrant updateReward(msg.sender) {\n    if (rewardsTokenID == 0) {\n      uint256 rewardDPX = rewardsDPX[msg.sender];\n      require(rewardDPX > 0, 'can not withdraw 0 DPX reward');\n      rewardsDPX[msg.sender] = 0;\n      rewardsTokenDPX.safeTransfer(msg.sender, rewardDPX);\n      emit RewardPaid(msg.sender, rewardDPX);\n    } else if (rewardsTokenID == 1) {\n      uint256 rewardRDPX = rewardsRDPX[msg.sender];\n      require(rewardRDPX > 0, 'can not withdraw 0 RDPX reward');\n      rewardsRDPX[msg.sender] = 0;\n      rewardsTokenRDPX.safeTransfer(msg.sender, rewardRDPX);\n      emit RewardPaid(msg.sender, rewardRDPX);\n    } else {\n      uint256 rewardDPX = rewardsDPX[msg.sender];\n      uint256 rewardRDPX = rewardsRDPX[msg.sender];\n      if (rewardDPX > 0) {\n        rewardsDPX[msg.sender] = 0;\n        rewardsTokenDPX.safeTransfer(msg.sender, rewardDPX);\n      }\n      if (rewardRDPX > 0) {\n        rewardsRDPX[msg.sender] = 0;\n        rewardsTokenRDPX.safeTransfer(msg.sender, rewardRDPX);\n      }\n      emit RewardPaid(msg.sender, rewardDPX);\n      emit RewardPaid(msg.sender, rewardRDPX);\n    }\n  }\n\n  function exit() external {\n    getReward(2);\n    withdraw(_balances[msg.sender]);\n  }\n\n  /* ========== RESTRICTED FUNCTIONS ========== */\n\n  function notifyRewardAmount(uint256 rewardDPX, uint256 rewardRDPX)\n    external\n    override\n    onlyRewardsDistribution\n    setReward(address(0))\n  {\n    if (periodFinish == 0) {\n      rewardRateDPX = rewardDPX.div(rewardsDuration.add(boostedTimePeriod));\n      rewardRateRDPX = rewardRDPX.div(rewardsDuration.add(boostedTimePeriod));\n      lastUpdateTime = block.timestamp;\n      periodFinish = block.timestamp.add(rewardsDuration);\n      boostedFinish = block.timestamp.add(boostedTimePeriod);\n    } else {\n      uint256 remaining = periodFinish.sub(block.timestamp);\n      uint256 leftoverDPX = remaining.mul(rewardRateDPX);\n      uint256 leftoverRDPX = remaining.mul(rewardRateRDPX);\n      rewardRateDPX = rewardDPX.add(leftoverDPX).div(rewardsDuration);\n      rewardRateRDPX = rewardRDPX.add(leftoverRDPX).div(rewardsDuration);\n      lastUpdateTime = block.timestamp;\n      periodFinish = block.timestamp.add(rewardsDuration);\n    }\n    emit RewardAdded(rewardDPX, rewardRDPX);\n  }\n\n  function addToContractWhitelist(address _contract) external onlyOwner returns (bool) {\n    require(isContract(_contract), 'StakingRewards: Address must be a contract address');\n    require(!whitelistedContracts[_contract], 'StakingRewards: Contract already whitelisted');\n\n    whitelistedContracts[_contract] = true;\n\n    emit AddToContractWhitelist(_contract);\n\n    return true;\n  }\n\n  function removeFromContractWhitelist(address _contract) external onlyOwner returns (bool) {\n    require(whitelistedContracts[_contract], 'StakingRewards: Contract not whitelisted');\n\n    whitelistedContracts[_contract] = false;\n\n    emit RemoveFromContractWhitelist(_contract);\n\n    return true;\n  }\n\n  /* ========== MODIFIERS ========== */\n\n  // Modifier is eligible sender modifier\n  modifier isEligibleSender() {\n    if (isContract(msg.sender))\n      require(whitelistedContracts[msg.sender], 'StakingRewards: Contract must be whitelisted');\n    _;\n  }\n\n  // Modifier Set Reward modifier\n  modifier setReward(address account) {\n    (rewardPerTokenStoredDPX, rewardPerTokenStoredRDPX) = rewardPerToken();\n    lastUpdateTime = lastTimeRewardApplicable();\n    if (account != address(0)) {\n      (rewardsDPX[account], rewardsRDPX[account]) = earned(account);\n      userDPXRewardPerTokenPaid[account] = rewardPerTokenStoredDPX;\n      userRDPXRewardPerTokenPaid[account] = rewardPerTokenStoredRDPX;\n    }\n    _;\n  }\n\n  // Modifier *Update Reward modifier*\n  modifier updateReward(address account) {\n    (rewardPerTokenStoredDPX, rewardPerTokenStoredRDPX) = rewardPerToken();\n    lastUpdateTime = lastTimeRewardApplicable();\n    if (account != address(0)) {\n      (rewardsDPX[account], rewardsRDPX[account]) = earned(account);\n      userDPXRewardPerTokenPaid[account] = rewardPerTokenStoredDPX;\n      userRDPXRewardPerTokenPaid[account] = rewardPerTokenStoredRDPX;\n    }\n    _;\n  }\n\n  /* ========== EVENTS ========== */\n\n  event RewardUpdated(uint256 rewardDPX, uint256 rewardRDPX);\n  event RewardAdded(uint256 rewardDPX, uint256 rewardRDPX);\n  event Staked(address indexed user, uint256 amount);\n  event Withdrawn(address indexed user, uint256 amount);\n  event RewardPaid(address indexed user, uint256 reward);\n  event RewardCompounded(address indexed user, uint256 rewardDPX);\n  event AddToContractWhitelist(address indexed _contract);\n  event RemoveFromContractWhitelist(address indexed _contract);\n}\n\ninterface IUniswapV2ERC20 {\n  function permit(\n    address owner,\n    address spender,\n    uint256 value,\n    uint256 deadline,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) external;\n}\n\n"
    },
    "@openzeppelin/contracts/utils/math/Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a >= b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow, so we distribute\n        return (a / 2) + (b / 2) + ((a % 2 + b % 2) / 2);\n    }\n}\n"
    },
    "contracts/test/staking-rewards/RewardsDistributionRecipient.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.0;\n\nabstract contract RewardsDistributionRecipient {\n  address public rewardsDistribution;\n\n  function notifyRewardAmount(uint256 rewardDPX, uint256 rewardRDPX) external virtual;\n\n  modifier onlyRewardsDistribution() {\n    require(msg.sender == rewardsDistribution, 'Caller is not RewardsDistribution contract');\n    _;\n  }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"./extensions/IERC20Metadata.sol\";\nimport \"../../utils/Context.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin guidelines: functions revert instead\n * of returning `false` on failure. This behavior is nonetheless conventional\n * and does not conflict with the expectations of ERC20 applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20, IERC20Metadata {\n    mapping (address => uint256) private _balances;\n\n    mapping (address => mapping (address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * The defaut value of {decimals} is 18. To select a different value for\n     * {decimals} you should overload it.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor (string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\n     * overridden;\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * Requirements:\n     *\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``sender``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(sender, recipient, amount);\n\n        uint256 currentAllowance = _allowances[sender][_msgSender()];\n        require(currentAllowance >= amount, \"ERC20: transfer amount exceeds allowance\");\n        _approve(sender, _msgSender(), currentAllowance - amount);\n\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender] + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        uint256 currentAllowance = _allowances[_msgSender()][spender];\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        _approve(_msgSender(), spender, currentAllowance - subtractedValue);\n\n        return true;\n    }\n\n    /**\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\n     *\n     * This is internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(sender, recipient, amount);\n\n        uint256 senderBalance = _balances[sender];\n        require(senderBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        _balances[sender] = senderBalance - amount;\n        _balances[recipient] += amount;\n\n        emit Transfer(sender, recipient, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        _balances[account] += amount;\n        emit Transfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        _balances[account] = accountBalance - amount;\n        _totalSupply -= amount;\n\n        emit Transfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be to transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/ERC20Pausable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../ERC20.sol\";\nimport \"../../../security/Pausable.sol\";\n\n/**\n * @dev ERC20 token with pausable token transfers, minting and burning.\n *\n * Useful for scenarios such as preventing trades until the end of an evaluation\n * period, or having an emergency switch for freezing all token transfers in the\n * event of a large bug.\n */\nabstract contract ERC20Pausable is ERC20, Pausable {\n    /**\n     * @dev See {ERC20-_beforeTokenTransfer}.\n     *\n     * Requirements:\n     *\n     * - the contract must not be paused.\n     */\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual override {\n        super._beforeTokenTransfer(from, to, amount);\n\n        require(!paused(), \"ERC20Pausable: token transfer while paused\");\n    }\n}\n"
    },
    "@openzeppelin/contracts/security/Pausable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which allows children to implement an emergency stop\n * mechanism that can be triggered by an authorized account.\n *\n * This module is used through inheritance. It will make available the\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n * the functions of your contract. Note that they will not be pausable by\n * simply including this module, only once the modifiers are put in place.\n */\nabstract contract Pausable is Context {\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    bool private _paused;\n\n    /**\n     * @dev Initializes the contract in unpaused state.\n     */\n    constructor () {\n        _paused = false;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view virtual returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        require(!paused(), \"Pausable: paused\");\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        require(paused(), \"Pausable: not paused\");\n        _;\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/AccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\nimport \"../utils/Strings.sol\";\nimport \"../utils/introspection/ERC165.sol\";\n\n/**\n * @dev External interface of AccessControl declared to support ERC165 detection.\n */\ninterface IAccessControl {\n    function hasRole(bytes32 role, address account) external view returns (bool);\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n    function grantRole(bytes32 role, address account) external;\n    function revokeRole(bytes32 role, address account) external;\n    function renounceRole(bytes32 role, address account) external;\n}\n\n/**\n * @dev Contract module that allows children to implement role-based access\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\n * members except through off-chain means by accessing the contract event logs. Some\n * applications may benefit from on-chain enumerability, for those cases see\n * {AccessControlEnumerable}.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```\n * function foo() public {\n *     require(hasRole(MY_ROLE, msg.sender));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n *\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it.\n */\nabstract contract AccessControl is Context, IAccessControl, ERC165 {\n    struct RoleData {\n        mapping (address => bool) members;\n        bytes32 adminRole;\n    }\n\n    mapping (bytes32 => RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     *\n     * _Available since v3.1._\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {_setupRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with a standardized message including the required role.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{20}) is missing role (0x[0-9a-f]{32})$/\n     *\n     * _Available since v4.1._\n     */\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role, _msgSender());\n        _;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControl).interfaceId\n            || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view override returns (bool) {\n        return _roles[role].members[account];\n    }\n\n    /**\n     * @dev Revert with a standard message if `account` is missing `role`.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{20}) is missing role (0x[0-9a-f]{32})$/\n     */\n    function _checkRole(bytes32 role, address account) internal view {\n        if(!hasRole(role, account)) {\n            revert(string(abi.encodePacked(\n                \"AccessControl: account \",\n                Strings.toHexString(uint160(account), 20),\n                \" is missing role \",\n                Strings.toHexString(uint256(role), 32)\n            )));\n        }\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view override returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     */\n    function renounceRole(bytes32 role, address account) public virtual override {\n        require(account == _msgSender(), \"AccessControl: can only renounce roles for self\");\n\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event. Note that unlike {grantRole}, this function doesn't perform any\n     * checks on the calling account.\n     *\n     * [WARNING]\n     * ====\n     * This function should only be called from the constructor when setting\n     * up the initial roles for the system.\n     *\n     * Using this function in any other way is effectively circumventing the admin\n     * system imposed by {AccessControl}.\n     * ====\n     */\n    function _setupRole(bytes32 role, address account) internal virtual {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        emit RoleAdminChanged(role, getRoleAdmin(role), adminRole);\n        _roles[role].adminRole = adminRole;\n    }\n\n    function _grantRole(bytes32 role, address account) private {\n        if (!hasRole(role, account)) {\n            _roles[role].members[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n        }\n    }\n\n    function _revokeRole(bytes32 role, address account) private {\n        if (hasRole(role, account)) {\n            _roles[role].members[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/ERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/access/AccessControlEnumerable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./AccessControl.sol\";\nimport \"../utils/structs/EnumerableSet.sol\";\n\n/**\n * @dev External interface of AccessControlEnumerable declared to support ERC165 detection.\n */\ninterface IAccessControlEnumerable {\n    function getRoleMember(bytes32 role, uint256 index) external view returns (address);\n    function getRoleMemberCount(bytes32 role) external view returns (uint256);\n}\n\n/**\n * @dev Extension of {AccessControl} that allows enumerating the members of each role.\n */\nabstract contract AccessControlEnumerable is IAccessControlEnumerable, AccessControl {\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    mapping (bytes32 => EnumerableSet.AddressSet) private _roleMembers;\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControlEnumerable).interfaceId\n            || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns one of the accounts that have `role`. `index` must be a\n     * value between 0 and {getRoleMemberCount}, non-inclusive.\n     *\n     * Role bearers are not sorted in any particular way, and their ordering may\n     * change at any point.\n     *\n     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\n     * you perform all queries on the same block. See the following\n     * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]\n     * for more information.\n     */\n    function getRoleMember(bytes32 role, uint256 index) public view override returns (address) {\n        return _roleMembers[role].at(index);\n    }\n\n    /**\n     * @dev Returns the number of accounts that have `role`. Can be used\n     * together with {getRoleMember} to enumerate all bearers of a role.\n     */\n    function getRoleMemberCount(bytes32 role) public view override returns (uint256) {\n        return _roleMembers[role].length();\n    }\n\n    /**\n     * @dev Overload {grantRole} to track enumerable memberships\n     */\n    function grantRole(bytes32 role, address account) public virtual override {\n        super.grantRole(role, account);\n        _roleMembers[role].add(account);\n    }\n\n    /**\n     * @dev Overload {revokeRole} to track enumerable memberships\n     */\n    function revokeRole(bytes32 role, address account) public virtual override {\n        super.revokeRole(role, account);\n        _roleMembers[role].remove(account);\n    }\n\n    /**\n     * @dev Overload {renounceRole} to track enumerable memberships\n     */\n    function renounceRole(bytes32 role, address account) public virtual override {\n        super.renounceRole(role, account);\n        _roleMembers[role].remove(account);\n    }\n\n    /**\n     * @dev Overload {_setupRole} to track enumerable memberships\n     */\n    function _setupRole(bytes32 role, address account) internal virtual override {\n        super._setupRole(role, account);\n        _roleMembers[role].add(account);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/structs/EnumerableSet.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n */\nlibrary EnumerableSet {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n\n        // Position of the value in the `values` array, plus 1 because index 0\n        // means a value is not in the set.\n        mapping (bytes32 => uint256) _indexes;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We read and store the value's index to prevent multiple reads from the same storage slot\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) { // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            // When the value to delete is the last one, the swap operation is unnecessary. However, since this occurs\n            // so rarely, we still do the swap anyway to avoid the gas cost of adding an 'if' statement.\n\n            bytes32 lastvalue = set._values[lastIndex];\n\n            // Move the last value to the index where the value to delete is\n            set._values[toDeleteIndex] = lastvalue;\n            // Update the index for the moved value\n            set._indexes[lastvalue] = valueIndex; // Replace lastvalue's index to valueIndex\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the index for the deleted slot\n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n   /**\n    * @dev Returns the value stored at position `index` in the set. O(1).\n    *\n    * Note that there are no guarantees on the ordering of values inside the\n    * array, and it may change when more values are added or removed.\n    *\n    * Requirements:\n    *\n    * - `index` must be strictly less than {length}.\n    */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        require(set._values.length > index, \"EnumerableSet: index out of bounds\");\n        return set._values[index];\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n   /**\n    * @dev Returns the value stored at position `index` in the set. O(1).\n    *\n    * Note that there are no guarantees on the ordering of values inside the\n    * array, and it may change when more values are added or removed.\n    *\n    * Requirements:\n    *\n    * - `index` must be strictly less than {length}.\n    */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n   /**\n    * @dev Returns the value stored at position `index` in the set. O(1).\n    *\n    * Note that there are no guarantees on the ordering of values inside the\n    * array, and it may change when more values are added or removed.\n    *\n    * Requirements:\n    *\n    * - `index` must be strictly less than {length}.\n    */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n   /**\n    * @dev Returns the value stored at position `index` in the set. O(1).\n    *\n    * Note that there are no guarantees on the ordering of values inside the\n    * array, and it may change when more values are added or removed.\n    *\n    * Requirements:\n    *\n    * - `index` must be strictly less than {length}.\n    */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/presets/ERC20PresetMinterPauser.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../ERC20.sol\";\nimport \"../extensions/ERC20Burnable.sol\";\nimport \"../extensions/ERC20Pausable.sol\";\nimport \"../../../access/AccessControlEnumerable.sol\";\nimport \"../../../utils/Context.sol\";\n\n/**\n * @dev {ERC20} token, including:\n *\n *  - ability for holders to burn (destroy) their tokens\n *  - a minter role that allows for token minting (creation)\n *  - a pauser role that allows to stop all token transfers\n *\n * This contract uses {AccessControl} to lock permissioned functions using the\n * different roles - head to its documentation for details.\n *\n * The account that deploys the contract will be granted the minter and pauser\n * roles, as well as the default admin role, which will let it grant both minter\n * and pauser roles to other accounts.\n */\ncontract ERC20PresetMinterPauser is Context, AccessControlEnumerable, ERC20Burnable, ERC20Pausable {\n    bytes32 public constant MINTER_ROLE = keccak256(\"MINTER_ROLE\");\n    bytes32 public constant PAUSER_ROLE = keccak256(\"PAUSER_ROLE\");\n\n    /**\n     * @dev Grants `DEFAULT_ADMIN_ROLE`, `MINTER_ROLE` and `PAUSER_ROLE` to the\n     * account that deploys the contract.\n     *\n     * See {ERC20-constructor}.\n     */\n    constructor(string memory name, string memory symbol) ERC20(name, symbol) {\n        _setupRole(DEFAULT_ADMIN_ROLE, _msgSender());\n\n        _setupRole(MINTER_ROLE, _msgSender());\n        _setupRole(PAUSER_ROLE, _msgSender());\n    }\n\n    /**\n     * @dev Creates `amount` new tokens for `to`.\n     *\n     * See {ERC20-_mint}.\n     *\n     * Requirements:\n     *\n     * - the caller must have the `MINTER_ROLE`.\n     */\n    function mint(address to, uint256 amount) public virtual {\n        require(hasRole(MINTER_ROLE, _msgSender()), \"ERC20PresetMinterPauser: must have minter role to mint\");\n        _mint(to, amount);\n    }\n\n    /**\n     * @dev Pauses all token transfers.\n     *\n     * See {ERC20Pausable} and {Pausable-_pause}.\n     *\n     * Requirements:\n     *\n     * - the caller must have the `PAUSER_ROLE`.\n     */\n    function pause() public virtual {\n        require(hasRole(PAUSER_ROLE, _msgSender()), \"ERC20PresetMinterPauser: must have pauser role to pause\");\n        _pause();\n    }\n\n    /**\n     * @dev Unpauses all token transfers.\n     *\n     * See {ERC20Pausable} and {Pausable-_unpause}.\n     *\n     * Requirements:\n     *\n     * - the caller must have the `PAUSER_ROLE`.\n     */\n    function unpause() public virtual {\n        require(hasRole(PAUSER_ROLE, _msgSender()), \"ERC20PresetMinterPauser: must have pauser role to unpause\");\n        _unpause();\n    }\n\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual override(ERC20, ERC20Pausable) {\n        super._beforeTokenTransfer(from, to, amount);\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/ERC20Burnable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../ERC20.sol\";\nimport \"../../../utils/Context.sol\";\n\n/**\n * @dev Extension of {ERC20} that allows token holders to destroy both their own\n * tokens and those that they have an allowance for, in a way that can be\n * recognized off-chain (via event analysis).\n */\nabstract contract ERC20Burnable is Context, ERC20 {\n    /**\n     * @dev Destroys `amount` tokens from the caller.\n     *\n     * See {ERC20-_burn}.\n     */\n    function burn(uint256 amount) public virtual {\n        _burn(_msgSender(), amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, deducting from the caller's\n     * allowance.\n     *\n     * See {ERC20-_burn} and {ERC20-allowance}.\n     *\n     * Requirements:\n     *\n     * - the caller must have allowance for ``accounts``'s tokens of at least\n     * `amount`.\n     */\n    function burnFrom(address account, uint256 amount) public virtual {\n        uint256 currentAllowance = allowance(account, _msgSender());\n        require(currentAllowance >= amount, \"ERC20: burn amount exceeds allowance\");\n        _approve(account, _msgSender(), currentAllowance - amount);\n        _burn(account, amount);\n    }\n}\n"
    },
    "contracts/test/staking-rewards/token/RdpxToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {ERC20PresetMinterPauser} from '@openzeppelin/contracts/token/ERC20/presets/ERC20PresetMinterPauser.sol';\n\ncontract RdpxToken is ERC20PresetMinterPauser('Rebate Dopex Token', 'rDPX') {\n  constructor() {\n    _mint(address(this), 2000000 ether);\n  }\n}\n"
    },
    "contracts/test/staking-rewards/token/DpxToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {ERC20PresetMinterPauser} from '@openzeppelin/contracts/token/ERC20/presets/ERC20PresetMinterPauser.sol';\n\ncontract DpxToken is ERC20PresetMinterPauser('Dopex.io Token', 'DPX') {\n  constructor() {\n    _mint(address(this), 500000 ether);\n  }\n}"
    },
    "contracts/pricing/OptionPricingSimple.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.0;\n\n// Libraries\nimport {SafeMath} from '@openzeppelin/contracts/utils/math/SafeMath.sol';\nimport {BlackScholes} from '../libraries/BlackScholes.sol';\nimport {ABDKMathQuad} from '../external/libraries/ABDKMathQuad.sol';\n\n// Contracts\nimport {Ownable} from '@openzeppelin/contracts/access/Ownable.sol';\n\n// Interfaces\nimport {IOptionPricing} from '../interfaces/IOptionPricing.sol';\n\ncontract OptionPricingSimple is Ownable, IOptionPricing {\n    using SafeMath for uint256;\n\n    // The max volatility possible\n    uint256 public volatilityCap;\n\n    // The % of the price of asset which is the minimum option price possible in 1e8 precision\n    uint256 public minOptionPricePercentage;\n\n    constructor(uint256 _volatilityCap, uint256 _minOptionPricePercentage) {\n        volatilityCap = _volatilityCap;\n        minOptionPricePercentage = _minOptionPricePercentage;\n    }\n\n    /*---- GOVERNANCE FUNCTIONS ----*/\n\n    /// @notice updates volatility cap for an option pool\n    /// @param _volatilityCap the new volatility cap\n    /// @return whether volatility cap was updated\n    function updateVolatilityCap(uint256 _volatilityCap)\n        external\n        onlyOwner\n        returns (bool)\n    {\n        volatilityCap = _volatilityCap;\n\n        return true;\n    }\n\n    /// @notice updates % of the price of asset which is the minimum option price possible\n    /// @param _minOptionPricePercentage the new %\n    /// @return whether % was updated\n    function updateMinOptionPricePercentage(uint256 _minOptionPricePercentage)\n        external\n        onlyOwner\n        returns (bool)\n    {\n        minOptionPricePercentage = _minOptionPricePercentage;\n\n        return true;\n    }\n\n    /*---- VIEWS ----*/\n\n    /**\n     * @notice computes the option price (with liquidity multiplier)\n     * @param isPut is put option\n     * @param expiry expiry timestamp\n     * @param strike strike price\n     * @param lastPrice current price\n     * @param volatility volatility\n     */\n    function getOptionPrice(\n        bool isPut,\n        uint256 expiry,\n        uint256 strike,\n        uint256 lastPrice,\n        uint256 volatility\n    ) external view override returns (uint256) {\n        uint256 timeToExpiry = expiry.sub(block.timestamp).div(864);\n\n        uint256 optionPrice = BlackScholes\n            .calculate(\n                isPut ? 1 : 0, // 0 - Put, 1 - Call\n                lastPrice,\n                strike,\n                timeToExpiry, // Number of days to expiry mul by 100\n                0,\n                volatility\n            )\n            .div(BlackScholes.DIVISOR);\n\n        uint256 minOptionPrice = lastPrice.mul(minOptionPricePercentage).div(\n            1e10\n        );\n\n        if (minOptionPrice > optionPrice) {\n            return minOptionPrice;\n        }\n\n        return optionPrice;\n    }\n}\n"
    },
    "contracts/libraries/BlackScholes.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.0;\n\n// Libraries\nimport {ABDKMathQuad} from '../external/libraries/ABDKMathQuad.sol';\n\n/// @title Black-Scholes option pricing formula and supporting statistical functions\n/// @author Dopex\n/// @notice This library implements the Black-Scholes model to price options.\n/// See - https://en.wikipedia.org/wiki/Black%E2%80%93Scholes_model\n/// @dev Implements the following implementation - https://cseweb.ucsd.edu/~goguen/courses/130/SayBlackScholes.html\n/// Uses the ABDKMathQuad(https://github.com/abdk-consulting/abdk-libraries-solidity/blob/master/ABDKMathQuad.md)\n/// library to make precise calculations. It uses a DIVISOR (1e16) for maintaining precision in constants.\nlibrary BlackScholes {\n    uint8 internal constant OPTION_TYPE_CALL = 0;\n    uint8 internal constant OPTION_TYPE_PUT = 1;\n\n    uint256 internal constant DIVISOR = 10**16;\n\n    /**\n     * @notice The function that uses the Black-Scholes equation to calculate the option price\n     * See http://en.wikipedia.org/wiki/Black%E2%80%93Scholes_model#Black-Scholes_formula\n     * NOTE: The different parts of the equation are broken down to separate functions as using\n     * ABDKMathQuad makes small equations verbose.\n     * @param optionType Type of option - 0 = call, 1 = put\n     * @param price Stock price\n     * @param strike Strike price\n     * @param timeToExpiry Time to expiry in days\n     * @param riskFreeRate Risk-free rate\n     * @param volatility Volatility on the asset\n     * @return Option price based on the Black-Scholes model\n     */\n    function calculate(\n        uint8 optionType,\n        uint256 price,\n        uint256 strike,\n        uint256 timeToExpiry,\n        uint256 riskFreeRate,\n        uint256 volatility\n    ) internal pure returns (uint256) {\n        bytes16 S = ABDKMathQuad.fromUInt(price);\n        bytes16 X = ABDKMathQuad.fromUInt(strike);\n        bytes16 T = ABDKMathQuad.div(\n            ABDKMathQuad.fromUInt(timeToExpiry),\n            ABDKMathQuad.fromUInt(36500) // 365 * 10 ^ DAYS_PRECISION\n        );\n        bytes16 r = ABDKMathQuad.div(\n            ABDKMathQuad.fromUInt(riskFreeRate),\n            ABDKMathQuad.fromUInt(10000)\n        );\n        bytes16 v = ABDKMathQuad.div(\n            ABDKMathQuad.fromUInt(volatility),\n            ABDKMathQuad.fromUInt(100)\n        );\n        bytes16 d1 = ABDKMathQuad.div(\n            ABDKMathQuad.add(\n                ABDKMathQuad.ln(ABDKMathQuad.div(S, X)),\n                ABDKMathQuad.mul(\n                    ABDKMathQuad.add(\n                        r,\n                        ABDKMathQuad.mul(\n                            v,\n                            ABDKMathQuad.div(v, ABDKMathQuad.fromUInt(2))\n                        )\n                    ),\n                    T\n                )\n            ),\n            ABDKMathQuad.mul(v, ABDKMathQuad.sqrt(T))\n        );\n        bytes16 d2 = ABDKMathQuad.sub(\n            d1,\n            ABDKMathQuad.mul(v, ABDKMathQuad.sqrt(T))\n        );\n        if (optionType == OPTION_TYPE_CALL) {\n            return\n                ABDKMathQuad.toUInt(\n                    ABDKMathQuad.mul(\n                        _calculateCallTimeDecay(S, d1, X, r, T, d2),\n                        ABDKMathQuad.fromUInt(DIVISOR)\n                    )\n                );\n        } else if (optionType == OPTION_TYPE_PUT) {\n            return\n                ABDKMathQuad.toUInt(\n                    ABDKMathQuad.mul(\n                        _calculatePutTimeDecay(X, r, T, d2, S, d1),\n                        ABDKMathQuad.fromUInt(DIVISOR)\n                    )\n                );\n        } else return 0;\n    }\n\n    /// @dev Function to caluclate the call time decay\n    /// From the implementation page(https://cseweb.ucsd.edu/~goguen/courses/130/SayBlackScholes.html); part of the equation\n    /// ( S * CND(d1)-X * Math.exp(-r * T) * CND(d2) );\n    function _calculateCallTimeDecay(\n        bytes16 S,\n        bytes16 d1,\n        bytes16 X,\n        bytes16 r,\n        bytes16 T,\n        bytes16 d2\n    ) internal pure returns (bytes16) {\n        return\n            ABDKMathQuad.sub(\n                ABDKMathQuad.mul(S, CND(d1)),\n                ABDKMathQuad.mul(\n                    ABDKMathQuad.mul(\n                        X,\n                        ABDKMathQuad.exp(\n                            ABDKMathQuad.mul(ABDKMathQuad.neg(r), T)\n                        )\n                    ),\n                    CND(d2)\n                )\n            );\n    }\n\n    /// @dev Function to caluclate the put time decay\n    /// From the implementation page(https://cseweb.ucsd.edu/~goguen/courses/130/SayBlackScholes.html); part of the equation -\n    /// ( X * Math.exp(-r * T) * CND(-d2) - S * CND(-d1) );\n    function _calculatePutTimeDecay(\n        bytes16 X,\n        bytes16 r,\n        bytes16 T,\n        bytes16 d2,\n        bytes16 S,\n        bytes16 d1\n    ) internal pure returns (bytes16) {\n        bytes16 price_part1 = ABDKMathQuad.mul(\n            ABDKMathQuad.mul(\n                X,\n                ABDKMathQuad.exp(ABDKMathQuad.mul(ABDKMathQuad.neg(r), T))\n            ),\n            CND(ABDKMathQuad.neg(d2))\n        );\n        bytes16 price_part2 = ABDKMathQuad.mul(S, CND(ABDKMathQuad.neg(d1)));\n        bytes16 price = ABDKMathQuad.sub(price_part1, price_part2);\n        return price;\n    }\n\n    /**\n     * @notice Normal cumulative distribution function.\n     * See http://en.wikipedia.org/wiki/Normal_distribution#Cumulative_distribution_function\n     * From the implementation page(https://cseweb.ucsd.edu/~goguen/courses/130/SayBlackScholes.html); part of the equation -\n     * \"k = 1 / (1 + .2316419 * x); return ( 1 - Math.exp(-x * x / 2)/ Math.sqrt(2*Math.PI) * k * (.31938153 + k * (-.356563782 + k * (1.781477937 + k * (-1.821255978 + k * 1.330274429)))) );\"\n     * NOTE: The different parts of the equation are broken down to separate functions as using\n     * ABDKMathQuad makes small equations verbose.\n     */\n    function CND(bytes16 x) internal pure returns (bytes16) {\n        if (ABDKMathQuad.toInt(x) < 0) {\n            return (\n                ABDKMathQuad.sub(\n                    ABDKMathQuad.fromUInt(1),\n                    CND(ABDKMathQuad.neg(x))\n                )\n            );\n        } else {\n            bytes16 k = ABDKMathQuad.div(\n                ABDKMathQuad.fromUInt(1),\n                ABDKMathQuad.add(\n                    ABDKMathQuad.fromUInt(1),\n                    ABDKMathQuad.mul(\n                        ABDKMathQuad.div(\n                            ABDKMathQuad.fromUInt(2316419000000000),\n                            ABDKMathQuad.fromUInt(DIVISOR)\n                        ),\n                        x\n                    )\n                )\n            );\n            bytes16 CND_part2 = _getCNDPart2(k, x);\n            return ABDKMathQuad.sub(ABDKMathQuad.fromUInt(1), CND_part2);\n        }\n    }\n\n    function _getCNDPart2(bytes16 k, bytes16 x)\n        internal\n        pure\n        returns (bytes16)\n    {\n        return ABDKMathQuad.mul(_getCNDPart2_1(x), _getCNDPart2_2(k));\n    }\n\n    function _getCNDPart2_1(bytes16 x) internal pure returns (bytes16) {\n        return\n            ABDKMathQuad.div(\n                ABDKMathQuad.exp(\n                    ABDKMathQuad.mul(\n                        ABDKMathQuad.neg(x),\n                        ABDKMathQuad.div(x, ABDKMathQuad.fromUInt(2))\n                    )\n                ),\n                ABDKMathQuad.sqrt(\n                    ABDKMathQuad.mul(\n                        ABDKMathQuad.fromUInt(2),\n                        ABDKMathQuad.div(\n                            ABDKMathQuad.fromUInt(31415926530000000),\n                            ABDKMathQuad.fromUInt(DIVISOR)\n                        )\n                    )\n                )\n            );\n    }\n\n    function _getCNDPart2_2(bytes16 k) internal pure returns (bytes16) {\n        return\n            ABDKMathQuad.mul(\n                ABDKMathQuad.add(\n                    ABDKMathQuad.div(\n                        ABDKMathQuad.fromUInt(3193815300000000),\n                        ABDKMathQuad.fromUInt(DIVISOR)\n                    ),\n                    ABDKMathQuad.mul(\n                        k,\n                        ABDKMathQuad.add(\n                            ABDKMathQuad.neg(\n                                ABDKMathQuad.div(\n                                    ABDKMathQuad.fromUInt(3565637820000000),\n                                    ABDKMathQuad.fromUInt(DIVISOR)\n                                )\n                            ),\n                            ABDKMathQuad.mul(\n                                k,\n                                ABDKMathQuad.add(\n                                    ABDKMathQuad.div(\n                                        ABDKMathQuad.fromUInt(\n                                            17814779370000000\n                                        ),\n                                        ABDKMathQuad.fromUInt(DIVISOR)\n                                    ),\n                                    _getCNDPart2_2_1(k)\n                                )\n                            )\n                        )\n                    )\n                ),\n                k\n            );\n    }\n\n    function _getCNDPart2_2_1(bytes16 k) internal pure returns (bytes16) {\n        return\n            ABDKMathQuad.mul(\n                k,\n                ABDKMathQuad.add(\n                    ABDKMathQuad.neg(\n                        ABDKMathQuad.div(\n                            ABDKMathQuad.fromUInt(18212559780000000),\n                            ABDKMathQuad.fromUInt(DIVISOR)\n                        )\n                    ),\n                    ABDKMathQuad.mul(\n                        k,\n                        ABDKMathQuad.div(\n                            ABDKMathQuad.fromUInt(13302744290000000),\n                            ABDKMathQuad.fromUInt(DIVISOR)\n                        )\n                    )\n                )\n            );\n    }\n}\n"
    },
    "contracts/external/libraries/ABDKMathQuad.sol": {
      "content": "// SPDX-License-Identifier: BSD-4-Clause\n/*\n * ABDK Math Quad Smart Contract Library.  Copyright  2019 by ABDK Consulting.\n * Author: Mikhail Vladimirov <mikhail.vladimirov@gmail.com>\n */\npragma solidity ^0.8.0;\n\n/**\n * Smart contract library of mathematical functions operating with IEEE 754\n * quadruple-precision binary floating-point numbers (quadruple precision\n * numbers).  As long as quadruple precision numbers are 16-bytes long, they are\n * represented by bytes16 type.\n */\nlibrary ABDKMathQuad {\n  /*\n   * 0.\n   */\n  bytes16 private constant POSITIVE_ZERO = 0x00000000000000000000000000000000;\n\n  /*\n   * -0.\n   */\n  bytes16 private constant NEGATIVE_ZERO = 0x80000000000000000000000000000000;\n\n  /*\n   * +Infinity.\n   */\n  bytes16 private constant POSITIVE_INFINITY =\n    0x7FFF0000000000000000000000000000;\n\n  /*\n   * -Infinity.\n   */\n  bytes16 private constant NEGATIVE_INFINITY =\n    0xFFFF0000000000000000000000000000;\n\n  /*\n   * Canonical NaN value.\n   */\n  bytes16 private constant NaN = 0x7FFF8000000000000000000000000000;\n\n  /**\n   * Convert signed 256-bit integer number into quadruple precision number.\n   *\n   * @param x signed 256-bit integer number\n   * @return quadruple precision number\n   */\n  function fromInt(int256 x) internal pure returns (bytes16) {\n    unchecked {\n      if (x == 0) return bytes16(0);\n      else {\n        // We rely on overflow behavior here\n        uint256 result = uint256(x > 0 ? x : -x);\n\n        uint256 msb = mostSignificantBit(result);\n        if (msb < 112) result <<= 112 - msb;\n        else if (msb > 112) result >>= msb - 112;\n\n        result =\n          (result & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF) |\n          ((16383 + msb) << 112);\n        if (x < 0) result |= 0x80000000000000000000000000000000;\n\n        return bytes16(uint128(result));\n      }\n    }\n  }\n\n  /**\n   * Convert quadruple precision number into signed 256-bit integer number\n   * rounding towards zero.  Revert on overflow.\n   *\n   * @param x quadruple precision number\n   * @return signed 256-bit integer number\n   */\n  function toInt(bytes16 x) internal pure returns (int256) {\n    unchecked {\n      uint256 exponent = (uint128(x) >> 112) & 0x7FFF;\n\n      require(exponent <= 16638); // Overflow\n      if (exponent < 16383) return 0; // Underflow\n\n      uint256 result = (uint256(uint128(x)) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF) |\n        0x10000000000000000000000000000;\n\n      if (exponent < 16495) result >>= 16495 - exponent;\n      else if (exponent > 16495) result <<= exponent - 16495;\n\n      if (uint128(x) >= 0x80000000000000000000000000000000) {\n        // Negative\n        require(\n          result <=\n            0x8000000000000000000000000000000000000000000000000000000000000000\n        );\n        return -int256(result); // We rely on overflow behavior here\n      } else {\n        require(\n          result <=\n            0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\n        );\n        return int256(result);\n      }\n    }\n  }\n\n  /**\n   * Convert unsigned 256-bit integer number into quadruple precision number.\n   *\n   * @param x unsigned 256-bit integer number\n   * @return quadruple precision number\n   */\n  function fromUInt(uint256 x) internal pure returns (bytes16) {\n    unchecked {\n      if (x == 0) return bytes16(0);\n      else {\n        uint256 result = x;\n\n        uint256 msb = mostSignificantBit(result);\n        if (msb < 112) result <<= 112 - msb;\n        else if (msb > 112) result >>= msb - 112;\n\n        result =\n          (result & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF) |\n          ((16383 + msb) << 112);\n\n        return bytes16(uint128(result));\n      }\n    }\n  }\n\n  /**\n   * Convert quadruple precision number into unsigned 256-bit integer number\n   * rounding towards zero.  Revert on underflow.  Note, that negative floating\n   * point numbers in range (-1.0 .. 0.0) may be converted to unsigned integer\n   * without error, because they are rounded to zero.\n   *\n   * @param x quadruple precision number\n   * @return unsigned 256-bit integer number\n   */\n  function toUInt(bytes16 x) internal pure returns (uint256) {\n    unchecked {\n      uint256 exponent = (uint128(x) >> 112) & 0x7FFF;\n\n      if (exponent < 16383) return 0; // Underflow\n\n      require(uint128(x) < 0x80000000000000000000000000000000); // Negative\n\n      require(exponent <= 16638); // Overflow\n      uint256 result = (uint256(uint128(x)) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF) |\n        0x10000000000000000000000000000;\n\n      if (exponent < 16495) result >>= 16495 - exponent;\n      else if (exponent > 16495) result <<= exponent - 16495;\n\n      return result;\n    }\n  }\n\n  /**\n   * Convert signed 128.128 bit fixed point number into quadruple precision\n   * number.\n   *\n   * @param x signed 128.128 bit fixed point number\n   * @return quadruple precision number\n   */\n  function from128x128(int256 x) internal pure returns (bytes16) {\n    unchecked {\n      if (x == 0) return bytes16(0);\n      else {\n        // We rely on overflow behavior here\n        uint256 result = uint256(x > 0 ? x : -x);\n\n        uint256 msb = mostSignificantBit(result);\n        if (msb < 112) result <<= 112 - msb;\n        else if (msb > 112) result >>= msb - 112;\n\n        result =\n          (result & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF) |\n          ((16255 + msb) << 112);\n        if (x < 0) result |= 0x80000000000000000000000000000000;\n\n        return bytes16(uint128(result));\n      }\n    }\n  }\n\n  /**\n   * Convert quadruple precision number into signed 128.128 bit fixed point\n   * number.  Revert on overflow.\n   *\n   * @param x quadruple precision number\n   * @return signed 128.128 bit fixed point number\n   */\n  function to128x128(bytes16 x) internal pure returns (int256) {\n    unchecked {\n      uint256 exponent = (uint128(x) >> 112) & 0x7FFF;\n\n      require(exponent <= 16510); // Overflow\n      if (exponent < 16255) return 0; // Underflow\n\n      uint256 result = (uint256(uint128(x)) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF) |\n        0x10000000000000000000000000000;\n\n      if (exponent < 16367) result >>= 16367 - exponent;\n      else if (exponent > 16367) result <<= exponent - 16367;\n\n      if (uint128(x) >= 0x80000000000000000000000000000000) {\n        // Negative\n        require(\n          result <=\n            0x8000000000000000000000000000000000000000000000000000000000000000\n        );\n        return -int256(result); // We rely on overflow behavior here\n      } else {\n        require(\n          result <=\n            0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\n        );\n        return int256(result);\n      }\n    }\n  }\n\n  /**\n   * Convert signed 64.64 bit fixed point number into quadruple precision\n   * number.\n   *\n   * @param x signed 64.64 bit fixed point number\n   * @return quadruple precision number\n   */\n  function from64x64(int128 x) internal pure returns (bytes16) {\n    unchecked {\n      if (x == 0) return bytes16(0);\n      else {\n        // We rely on overflow behavior here\n        uint256 result = uint128(x > 0 ? x : -x);\n\n        uint256 msb = mostSignificantBit(result);\n        if (msb < 112) result <<= 112 - msb;\n        else if (msb > 112) result >>= msb - 112;\n\n        result =\n          (result & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF) |\n          ((16319 + msb) << 112);\n        if (x < 0) result |= 0x80000000000000000000000000000000;\n\n        return bytes16(uint128(result));\n      }\n    }\n  }\n\n  /**\n   * Convert quadruple precision number into signed 64.64 bit fixed point\n   * number.  Revert on overflow.\n   *\n   * @param x quadruple precision number\n   * @return signed 64.64 bit fixed point number\n   */\n  function to64x64(bytes16 x) internal pure returns (int128) {\n    unchecked {\n      uint256 exponent = (uint128(x) >> 112) & 0x7FFF;\n\n      require(exponent <= 16446); // Overflow\n      if (exponent < 16319) return 0; // Underflow\n\n      uint256 result = (uint256(uint128(x)) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF) |\n        0x10000000000000000000000000000;\n\n      if (exponent < 16431) result >>= 16431 - exponent;\n      else if (exponent > 16431) result <<= exponent - 16431;\n\n      if (uint128(x) >= 0x80000000000000000000000000000000) {\n        // Negative\n        require(result <= 0x80000000000000000000000000000000);\n        return -int128(int256(result)); // We rely on overflow behavior here\n      } else {\n        require(result <= 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\n        return int128(int256(result));\n      }\n    }\n  }\n\n  /**\n   * Convert octuple precision number into quadruple precision number.\n   *\n   * @param x octuple precision number\n   * @return quadruple precision number\n   */\n  function fromOctuple(bytes32 x) internal pure returns (bytes16) {\n    unchecked {\n      bool negative = x &\n        0x8000000000000000000000000000000000000000000000000000000000000000 >\n        0;\n\n      uint256 exponent = (uint256(x) >> 236) & 0x7FFFF;\n      uint256 significand = uint256(x) &\n        0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\n\n      if (exponent == 0x7FFFF) {\n        if (significand > 0) return NaN;\n        else return negative ? NEGATIVE_INFINITY : POSITIVE_INFINITY;\n      }\n\n      if (exponent > 278526)\n        return negative ? NEGATIVE_INFINITY : POSITIVE_INFINITY;\n      else if (exponent < 245649)\n        return negative ? NEGATIVE_ZERO : POSITIVE_ZERO;\n      else if (exponent < 245761) {\n        significand =\n          (significand |\n            0x100000000000000000000000000000000000000000000000000000000000) >>\n          (245885 - exponent);\n        exponent = 0;\n      } else {\n        significand >>= 124;\n        exponent -= 245760;\n      }\n\n      uint128 result = uint128(significand | (exponent << 112));\n      if (negative) result |= 0x80000000000000000000000000000000;\n\n      return bytes16(result);\n    }\n  }\n\n  /**\n   * Convert quadruple precision number into octuple precision number.\n   *\n   * @param x quadruple precision number\n   * @return octuple precision number\n   */\n  function toOctuple(bytes16 x) internal pure returns (bytes32) {\n    unchecked {\n      uint256 exponent = (uint128(x) >> 112) & 0x7FFF;\n\n      uint256 result = uint128(x) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\n\n      if (exponent == 0x7FFF)\n        exponent = 0x7FFFF; // Infinity or NaN\n      else if (exponent == 0) {\n        if (result > 0) {\n          uint256 msb = mostSignificantBit(result);\n          result =\n            (result << (236 - msb)) &\n            0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\n          exponent = 245649 + msb;\n        }\n      } else {\n        result <<= 124;\n        exponent += 245760;\n      }\n\n      result |= exponent << 236;\n      if (uint128(x) >= 0x80000000000000000000000000000000)\n        result |= 0x8000000000000000000000000000000000000000000000000000000000000000;\n\n      return bytes32(result);\n    }\n  }\n\n  /**\n   * Convert double precision number into quadruple precision number.\n   *\n   * @param x double precision number\n   * @return quadruple precision number\n   */\n  function fromDouble(bytes8 x) internal pure returns (bytes16) {\n    unchecked {\n      uint256 exponent = (uint64(x) >> 52) & 0x7FF;\n\n      uint256 result = uint64(x) & 0xFFFFFFFFFFFFF;\n\n      if (exponent == 0x7FF)\n        exponent = 0x7FFF; // Infinity or NaN\n      else if (exponent == 0) {\n        if (result > 0) {\n          uint256 msb = mostSignificantBit(result);\n          result = (result << (112 - msb)) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\n          exponent = 15309 + msb;\n        }\n      } else {\n        result <<= 60;\n        exponent += 15360;\n      }\n\n      result |= exponent << 112;\n      if (x & 0x8000000000000000 > 0)\n        result |= 0x80000000000000000000000000000000;\n\n      return bytes16(uint128(result));\n    }\n  }\n\n  /**\n   * Convert quadruple precision number into double precision number.\n   *\n   * @param x quadruple precision number\n   * @return double precision number\n   */\n  function toDouble(bytes16 x) internal pure returns (bytes8) {\n    unchecked {\n      bool negative = uint128(x) >= 0x80000000000000000000000000000000;\n\n      uint256 exponent = (uint128(x) >> 112) & 0x7FFF;\n      uint256 significand = uint128(x) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\n\n      if (exponent == 0x7FFF) {\n        if (significand > 0) return 0x7FF8000000000000;\n        // NaN\n        else\n          return\n            negative\n              ? bytes8(0xFFF0000000000000) // -Infinity\n              : bytes8(0x7FF0000000000000); // Infinity\n      }\n\n      if (exponent > 17406)\n        return\n          negative\n            ? bytes8(0xFFF0000000000000) // -Infinity\n            : bytes8(0x7FF0000000000000);\n      // Infinity\n      else if (exponent < 15309)\n        return\n          negative\n            ? bytes8(0x8000000000000000) // -0\n            : bytes8(0x0000000000000000);\n      // 0\n      else if (exponent < 15361) {\n        significand =\n          (significand | 0x10000000000000000000000000000) >>\n          (15421 - exponent);\n        exponent = 0;\n      } else {\n        significand >>= 60;\n        exponent -= 15360;\n      }\n\n      uint64 result = uint64(significand | (exponent << 52));\n      if (negative) result |= 0x8000000000000000;\n\n      return bytes8(result);\n    }\n  }\n\n  /**\n   * Test whether given quadruple precision number is NaN.\n   *\n   * @param x quadruple precision number\n   * @return true if x is NaN, false otherwise\n   */\n  function isNaN(bytes16 x) internal pure returns (bool) {\n    unchecked {\n      return\n        uint128(x) & 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF >\n        0x7FFF0000000000000000000000000000;\n    }\n  }\n\n  /**\n   * Test whether given quadruple precision number is positive or negative\n   * infinity.\n   *\n   * @param x quadruple precision number\n   * @return true if x is positive or negative infinity, false otherwise\n   */\n  function isInfinity(bytes16 x) internal pure returns (bool) {\n    unchecked {\n      return\n        uint128(x) & 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF ==\n        0x7FFF0000000000000000000000000000;\n    }\n  }\n\n  /**\n   * Calculate sign of x, i.e. -1 if x is negative, 0 if x if zero, and 1 if x\n   * is positive.  Note that sign (-0) is zero.  Revert if x is NaN.\n   *\n   * @param x quadruple precision number\n   * @return sign of x\n   */\n  function sign(bytes16 x) internal pure returns (int8) {\n    unchecked {\n      uint128 absoluteX = uint128(x) & 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\n\n      require(absoluteX <= 0x7FFF0000000000000000000000000000); // Not NaN\n\n      if (absoluteX == 0) return 0;\n      else if (uint128(x) >= 0x80000000000000000000000000000000) return -1;\n      else return 1;\n    }\n  }\n\n  /**\n   * Calculate sign (x - y).  Revert if either argument is NaN, or both\n   * arguments are infinities of the same sign.\n   *\n   * @param x quadruple precision number\n   * @param y quadruple precision number\n   * @return sign (x - y)\n   */\n  function cmp(bytes16 x, bytes16 y) internal pure returns (int8) {\n    unchecked {\n      uint128 absoluteX = uint128(x) & 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\n\n      require(absoluteX <= 0x7FFF0000000000000000000000000000); // Not NaN\n\n      uint128 absoluteY = uint128(y) & 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\n\n      require(absoluteY <= 0x7FFF0000000000000000000000000000); // Not NaN\n\n      // Not infinities of the same sign\n      require(x != y || absoluteX < 0x7FFF0000000000000000000000000000);\n\n      if (x == y) return 0;\n      else {\n        bool negativeX = uint128(x) >= 0x80000000000000000000000000000000;\n        bool negativeY = uint128(y) >= 0x80000000000000000000000000000000;\n\n        if (negativeX) {\n          if (negativeY) return absoluteX > absoluteY ? -1 : int8(1);\n          else return -1;\n        } else {\n          if (negativeY) return 1;\n          else return absoluteX > absoluteY ? int8(1) : -1;\n        }\n      }\n    }\n  }\n\n  /**\n   * Test whether x equals y.  NaN, infinity, and -infinity are not equal to\n   * anything.\n   *\n   * @param x quadruple precision number\n   * @param y quadruple precision number\n   * @return true if x equals to y, false otherwise\n   */\n  function eq(bytes16 x, bytes16 y) internal pure returns (bool) {\n    unchecked {\n      if (x == y) {\n        return\n          uint128(x) & 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF <\n          0x7FFF0000000000000000000000000000;\n      } else return false;\n    }\n  }\n\n  /**\n   * Calculate x + y.  Special values behave in the following way:\n   *\n   * NaN + x = NaN for any x.\n   * Infinity + x = Infinity for any finite x.\n   * -Infinity + x = -Infinity for any finite x.\n   * Infinity + Infinity = Infinity.\n   * -Infinity + -Infinity = -Infinity.\n   * Infinity + -Infinity = -Infinity + Infinity = NaN.\n   *\n   * @param x quadruple precision number\n   * @param y quadruple precision number\n   * @return quadruple precision number\n   */\n  function add(bytes16 x, bytes16 y) internal pure returns (bytes16) {\n    unchecked {\n      uint256 xExponent = (uint128(x) >> 112) & 0x7FFF;\n      uint256 yExponent = (uint128(y) >> 112) & 0x7FFF;\n\n      if (xExponent == 0x7FFF) {\n        if (yExponent == 0x7FFF) {\n          if (x == y) return x;\n          else return NaN;\n        } else return x;\n      } else if (yExponent == 0x7FFF) return y;\n      else {\n        bool xSign = uint128(x) >= 0x80000000000000000000000000000000;\n        uint256 xSignifier = uint128(x) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\n        if (xExponent == 0) xExponent = 1;\n        else xSignifier |= 0x10000000000000000000000000000;\n\n        bool ySign = uint128(y) >= 0x80000000000000000000000000000000;\n        uint256 ySignifier = uint128(y) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\n        if (yExponent == 0) yExponent = 1;\n        else ySignifier |= 0x10000000000000000000000000000;\n\n        if (xSignifier == 0) return y == NEGATIVE_ZERO ? POSITIVE_ZERO : y;\n        else if (ySignifier == 0) return x == NEGATIVE_ZERO ? POSITIVE_ZERO : x;\n        else {\n          int256 delta = int256(xExponent) - int256(yExponent);\n\n          if (xSign == ySign) {\n            if (delta > 112) return x;\n            else if (delta > 0) ySignifier >>= uint256(delta);\n            else if (delta < -112) return y;\n            else if (delta < 0) {\n              xSignifier >>= uint256(-delta);\n              xExponent = yExponent;\n            }\n\n            xSignifier += ySignifier;\n\n            if (xSignifier >= 0x20000000000000000000000000000) {\n              xSignifier >>= 1;\n              xExponent += 1;\n            }\n\n            if (xExponent == 0x7FFF)\n              return xSign ? NEGATIVE_INFINITY : POSITIVE_INFINITY;\n            else {\n              if (xSignifier < 0x10000000000000000000000000000) xExponent = 0;\n              else xSignifier &= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\n\n              return\n                bytes16(\n                  uint128(\n                    (xSign ? 0x80000000000000000000000000000000 : 0) |\n                      (xExponent << 112) |\n                      xSignifier\n                  )\n                );\n            }\n          } else {\n            if (delta > 0) {\n              xSignifier <<= 1;\n              xExponent -= 1;\n            } else if (delta < 0) {\n              ySignifier <<= 1;\n              xExponent = yExponent - 1;\n            }\n\n            if (delta > 112) ySignifier = 1;\n            else if (delta > 1)\n              ySignifier = ((ySignifier - 1) >> uint256(delta - 1)) + 1;\n            else if (delta < -112) xSignifier = 1;\n            else if (delta < -1)\n              xSignifier = ((xSignifier - 1) >> uint256(-delta - 1)) + 1;\n\n            if (xSignifier >= ySignifier) xSignifier -= ySignifier;\n            else {\n              xSignifier = ySignifier - xSignifier;\n              xSign = ySign;\n            }\n\n            if (xSignifier == 0) return POSITIVE_ZERO;\n\n            uint256 msb = mostSignificantBit(xSignifier);\n\n            if (msb == 113) {\n              xSignifier = (xSignifier >> 1) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\n              xExponent += 1;\n            } else if (msb < 112) {\n              uint256 shift = 112 - msb;\n              if (xExponent > shift) {\n                xSignifier =\n                  (xSignifier << shift) &\n                  0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\n                xExponent -= shift;\n              } else {\n                xSignifier <<= xExponent - 1;\n                xExponent = 0;\n              }\n            } else xSignifier &= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\n\n            if (xExponent == 0x7FFF)\n              return xSign ? NEGATIVE_INFINITY : POSITIVE_INFINITY;\n            else\n              return\n                bytes16(\n                  uint128(\n                    (xSign ? 0x80000000000000000000000000000000 : 0) |\n                      (xExponent << 112) |\n                      xSignifier\n                  )\n                );\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * Calculate x - y.  Special values behave in the following way:\n   *\n   * NaN - x = NaN for any x.\n   * Infinity - x = Infinity for any finite x.\n   * -Infinity - x = -Infinity for any finite x.\n   * Infinity - -Infinity = Infinity.\n   * -Infinity - Infinity = -Infinity.\n   * Infinity - Infinity = -Infinity - -Infinity = NaN.\n   *\n   * @param x quadruple precision number\n   * @param y quadruple precision number\n   * @return quadruple precision number\n   */\n  function sub(bytes16 x, bytes16 y) internal pure returns (bytes16) {\n    unchecked {\n      return add(x, y ^ 0x80000000000000000000000000000000);\n    }\n  }\n\n  /**\n   * Calculate x * y.  Special values behave in the following way:\n   *\n   * NaN * x = NaN for any x.\n   * Infinity * x = Infinity for any finite positive x.\n   * Infinity * x = -Infinity for any finite negative x.\n   * -Infinity * x = -Infinity for any finite positive x.\n   * -Infinity * x = Infinity for any finite negative x.\n   * Infinity * 0 = NaN.\n   * -Infinity * 0 = NaN.\n   * Infinity * Infinity = Infinity.\n   * Infinity * -Infinity = -Infinity.\n   * -Infinity * Infinity = -Infinity.\n   * -Infinity * -Infinity = Infinity.\n   *\n   * @param x quadruple precision number\n   * @param y quadruple precision number\n   * @return quadruple precision number\n   */\n  function mul(bytes16 x, bytes16 y) internal pure returns (bytes16) {\n    unchecked {\n      uint256 xExponent = (uint128(x) >> 112) & 0x7FFF;\n      uint256 yExponent = (uint128(y) >> 112) & 0x7FFF;\n\n      if (xExponent == 0x7FFF) {\n        if (yExponent == 0x7FFF) {\n          if (x == y) return x ^ (y & 0x80000000000000000000000000000000);\n          else if (x ^ y == 0x80000000000000000000000000000000) return x | y;\n          else return NaN;\n        } else {\n          if (y & 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF == 0) return NaN;\n          else return x ^ (y & 0x80000000000000000000000000000000);\n        }\n      } else if (yExponent == 0x7FFF) {\n        if (x & 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF == 0) return NaN;\n        else return y ^ (x & 0x80000000000000000000000000000000);\n      } else {\n        uint256 xSignifier = uint128(x) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\n        if (xExponent == 0) xExponent = 1;\n        else xSignifier |= 0x10000000000000000000000000000;\n\n        uint256 ySignifier = uint128(y) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\n        if (yExponent == 0) yExponent = 1;\n        else ySignifier |= 0x10000000000000000000000000000;\n\n        xSignifier *= ySignifier;\n        if (xSignifier == 0)\n          return\n            (x ^ y) & 0x80000000000000000000000000000000 > 0\n              ? NEGATIVE_ZERO\n              : POSITIVE_ZERO;\n\n        xExponent += yExponent;\n\n        uint256 msb = xSignifier >=\n          0x200000000000000000000000000000000000000000000000000000000\n          ? 225\n          : xSignifier >=\n            0x100000000000000000000000000000000000000000000000000000000\n          ? 224\n          : mostSignificantBit(xSignifier);\n\n        if (xExponent + msb < 16496) {\n          // Underflow\n          xExponent = 0;\n          xSignifier = 0;\n        } else if (xExponent + msb < 16608) {\n          // Subnormal\n          if (xExponent < 16496) xSignifier >>= 16496 - xExponent;\n          else if (xExponent > 16496) xSignifier <<= xExponent - 16496;\n          xExponent = 0;\n        } else if (xExponent + msb > 49373) {\n          xExponent = 0x7FFF;\n          xSignifier = 0;\n        } else {\n          if (msb > 112) xSignifier >>= msb - 112;\n          else if (msb < 112) xSignifier <<= 112 - msb;\n\n          xSignifier &= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\n\n          xExponent = xExponent + msb - 16607;\n        }\n\n        return\n          bytes16(\n            uint128(\n              uint128((x ^ y) & 0x80000000000000000000000000000000) |\n                (xExponent << 112) |\n                xSignifier\n            )\n          );\n      }\n    }\n  }\n\n  /**\n   * Calculate x / y.  Special values behave in the following way:\n   *\n   * NaN / x = NaN for any x.\n   * x / NaN = NaN for any x.\n   * Infinity / x = Infinity for any finite non-negative x.\n   * Infinity / x = -Infinity for any finite negative x including -0.\n   * -Infinity / x = -Infinity for any finite non-negative x.\n   * -Infinity / x = Infinity for any finite negative x including -0.\n   * x / Infinity = 0 for any finite non-negative x.\n   * x / -Infinity = -0 for any finite non-negative x.\n   * x / Infinity = -0 for any finite non-negative x including -0.\n   * x / -Infinity = 0 for any finite non-negative x including -0.\n   *\n   * Infinity / Infinity = NaN.\n   * Infinity / -Infinity = -NaN.\n   * -Infinity / Infinity = -NaN.\n   * -Infinity / -Infinity = NaN.\n   *\n   * Division by zero behaves in the following way:\n   *\n   * x / 0 = Infinity for any finite positive x.\n   * x / -0 = -Infinity for any finite positive x.\n   * x / 0 = -Infinity for any finite negative x.\n   * x / -0 = Infinity for any finite negative x.\n   * 0 / 0 = NaN.\n   * 0 / -0 = NaN.\n   * -0 / 0 = NaN.\n   * -0 / -0 = NaN.\n   *\n   * @param x quadruple precision number\n   * @param y quadruple precision number\n   * @return quadruple precision number\n   */\n  function div(bytes16 x, bytes16 y) internal pure returns (bytes16) {\n    unchecked {\n      uint256 xExponent = (uint128(x) >> 112) & 0x7FFF;\n      uint256 yExponent = (uint128(y) >> 112) & 0x7FFF;\n\n      if (xExponent == 0x7FFF) {\n        if (yExponent == 0x7FFF) return NaN;\n        else return x ^ (y & 0x80000000000000000000000000000000);\n      } else if (yExponent == 0x7FFF) {\n        if (y & 0x0000FFFFFFFFFFFFFFFFFFFFFFFFFFFF != 0) return NaN;\n        else\n          return POSITIVE_ZERO | ((x ^ y) & 0x80000000000000000000000000000000);\n      } else if (y & 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF == 0) {\n        if (x & 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF == 0) return NaN;\n        else\n          return\n            POSITIVE_INFINITY | ((x ^ y) & 0x80000000000000000000000000000000);\n      } else {\n        uint256 ySignifier = uint128(y) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\n        if (yExponent == 0) yExponent = 1;\n        else ySignifier |= 0x10000000000000000000000000000;\n\n        uint256 xSignifier = uint128(x) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\n        if (xExponent == 0) {\n          if (xSignifier != 0) {\n            uint256 shift = 226 - mostSignificantBit(xSignifier);\n\n            xSignifier <<= shift;\n\n            xExponent = 1;\n            yExponent += shift - 114;\n          }\n        } else {\n          xSignifier = (xSignifier | 0x10000000000000000000000000000) << 114;\n        }\n\n        xSignifier = xSignifier / ySignifier;\n        if (xSignifier == 0)\n          return\n            (x ^ y) & 0x80000000000000000000000000000000 > 0\n              ? NEGATIVE_ZERO\n              : POSITIVE_ZERO;\n\n        assert(xSignifier >= 0x1000000000000000000000000000);\n\n        uint256 msb = xSignifier >= 0x80000000000000000000000000000\n          ? mostSignificantBit(xSignifier)\n          : xSignifier >= 0x40000000000000000000000000000\n          ? 114\n          : xSignifier >= 0x20000000000000000000000000000\n          ? 113\n          : 112;\n\n        if (xExponent + msb > yExponent + 16497) {\n          // Overflow\n          xExponent = 0x7FFF;\n          xSignifier = 0;\n        } else if (xExponent + msb + 16380 < yExponent) {\n          // Underflow\n          xExponent = 0;\n          xSignifier = 0;\n        } else if (xExponent + msb + 16268 < yExponent) {\n          // Subnormal\n          if (xExponent + 16380 > yExponent)\n            xSignifier <<= xExponent + 16380 - yExponent;\n          else if (xExponent + 16380 < yExponent)\n            xSignifier >>= yExponent - xExponent - 16380;\n\n          xExponent = 0;\n        } else {\n          // Normal\n          if (msb > 112) xSignifier >>= msb - 112;\n\n          xSignifier &= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\n\n          xExponent = xExponent + msb + 16269 - yExponent;\n        }\n\n        return\n          bytes16(\n            uint128(\n              uint128((x ^ y) & 0x80000000000000000000000000000000) |\n                (xExponent << 112) |\n                xSignifier\n            )\n          );\n      }\n    }\n  }\n\n  /**\n   * Calculate -x.\n   *\n   * @param x quadruple precision number\n   * @return quadruple precision number\n   */\n  function neg(bytes16 x) internal pure returns (bytes16) {\n    unchecked {\n      return x ^ 0x80000000000000000000000000000000;\n    }\n  }\n\n  /**\n   * Calculate |x|.\n   *\n   * @param x quadruple precision number\n   * @return quadruple precision number\n   */\n  function abs(bytes16 x) internal pure returns (bytes16) {\n    unchecked {\n      return x & 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\n    }\n  }\n\n  /**\n   * Calculate square root of x.  Return NaN on negative x excluding -0.\n   *\n   * @param x quadruple precision number\n   * @return quadruple precision number\n   */\n  function sqrt(bytes16 x) internal pure returns (bytes16) {\n    unchecked {\n      if (uint128(x) > 0x80000000000000000000000000000000) return NaN;\n      else {\n        uint256 xExponent = (uint128(x) >> 112) & 0x7FFF;\n        if (xExponent == 0x7FFF) return x;\n        else {\n          uint256 xSignifier = uint128(x) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\n          if (xExponent == 0) xExponent = 1;\n          else xSignifier |= 0x10000000000000000000000000000;\n\n          if (xSignifier == 0) return POSITIVE_ZERO;\n\n          bool oddExponent = xExponent & 0x1 == 0;\n          xExponent = (xExponent + 16383) >> 1;\n\n          if (oddExponent) {\n            if (xSignifier >= 0x10000000000000000000000000000)\n              xSignifier <<= 113;\n            else {\n              uint256 msb = mostSignificantBit(xSignifier);\n              uint256 shift = (226 - msb) & 0xFE;\n              xSignifier <<= shift;\n              xExponent -= (shift - 112) >> 1;\n            }\n          } else {\n            if (xSignifier >= 0x10000000000000000000000000000)\n              xSignifier <<= 112;\n            else {\n              uint256 msb = mostSignificantBit(xSignifier);\n              uint256 shift = (225 - msb) & 0xFE;\n              xSignifier <<= shift;\n              xExponent -= (shift - 112) >> 1;\n            }\n          }\n\n          uint256 r = 0x10000000000000000000000000000;\n          r = (r + xSignifier / r) >> 1;\n          r = (r + xSignifier / r) >> 1;\n          r = (r + xSignifier / r) >> 1;\n          r = (r + xSignifier / r) >> 1;\n          r = (r + xSignifier / r) >> 1;\n          r = (r + xSignifier / r) >> 1;\n          r = (r + xSignifier / r) >> 1; // Seven iterations should be enough\n          uint256 r1 = xSignifier / r;\n          if (r1 < r) r = r1;\n\n          return\n            bytes16(\n              uint128((xExponent << 112) | (r & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF))\n            );\n        }\n      }\n    }\n  }\n\n  /**\n   * Calculate binary logarithm of x.  Return NaN on negative x excluding -0.\n   *\n   * @param x quadruple precision number\n   * @return quadruple precision number\n   */\n  function log_2(bytes16 x) internal pure returns (bytes16) {\n    unchecked {\n      if (uint128(x) > 0x80000000000000000000000000000000) return NaN;\n      else if (x == 0x3FFF0000000000000000000000000000) return POSITIVE_ZERO;\n      else {\n        uint256 xExponent = (uint128(x) >> 112) & 0x7FFF;\n        if (xExponent == 0x7FFF) return x;\n        else {\n          uint256 xSignifier = uint128(x) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\n          if (xExponent == 0) xExponent = 1;\n          else xSignifier |= 0x10000000000000000000000000000;\n\n          if (xSignifier == 0) return NEGATIVE_INFINITY;\n\n          bool resultNegative;\n          uint256 resultExponent = 16495;\n          uint256 resultSignifier;\n\n          if (xExponent >= 0x3FFF) {\n            resultNegative = false;\n            resultSignifier = xExponent - 0x3FFF;\n            xSignifier <<= 15;\n          } else {\n            resultNegative = true;\n            if (xSignifier >= 0x10000000000000000000000000000) {\n              resultSignifier = 0x3FFE - xExponent;\n              xSignifier <<= 15;\n            } else {\n              uint256 msb = mostSignificantBit(xSignifier);\n              resultSignifier = 16493 - msb;\n              xSignifier <<= 127 - msb;\n            }\n          }\n\n          if (xSignifier == 0x80000000000000000000000000000000) {\n            if (resultNegative) resultSignifier += 1;\n            uint256 shift = 112 - mostSignificantBit(resultSignifier);\n            resultSignifier <<= shift;\n            resultExponent -= shift;\n          } else {\n            uint256 bb = resultNegative ? 1 : 0;\n            while (resultSignifier < 0x10000000000000000000000000000) {\n              resultSignifier <<= 1;\n              resultExponent -= 1;\n\n              xSignifier *= xSignifier;\n              uint256 b = xSignifier >> 255;\n              resultSignifier += b ^ bb;\n              xSignifier >>= 127 + b;\n            }\n          }\n\n          return\n            bytes16(\n              uint128(\n                (resultNegative ? 0x80000000000000000000000000000000 : 0) |\n                  (resultExponent << 112) |\n                  (resultSignifier & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF)\n              )\n            );\n        }\n      }\n    }\n  }\n\n  /**\n   * Calculate natural logarithm of x.  Return NaN on negative x excluding -0.\n   *\n   * @param x quadruple precision number\n   * @return quadruple precision number\n   */\n  function ln(bytes16 x) internal pure returns (bytes16) {\n    unchecked {\n      return mul(log_2(x), 0x3FFE62E42FEFA39EF35793C7673007E5);\n    }\n  }\n\n  /**\n   * Calculate 2^x.\n   *\n   * @param x quadruple precision number\n   * @return quadruple precision number\n   */\n  function pow_2(bytes16 x) internal pure returns (bytes16) {\n    unchecked {\n      bool xNegative = uint128(x) > 0x80000000000000000000000000000000;\n      uint256 xExponent = (uint128(x) >> 112) & 0x7FFF;\n      uint256 xSignifier = uint128(x) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\n\n      if (xExponent == 0x7FFF && xSignifier != 0) return NaN;\n      else if (xExponent > 16397)\n        return xNegative ? POSITIVE_ZERO : POSITIVE_INFINITY;\n      else if (xExponent < 16255) return 0x3FFF0000000000000000000000000000;\n      else {\n        if (xExponent == 0) xExponent = 1;\n        else xSignifier |= 0x10000000000000000000000000000;\n\n        if (xExponent > 16367) xSignifier <<= xExponent - 16367;\n        else if (xExponent < 16367) xSignifier >>= 16367 - xExponent;\n\n        if (xNegative && xSignifier > 0x406E00000000000000000000000000000000)\n          return POSITIVE_ZERO;\n\n        if (!xNegative && xSignifier > 0x3FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)\n          return POSITIVE_INFINITY;\n\n        uint256 resultExponent = xSignifier >> 128;\n        xSignifier &= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\n        if (xNegative && xSignifier != 0) {\n          xSignifier = ~xSignifier;\n          resultExponent += 1;\n        }\n\n        uint256 resultSignifier = 0x80000000000000000000000000000000;\n        if (xSignifier & 0x80000000000000000000000000000000 > 0)\n          resultSignifier =\n            (resultSignifier * 0x16A09E667F3BCC908B2FB1366EA957D3E) >>\n            128;\n        if (xSignifier & 0x40000000000000000000000000000000 > 0)\n          resultSignifier =\n            (resultSignifier * 0x1306FE0A31B7152DE8D5A46305C85EDEC) >>\n            128;\n        if (xSignifier & 0x20000000000000000000000000000000 > 0)\n          resultSignifier =\n            (resultSignifier * 0x1172B83C7D517ADCDF7C8C50EB14A791F) >>\n            128;\n        if (xSignifier & 0x10000000000000000000000000000000 > 0)\n          resultSignifier =\n            (resultSignifier * 0x10B5586CF9890F6298B92B71842A98363) >>\n            128;\n        if (xSignifier & 0x8000000000000000000000000000000 > 0)\n          resultSignifier =\n            (resultSignifier * 0x1059B0D31585743AE7C548EB68CA417FD) >>\n            128;\n        if (xSignifier & 0x4000000000000000000000000000000 > 0)\n          resultSignifier =\n            (resultSignifier * 0x102C9A3E778060EE6F7CACA4F7A29BDE8) >>\n            128;\n        if (xSignifier & 0x2000000000000000000000000000000 > 0)\n          resultSignifier =\n            (resultSignifier * 0x10163DA9FB33356D84A66AE336DCDFA3F) >>\n            128;\n        if (xSignifier & 0x1000000000000000000000000000000 > 0)\n          resultSignifier =\n            (resultSignifier * 0x100B1AFA5ABCBED6129AB13EC11DC9543) >>\n            128;\n        if (xSignifier & 0x800000000000000000000000000000 > 0)\n          resultSignifier =\n            (resultSignifier * 0x10058C86DA1C09EA1FF19D294CF2F679B) >>\n            128;\n        if (xSignifier & 0x400000000000000000000000000000 > 0)\n          resultSignifier =\n            (resultSignifier * 0x1002C605E2E8CEC506D21BFC89A23A00F) >>\n            128;\n        if (xSignifier & 0x200000000000000000000000000000 > 0)\n          resultSignifier =\n            (resultSignifier * 0x100162F3904051FA128BCA9C55C31E5DF) >>\n            128;\n        if (xSignifier & 0x100000000000000000000000000000 > 0)\n          resultSignifier =\n            (resultSignifier * 0x1000B175EFFDC76BA38E31671CA939725) >>\n            128;\n        if (xSignifier & 0x80000000000000000000000000000 > 0)\n          resultSignifier =\n            (resultSignifier * 0x100058BA01FB9F96D6CACD4B180917C3D) >>\n            128;\n        if (xSignifier & 0x40000000000000000000000000000 > 0)\n          resultSignifier =\n            (resultSignifier * 0x10002C5CC37DA9491D0985C348C68E7B3) >>\n            128;\n        if (xSignifier & 0x20000000000000000000000000000 > 0)\n          resultSignifier =\n            (resultSignifier * 0x1000162E525EE054754457D5995292026) >>\n            128;\n        if (xSignifier & 0x10000000000000000000000000000 > 0)\n          resultSignifier =\n            (resultSignifier * 0x10000B17255775C040618BF4A4ADE83FC) >>\n            128;\n        if (xSignifier & 0x8000000000000000000000000000 > 0)\n          resultSignifier =\n            (resultSignifier * 0x1000058B91B5BC9AE2EED81E9B7D4CFAB) >>\n            128;\n        if (xSignifier & 0x4000000000000000000000000000 > 0)\n          resultSignifier =\n            (resultSignifier * 0x100002C5C89D5EC6CA4D7C8ACC017B7C9) >>\n            128;\n        if (xSignifier & 0x2000000000000000000000000000 > 0)\n          resultSignifier =\n            (resultSignifier * 0x10000162E43F4F831060E02D839A9D16D) >>\n            128;\n        if (xSignifier & 0x1000000000000000000000000000 > 0)\n          resultSignifier =\n            (resultSignifier * 0x100000B1721BCFC99D9F890EA06911763) >>\n            128;\n        if (xSignifier & 0x800000000000000000000000000 > 0)\n          resultSignifier =\n            (resultSignifier * 0x10000058B90CF1E6D97F9CA14DBCC1628) >>\n            128;\n        if (xSignifier & 0x400000000000000000000000000 > 0)\n          resultSignifier =\n            (resultSignifier * 0x1000002C5C863B73F016468F6BAC5CA2B) >>\n            128;\n        if (xSignifier & 0x200000000000000000000000000 > 0)\n          resultSignifier =\n            (resultSignifier * 0x100000162E430E5A18F6119E3C02282A5) >>\n            128;\n        if (xSignifier & 0x100000000000000000000000000 > 0)\n          resultSignifier =\n            (resultSignifier * 0x1000000B1721835514B86E6D96EFD1BFE) >>\n            128;\n        if (xSignifier & 0x80000000000000000000000000 > 0)\n          resultSignifier =\n            (resultSignifier * 0x100000058B90C0B48C6BE5DF846C5B2EF) >>\n            128;\n        if (xSignifier & 0x40000000000000000000000000 > 0)\n          resultSignifier =\n            (resultSignifier * 0x10000002C5C8601CC6B9E94213C72737A) >>\n            128;\n        if (xSignifier & 0x20000000000000000000000000 > 0)\n          resultSignifier =\n            (resultSignifier * 0x1000000162E42FFF037DF38AA2B219F06) >>\n            128;\n        if (xSignifier & 0x10000000000000000000000000 > 0)\n          resultSignifier =\n            (resultSignifier * 0x10000000B17217FBA9C739AA5819F44F9) >>\n            128;\n        if (xSignifier & 0x8000000000000000000000000 > 0)\n          resultSignifier =\n            (resultSignifier * 0x1000000058B90BFCDEE5ACD3C1CEDC823) >>\n            128;\n        if (xSignifier & 0x4000000000000000000000000 > 0)\n          resultSignifier =\n            (resultSignifier * 0x100000002C5C85FE31F35A6A30DA1BE50) >>\n            128;\n        if (xSignifier & 0x2000000000000000000000000 > 0)\n          resultSignifier =\n            (resultSignifier * 0x10000000162E42FF0999CE3541B9FFFCF) >>\n            128;\n        if (xSignifier & 0x1000000000000000000000000 > 0)\n          resultSignifier =\n            (resultSignifier * 0x100000000B17217F80F4EF5AADDA45554) >>\n            128;\n        if (xSignifier & 0x800000000000000000000000 > 0)\n          resultSignifier =\n            (resultSignifier * 0x10000000058B90BFBF8479BD5A81B51AD) >>\n            128;\n        if (xSignifier & 0x400000000000000000000000 > 0)\n          resultSignifier =\n            (resultSignifier * 0x1000000002C5C85FDF84BD62AE30A74CC) >>\n            128;\n        if (xSignifier & 0x200000000000000000000000 > 0)\n          resultSignifier =\n            (resultSignifier * 0x100000000162E42FEFB2FED257559BDAA) >>\n            128;\n        if (xSignifier & 0x100000000000000000000000 > 0)\n          resultSignifier =\n            (resultSignifier * 0x1000000000B17217F7D5A7716BBA4A9AE) >>\n            128;\n        if (xSignifier & 0x80000000000000000000000 > 0)\n          resultSignifier =\n            (resultSignifier * 0x100000000058B90BFBE9DDBAC5E109CCE) >>\n            128;\n        if (xSignifier & 0x40000000000000000000000 > 0)\n          resultSignifier =\n            (resultSignifier * 0x10000000002C5C85FDF4B15DE6F17EB0D) >>\n            128;\n        if (xSignifier & 0x20000000000000000000000 > 0)\n          resultSignifier =\n            (resultSignifier * 0x1000000000162E42FEFA494F1478FDE05) >>\n            128;\n        if (xSignifier & 0x10000000000000000000000 > 0)\n          resultSignifier =\n            (resultSignifier * 0x10000000000B17217F7D20CF927C8E94C) >>\n            128;\n        if (xSignifier & 0x8000000000000000000000 > 0)\n          resultSignifier =\n            (resultSignifier * 0x1000000000058B90BFBE8F71CB4E4B33D) >>\n            128;\n        if (xSignifier & 0x4000000000000000000000 > 0)\n          resultSignifier =\n            (resultSignifier * 0x100000000002C5C85FDF477B662B26945) >>\n            128;\n        if (xSignifier & 0x2000000000000000000000 > 0)\n          resultSignifier =\n            (resultSignifier * 0x10000000000162E42FEFA3AE53369388C) >>\n            128;\n        if (xSignifier & 0x1000000000000000000000 > 0)\n          resultSignifier =\n            (resultSignifier * 0x100000000000B17217F7D1D351A389D40) >>\n            128;\n        if (xSignifier & 0x800000000000000000000 > 0)\n          resultSignifier =\n            (resultSignifier * 0x10000000000058B90BFBE8E8B2D3D4EDE) >>\n            128;\n        if (xSignifier & 0x400000000000000000000 > 0)\n          resultSignifier =\n            (resultSignifier * 0x1000000000002C5C85FDF4741BEA6E77E) >>\n            128;\n        if (xSignifier & 0x200000000000000000000 > 0)\n          resultSignifier =\n            (resultSignifier * 0x100000000000162E42FEFA39FE95583C2) >>\n            128;\n        if (xSignifier & 0x100000000000000000000 > 0)\n          resultSignifier =\n            (resultSignifier * 0x1000000000000B17217F7D1CFB72B45E1) >>\n            128;\n        if (xSignifier & 0x80000000000000000000 > 0)\n          resultSignifier =\n            (resultSignifier * 0x100000000000058B90BFBE8E7CC35C3F0) >>\n            128;\n        if (xSignifier & 0x40000000000000000000 > 0)\n          resultSignifier =\n            (resultSignifier * 0x10000000000002C5C85FDF473E242EA38) >>\n            128;\n        if (xSignifier & 0x20000000000000000000 > 0)\n          resultSignifier =\n            (resultSignifier * 0x1000000000000162E42FEFA39F02B772C) >>\n            128;\n        if (xSignifier & 0x10000000000000000000 > 0)\n          resultSignifier =\n            (resultSignifier * 0x10000000000000B17217F7D1CF7D83C1A) >>\n            128;\n        if (xSignifier & 0x8000000000000000000 > 0)\n          resultSignifier =\n            (resultSignifier * 0x1000000000000058B90BFBE8E7BDCBE2E) >>\n            128;\n        if (xSignifier & 0x4000000000000000000 > 0)\n          resultSignifier =\n            (resultSignifier * 0x100000000000002C5C85FDF473DEA871F) >>\n            128;\n        if (xSignifier & 0x2000000000000000000 > 0)\n          resultSignifier =\n            (resultSignifier * 0x10000000000000162E42FEFA39EF44D91) >>\n            128;\n        if (xSignifier & 0x1000000000000000000 > 0)\n          resultSignifier =\n            (resultSignifier * 0x100000000000000B17217F7D1CF79E949) >>\n            128;\n        if (xSignifier & 0x800000000000000000 > 0)\n          resultSignifier =\n            (resultSignifier * 0x10000000000000058B90BFBE8E7BCE544) >>\n            128;\n        if (xSignifier & 0x400000000000000000 > 0)\n          resultSignifier =\n            (resultSignifier * 0x1000000000000002C5C85FDF473DE6ECA) >>\n            128;\n        if (xSignifier & 0x200000000000000000 > 0)\n          resultSignifier =\n            (resultSignifier * 0x100000000000000162E42FEFA39EF366F) >>\n            128;\n        if (xSignifier & 0x100000000000000000 > 0)\n          resultSignifier =\n            (resultSignifier * 0x1000000000000000B17217F7D1CF79AFA) >>\n            128;\n        if (xSignifier & 0x80000000000000000 > 0)\n          resultSignifier =\n            (resultSignifier * 0x100000000000000058B90BFBE8E7BCD6D) >>\n            128;\n        if (xSignifier & 0x40000000000000000 > 0)\n          resultSignifier =\n            (resultSignifier * 0x10000000000000002C5C85FDF473DE6B2) >>\n            128;\n        if (xSignifier & 0x20000000000000000 > 0)\n          resultSignifier =\n            (resultSignifier * 0x1000000000000000162E42FEFA39EF358) >>\n            128;\n        if (xSignifier & 0x10000000000000000 > 0)\n          resultSignifier =\n            (resultSignifier * 0x10000000000000000B17217F7D1CF79AB) >>\n            128;\n        if (xSignifier & 0x8000000000000000 > 0)\n          resultSignifier =\n            (resultSignifier * 0x1000000000000000058B90BFBE8E7BCD5) >>\n            128;\n        if (xSignifier & 0x4000000000000000 > 0)\n          resultSignifier =\n            (resultSignifier * 0x100000000000000002C5C85FDF473DE6A) >>\n            128;\n        if (xSignifier & 0x2000000000000000 > 0)\n          resultSignifier =\n            (resultSignifier * 0x10000000000000000162E42FEFA39EF34) >>\n            128;\n        if (xSignifier & 0x1000000000000000 > 0)\n          resultSignifier =\n            (resultSignifier * 0x100000000000000000B17217F7D1CF799) >>\n            128;\n        if (xSignifier & 0x800000000000000 > 0)\n          resultSignifier =\n            (resultSignifier * 0x10000000000000000058B90BFBE8E7BCC) >>\n            128;\n        if (xSignifier & 0x400000000000000 > 0)\n          resultSignifier =\n            (resultSignifier * 0x1000000000000000002C5C85FDF473DE5) >>\n            128;\n        if (xSignifier & 0x200000000000000 > 0)\n          resultSignifier =\n            (resultSignifier * 0x100000000000000000162E42FEFA39EF2) >>\n            128;\n        if (xSignifier & 0x100000000000000 > 0)\n          resultSignifier =\n            (resultSignifier * 0x1000000000000000000B17217F7D1CF78) >>\n            128;\n        if (xSignifier & 0x80000000000000 > 0)\n          resultSignifier =\n            (resultSignifier * 0x100000000000000000058B90BFBE8E7BB) >>\n            128;\n        if (xSignifier & 0x40000000000000 > 0)\n          resultSignifier =\n            (resultSignifier * 0x10000000000000000002C5C85FDF473DD) >>\n            128;\n        if (xSignifier & 0x20000000000000 > 0)\n          resultSignifier =\n            (resultSignifier * 0x1000000000000000000162E42FEFA39EE) >>\n            128;\n        if (xSignifier & 0x10000000000000 > 0)\n          resultSignifier =\n            (resultSignifier * 0x10000000000000000000B17217F7D1CF6) >>\n            128;\n        if (xSignifier & 0x8000000000000 > 0)\n          resultSignifier =\n            (resultSignifier * 0x1000000000000000000058B90BFBE8E7A) >>\n            128;\n        if (xSignifier & 0x4000000000000 > 0)\n          resultSignifier =\n            (resultSignifier * 0x100000000000000000002C5C85FDF473C) >>\n            128;\n        if (xSignifier & 0x2000000000000 > 0)\n          resultSignifier =\n            (resultSignifier * 0x10000000000000000000162E42FEFA39D) >>\n            128;\n        if (xSignifier & 0x1000000000000 > 0)\n          resultSignifier =\n            (resultSignifier * 0x100000000000000000000B17217F7D1CE) >>\n            128;\n        if (xSignifier & 0x800000000000 > 0)\n          resultSignifier =\n            (resultSignifier * 0x10000000000000000000058B90BFBE8E6) >>\n            128;\n        if (xSignifier & 0x400000000000 > 0)\n          resultSignifier =\n            (resultSignifier * 0x1000000000000000000002C5C85FDF472) >>\n            128;\n        if (xSignifier & 0x200000000000 > 0)\n          resultSignifier =\n            (resultSignifier * 0x100000000000000000000162E42FEFA38) >>\n            128;\n        if (xSignifier & 0x100000000000 > 0)\n          resultSignifier =\n            (resultSignifier * 0x1000000000000000000000B17217F7D1B) >>\n            128;\n        if (xSignifier & 0x80000000000 > 0)\n          resultSignifier =\n            (resultSignifier * 0x100000000000000000000058B90BFBE8D) >>\n            128;\n        if (xSignifier & 0x40000000000 > 0)\n          resultSignifier =\n            (resultSignifier * 0x10000000000000000000002C5C85FDF46) >>\n            128;\n        if (xSignifier & 0x20000000000 > 0)\n          resultSignifier =\n            (resultSignifier * 0x1000000000000000000000162E42FEFA2) >>\n            128;\n        if (xSignifier & 0x10000000000 > 0)\n          resultSignifier =\n            (resultSignifier * 0x10000000000000000000000B17217F7D0) >>\n            128;\n        if (xSignifier & 0x8000000000 > 0)\n          resultSignifier =\n            (resultSignifier * 0x1000000000000000000000058B90BFBE7) >>\n            128;\n        if (xSignifier & 0x4000000000 > 0)\n          resultSignifier =\n            (resultSignifier * 0x100000000000000000000002C5C85FDF3) >>\n            128;\n        if (xSignifier & 0x2000000000 > 0)\n          resultSignifier =\n            (resultSignifier * 0x10000000000000000000000162E42FEF9) >>\n            128;\n        if (xSignifier & 0x1000000000 > 0)\n          resultSignifier =\n            (resultSignifier * 0x100000000000000000000000B17217F7C) >>\n            128;\n        if (xSignifier & 0x800000000 > 0)\n          resultSignifier =\n            (resultSignifier * 0x10000000000000000000000058B90BFBD) >>\n            128;\n        if (xSignifier & 0x400000000 > 0)\n          resultSignifier =\n            (resultSignifier * 0x1000000000000000000000002C5C85FDE) >>\n            128;\n        if (xSignifier & 0x200000000 > 0)\n          resultSignifier =\n            (resultSignifier * 0x100000000000000000000000162E42FEE) >>\n            128;\n        if (xSignifier & 0x100000000 > 0)\n          resultSignifier =\n            (resultSignifier * 0x1000000000000000000000000B17217F6) >>\n            128;\n        if (xSignifier & 0x80000000 > 0)\n          resultSignifier =\n            (resultSignifier * 0x100000000000000000000000058B90BFA) >>\n            128;\n        if (xSignifier & 0x40000000 > 0)\n          resultSignifier =\n            (resultSignifier * 0x10000000000000000000000002C5C85FC) >>\n            128;\n        if (xSignifier & 0x20000000 > 0)\n          resultSignifier =\n            (resultSignifier * 0x1000000000000000000000000162E42FD) >>\n            128;\n        if (xSignifier & 0x10000000 > 0)\n          resultSignifier =\n            (resultSignifier * 0x10000000000000000000000000B17217E) >>\n            128;\n        if (xSignifier & 0x8000000 > 0)\n          resultSignifier =\n            (resultSignifier * 0x1000000000000000000000000058B90BE) >>\n            128;\n        if (xSignifier & 0x4000000 > 0)\n          resultSignifier =\n            (resultSignifier * 0x100000000000000000000000002C5C85E) >>\n            128;\n        if (xSignifier & 0x2000000 > 0)\n          resultSignifier =\n            (resultSignifier * 0x10000000000000000000000000162E42E) >>\n            128;\n        if (xSignifier & 0x1000000 > 0)\n          resultSignifier =\n            (resultSignifier * 0x100000000000000000000000000B17216) >>\n            128;\n        if (xSignifier & 0x800000 > 0)\n          resultSignifier =\n            (resultSignifier * 0x10000000000000000000000000058B90A) >>\n            128;\n        if (xSignifier & 0x400000 > 0)\n          resultSignifier =\n            (resultSignifier * 0x1000000000000000000000000002C5C84) >>\n            128;\n        if (xSignifier & 0x200000 > 0)\n          resultSignifier =\n            (resultSignifier * 0x100000000000000000000000000162E41) >>\n            128;\n        if (xSignifier & 0x100000 > 0)\n          resultSignifier =\n            (resultSignifier * 0x1000000000000000000000000000B1720) >>\n            128;\n        if (xSignifier & 0x80000 > 0)\n          resultSignifier =\n            (resultSignifier * 0x100000000000000000000000000058B8F) >>\n            128;\n        if (xSignifier & 0x40000 > 0)\n          resultSignifier =\n            (resultSignifier * 0x10000000000000000000000000002C5C7) >>\n            128;\n        if (xSignifier & 0x20000 > 0)\n          resultSignifier =\n            (resultSignifier * 0x1000000000000000000000000000162E3) >>\n            128;\n        if (xSignifier & 0x10000 > 0)\n          resultSignifier =\n            (resultSignifier * 0x10000000000000000000000000000B171) >>\n            128;\n        if (xSignifier & 0x8000 > 0)\n          resultSignifier =\n            (resultSignifier * 0x1000000000000000000000000000058B8) >>\n            128;\n        if (xSignifier & 0x4000 > 0)\n          resultSignifier =\n            (resultSignifier * 0x100000000000000000000000000002C5B) >>\n            128;\n        if (xSignifier & 0x2000 > 0)\n          resultSignifier =\n            (resultSignifier * 0x10000000000000000000000000000162D) >>\n            128;\n        if (xSignifier & 0x1000 > 0)\n          resultSignifier =\n            (resultSignifier * 0x100000000000000000000000000000B16) >>\n            128;\n        if (xSignifier & 0x800 > 0)\n          resultSignifier =\n            (resultSignifier * 0x10000000000000000000000000000058A) >>\n            128;\n        if (xSignifier & 0x400 > 0)\n          resultSignifier =\n            (resultSignifier * 0x1000000000000000000000000000002C4) >>\n            128;\n        if (xSignifier & 0x200 > 0)\n          resultSignifier =\n            (resultSignifier * 0x100000000000000000000000000000161) >>\n            128;\n        if (xSignifier & 0x100 > 0)\n          resultSignifier =\n            (resultSignifier * 0x1000000000000000000000000000000B0) >>\n            128;\n        if (xSignifier & 0x80 > 0)\n          resultSignifier =\n            (resultSignifier * 0x100000000000000000000000000000057) >>\n            128;\n        if (xSignifier & 0x40 > 0)\n          resultSignifier =\n            (resultSignifier * 0x10000000000000000000000000000002B) >>\n            128;\n        if (xSignifier & 0x20 > 0)\n          resultSignifier =\n            (resultSignifier * 0x100000000000000000000000000000015) >>\n            128;\n        if (xSignifier & 0x10 > 0)\n          resultSignifier =\n            (resultSignifier * 0x10000000000000000000000000000000A) >>\n            128;\n        if (xSignifier & 0x8 > 0)\n          resultSignifier =\n            (resultSignifier * 0x100000000000000000000000000000004) >>\n            128;\n        if (xSignifier & 0x4 > 0)\n          resultSignifier =\n            (resultSignifier * 0x100000000000000000000000000000001) >>\n            128;\n\n        if (!xNegative) {\n          resultSignifier =\n            (resultSignifier >> 15) &\n            0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\n          resultExponent += 0x3FFF;\n        } else if (resultExponent <= 0x3FFE) {\n          resultSignifier =\n            (resultSignifier >> 15) &\n            0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\n          resultExponent = 0x3FFF - resultExponent;\n        } else {\n          resultSignifier = resultSignifier >> (resultExponent - 16367);\n          resultExponent = 0;\n        }\n\n        return bytes16(uint128((resultExponent << 112) | resultSignifier));\n      }\n    }\n  }\n\n  /**\n   * Calculate e^x.\n   *\n   * @param x quadruple precision number\n   * @return quadruple precision number\n   */\n  function exp(bytes16 x) internal pure returns (bytes16) {\n    unchecked {\n      return pow_2(mul(x, 0x3FFF71547652B82FE1777D0FFDA0D23A));\n    }\n  }\n\n  /**\n   * Get index of the most significant non-zero bit in binary representation of\n   * x.  Reverts if x is zero.\n   *\n   * @return index of the most significant non-zero bit in binary representation\n   *         of x\n   */\n  function mostSignificantBit(uint256 x) private pure returns (uint256) {\n    unchecked {\n      require(x > 0);\n\n      uint256 result = 0;\n\n      if (x >= 0x100000000000000000000000000000000) {\n        x >>= 128;\n        result += 128;\n      }\n      if (x >= 0x10000000000000000) {\n        x >>= 64;\n        result += 64;\n      }\n      if (x >= 0x100000000) {\n        x >>= 32;\n        result += 32;\n      }\n      if (x >= 0x10000) {\n        x >>= 16;\n        result += 16;\n      }\n      if (x >= 0x100) {\n        x >>= 8;\n        result += 8;\n      }\n      if (x >= 0x10) {\n        x >>= 4;\n        result += 4;\n      }\n      if (x >= 0x4) {\n        x >>= 2;\n        result += 2;\n      }\n      if (x >= 0x2) result += 1; // No need to shift x anymore\n\n      return result;\n    }\n  }\n}\n"
    },
    "contracts/test/MockOptionPricing.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.0;\n\nimport { IOptionPricing } from \"../interfaces/IOptionPricing.sol\";\n\ncontract MockOptionPricing is IOptionPricing {\n  function getOptionPrice(\n    bool isPut,\n    uint256 expiry,\n    uint256 strike,\n    uint256 lastPrice,\n    uint256 baseIv\n  ) external pure override returns (uint256) {\n    return 5e8; // 5$\n  }\n}\n"
    },
    "contracts/pricing/OptionPricing.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.0;\n\n// Libraries\nimport {SafeMath} from '@openzeppelin/contracts/utils/math/SafeMath.sol';\nimport {BlackScholes} from '../libraries/BlackScholes.sol';\nimport {ABDKMathQuad} from '../external/libraries/ABDKMathQuad.sol';\n\n// Contracts\nimport {Ownable} from '@openzeppelin/contracts/access/Ownable.sol';\n\ncontract OptionPricing is Ownable {\n    using SafeMath for uint256;\n\n    // strike precision 10^8\n    uint256 public constant strikePrecision = 1e8;\n\n    // The max iv possible\n    uint256 public ivCap;\n\n    // All multipliers will be precision 1e8 (strike precision)\n    struct Multipliers {\n        uint256 callCurveMultiplier;\n        uint256 putCurveMultiplier;\n        uint256 callGrowthMultiplier;\n        uint256 putGrowthMultiplier;\n    }\n\n    // The set of multipliers to be used\n    Multipliers public multipliers;\n\n    constructor(\n        uint256 _ivCap,\n        uint256 _callCurveMultiplier,\n        uint256 _putCurveMultiplier,\n        uint256 _callGrowthMultiplier,\n        uint256 _putGrowthMultiplier\n    ) {\n        // Initialize ivCap\n        ivCap = _ivCap;\n        // Initialize multipliers\n        multipliers.callCurveMultiplier = _callCurveMultiplier;\n        multipliers.putCurveMultiplier = _putCurveMultiplier;\n        multipliers.callGrowthMultiplier = _callGrowthMultiplier;\n        multipliers.putGrowthMultiplier = _putGrowthMultiplier;\n    }\n\n    /*---- GOVERNANCE FUNCTIONS ----*/\n\n    /// @notice updates iv cap for an option pool\n    /// @param _ivCap the new iv cap\n    /// @return whether iv cap was updated\n    function updateIvCap(uint256 _ivCap) external onlyOwner returns (bool) {\n        ivCap = _ivCap;\n\n        return true;\n    }\n\n    /// @notice propose a new quote for multipliers\n    /// @param _callCurveMultiplier call curve multiplier\n    /// @param _putCurveMultiplier put curve multiplier\n    /// @param _callGrowthMultiplier call growth multiplier\n    /// @param _putGrowthMultiplier put growth multiplier\n    /// @return whether the multiplier was updated\n    function updateMultipliers(\n        uint256 _callCurveMultiplier,\n        uint256 _putCurveMultiplier,\n        uint256 _callGrowthMultiplier,\n        uint256 _putGrowthMultiplier\n    ) external onlyOwner returns (bool) {\n        multipliers.callCurveMultiplier = _callCurveMultiplier;\n        multipliers.putCurveMultiplier = _putCurveMultiplier;\n        multipliers.callGrowthMultiplier = _callGrowthMultiplier;\n        multipliers.putGrowthMultiplier = _putGrowthMultiplier;\n\n        return true;\n    }\n\n    /*---- VIEWS ----*/\n\n    /**\n     * @notice computes the option price (with liquidity multiplier)\n     * @param isPut is put option\n     * @param expiry expiry timestamp\n     * @param strike strike price\n     * @param lastPrice current price\n     * @param baseIv baseIv\n     */\n    function getOptionPrice(\n        bool isPut,\n        uint256 expiry,\n        uint256 strike,\n        uint256 lastPrice,\n        uint256 baseIv\n    ) external view returns (uint256) {\n        uint256 iv = getIV(baseIv, strike, lastPrice, expiry, isPut);\n\n        uint256 timeToExpiry = expiry.sub(block.timestamp).div(864);\n\n        return\n            BlackScholes\n                .calculate(\n                    isPut ? 1 : 0, // 0 - Put, 1 - Call\n                    lastPrice,\n                    strike,\n                    timeToExpiry, // Number of days to expiry mul by 100\n                    0,\n                    iv\n                )\n                .div(BlackScholes.DIVISOR);\n    }\n\n    /**\n     * @notice returns the multiplied iv given the strike price\n     * @param baseIv the base iv to be used\n     * @param strike the strike price\n     * @param lastPrice the last price of the base asset\n     * @param expiry the expiry of the option\n     * @param isPut whether the option is put or call option\n     * @return the iv\n     */\n    function getIV(\n        uint256 baseIv,\n        uint256 strike,\n        uint256 lastPrice,\n        uint256 expiry,\n        bool isPut\n    ) public view returns (uint256) {\n        uint256 curveMultiplier;\n        uint256 growthMultiplier;\n\n        if (isPut) {\n            curveMultiplier = multipliers.putCurveMultiplier;\n            growthMultiplier = multipliers.putGrowthMultiplier;\n        } else {\n            curveMultiplier = multipliers.callCurveMultiplier;\n            growthMultiplier = multipliers.callGrowthMultiplier;\n        }\n\n        // percentageDifference is the difference in percentage of the strike price from the current price\n        uint256 percentageDifference;\n\n        if (strike > lastPrice) {\n            percentageDifference = uint256(100).mul(\n                (strike.sub(lastPrice).mul(strikePrecision).div(lastPrice))\n            );\n        } else {\n            percentageDifference = uint256(100).mul(\n                (lastPrice.sub(strike).mul(strikePrecision).div(lastPrice))\n            );\n        }\n\n        percentageDifference = percentageDifference.div(strikePrecision);\n\n        // timeToExpiry in days = timestamp (in sec) / 86400\n        bytes16 timeToExpiry = ABDKMathQuad.div(\n            ABDKMathQuad.fromUInt(expiry.sub(block.timestamp)),\n            ABDKMathQuad.fromUInt(86400) // 86400 = seconds in a day\n        );\n\n        // Calculate the exponent = e ^ (percentageDifference / (curveMultiplier * timeToExpiry))\n        bytes16 exponent = ABDKMathQuad.div(\n            ABDKMathQuad.fromUInt(percentageDifference),\n            ABDKMathQuad.mul(\n                ABDKMathQuad.div(\n                    ABDKMathQuad.fromUInt(curveMultiplier),\n                    ABDKMathQuad.fromUInt(1e8)\n                ),\n                timeToExpiry\n            )\n        );\n\n        // Calculate ivMultiple = 1 + ((Growth Multiplier * exponent) * (percentageDifference) ^ 2)\n        bytes16 ivMultiple = ABDKMathQuad.add(\n            ABDKMathQuad.fromUInt(1),\n            ABDKMathQuad.mul(\n                ABDKMathQuad.mul(\n                    ABDKMathQuad.div(\n                        ABDKMathQuad.fromUInt(growthMultiplier),\n                        ABDKMathQuad.fromUInt(1e8)\n                    ),\n                    ABDKMathQuad.exp(exponent)\n                ),\n                ABDKMathQuad.mul(\n                    ABDKMathQuad.fromUInt(percentageDifference),\n                    ABDKMathQuad.fromUInt(percentageDifference)\n                )\n            )\n        );\n\n        // Final iv is baseIv * ivMultiple\n        uint256 iv = ABDKMathQuad.toUInt(\n            ABDKMathQuad.mul(ABDKMathQuad.fromUInt(baseIv), ivMultiple)\n        );\n\n        if (iv > ivCap) {\n            iv = ivCap;\n        }\n\n        return iv;\n    }\n}\n"
    },
    "contracts/test/MockDPXChainlinkUSDAdapter.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.0;\n\nimport {Ownable} from '@openzeppelin/contracts/access/Ownable.sol';\n\nimport {IOracle} from '../interfaces/IOracle.sol';\n\ncontract MockDPXChainlinkUSDAdapter is IOracle, Ownable {\n    uint256 public price = 100e8;\n\n    function updatePrice(uint256 _price) external onlyOwner returns (bool) {\n        price = _price;\n        return true;\n    }\n\n    function getPriceInUSD() external view override returns (uint256) {\n        return price;\n    }\n\n    function viewPriceInUSD() external view override returns (uint256) {\n        return price;\n    }\n}\n"
    },
    "contracts/oracle/ChainlinkUSDAdapter.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.0;\n\n// Interfaces\nimport {IOracle} from '../interfaces/IOracle.sol';\nimport {IChainlinkV3Aggregator} from '../external/interfaces/IChainlinkV3Aggregator.sol';\n\ncontract ChainlinkUSDAdapter is IOracle {\n    /// @notice the asset with the price oracle\n    address public immutable asset;\n\n    /// @notice chainlink aggregator with price in USD\n    IChainlinkV3Aggregator public immutable aggregator;\n\n    /// @dev the latestAnser returned\n    uint256 private latestAnswer;\n\n    constructor(address _asset, address _aggregator) {\n        require(address(_aggregator) != address(0), 'invalid aggregator');\n\n        asset = _asset;\n        aggregator = IChainlinkV3Aggregator(_aggregator);\n    }\n\n    function adjustDecimal(\n        uint256 balance,\n        uint8 org,\n        uint8 target\n    ) internal pure returns (uint256 adjustedBalance) {\n        adjustedBalance = balance;\n        if (target < org) {\n            adjustedBalance = adjustedBalance / (10**(org - target));\n        } else if (target > org) {\n            adjustedBalance = adjustedBalance * (10**(target - org));\n        }\n    }\n\n    /// @dev returns price of asset in 1e8\n    function getPriceInUSD() external override returns (uint256 price) {\n        (, int256 priceC, , , ) = aggregator.latestRoundData();\n        price = adjustDecimal(uint256(priceC), aggregator.decimals(), 8);\n        latestAnswer = price;\n        emit PriceUpdated(asset, price);\n    }\n\n    /// @dev returns the latest price of asset\n    function viewPriceInUSD() external view override returns (uint256) {\n        return latestAnswer;\n    }\n}\n"
    },
    "contracts/external/interfaces/IChainlinkV3Aggregator.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.0;\n\ninterface IChainlinkV3Aggregator {\n  function decimals() external view returns (uint8);\n\n  function latestRoundData()\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n}\n"
    },
    "contracts/oracle/VolatilityOracle.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.0;\n\n// Contracts\nimport {Ownable} from '@openzeppelin/contracts/access/Ownable.sol';\n\n// Interfaces\nimport {IVolatilityOracle} from '../interfaces/IVolatilityOracle.sol';\n\ncontract VolatilityOracle is Ownable, IVolatilityOracle {\n    /*==== PUBLIC VARS ====*/\n\n    uint256 public lastVolatility;\n\n    /*==== SETTER FUNCTIONS (ONLY OWNER) ====*/\n\n    /**\n     * @notice Updates the last volatility for DPX\n     * @param v volatility\n     * @return volatility of dpx\n     */\n    function updateVolatility(uint256 v) external onlyOwner returns (uint256) {\n        require(v != 0, 'VolatilityOracle: Volatility cannot be 0');\n\n        lastVolatility = v;\n\n        return v;\n    }\n\n    /*==== VIEWS ====*/\n\n    /**\n     * @notice Gets the iv of dpx\n     * @return iv\n     */\n    function getVolatility() external view override returns (uint256 iv) {\n        require(lastVolatility != 0, 'VolatilityOracle: Last volatility == 0');\n\n        return lastVolatility;\n    }\n}\n"
    },
    "contracts/test/MockVolatilityOracle.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.0;\n\nimport {IVolatilityOracle} from '../interfaces/IVolatilityOracle.sol';\n\ncontract MockVolatilityOracle is IVolatilityOracle {\n    /**\n     * @notice Gets the iv of dpx\n     * @return iv\n     */\n    function getVolatility() public pure override returns (uint256) {\n        return 100;\n    }\n}\n"
    },
    "contracts/external/oracle/UniswapV2Oracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"../libraries/PRBMathSD59x18.sol\";\nimport \"../../interfaces/IPriceOracleAggregator.sol\";\n\ninterface IUniswapV2Pair {\n  function token0() external view returns (address);\n\n  function token1() external view returns (address);\n\n  function decimals() external pure returns (uint8);\n\n  function price0CumulativeLast() external view returns (uint256);\n\n  function price1CumulativeLast() external view returns (uint256);\n\n  function getReserves()\n    external\n    view\n    returns (\n      uint112 reserve0,\n      uint112 reserve1,\n      uint32 blockTimestampLast\n    );\n\n  function totalSupply() external view returns (uint256);\n}\n\nlibrary UniswapV2Library {\n  // returns sorted token addresses, used to handle return values from pairs sorted in this order\n  function sortTokens(address tokenA, address tokenB)\n    internal\n    pure\n    returns (address token0, address token1)\n  {\n    require(tokenA != tokenB, \"UniswapV2Library: IDENTICAL_ADDRESSES\");\n    (token0, token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\n    require(token0 != address(0), \"UniswapV2Library: ZERO_ADDRESS\");\n  }\n\n  // calculates the CREATE2 address for a pair without making any external calls\n  function pairFor(\n    address factory,\n    address tokenA,\n    address tokenB\n  ) internal pure returns (address pair) {\n    (address token0, address token1) = sortTokens(tokenA, tokenB);\n    pair = address(\n      uint160(\n        uint256(\n          keccak256(\n            abi.encodePacked(\n              hex\"ff\",\n              factory,\n              keccak256(abi.encodePacked(token0, token1)),\n              hex\"96e8ac4277198ff8b6f785478aa9a39f403cb768dd02cbee326c3e7da348845f\" // init code hash\n            )\n          )\n        )\n      )\n    );\n  }\n}\n\nlibrary UniswapV2OracleLibrary {\n  // helper function that returns the current block timestamp within the range of uint32, i.e. [0, 2**32 - 1]\n  function currentBlockTimestamp() internal view returns (uint32) {\n    return uint32(block.timestamp % 2**32);\n  }\n\n  // produces the cumulative price using counterfactuals to save gas and avoid a call to sync.\n  function currentCumulativePrices(address pair)\n    internal\n    view\n    returns (\n      uint256 price0Cumulative,\n      uint256 price1Cumulative,\n      uint32 blockTimestamp\n    )\n  {\n    blockTimestamp = currentBlockTimestamp();\n    price0Cumulative = IUniswapV2Pair(pair).price0CumulativeLast();\n    price1Cumulative = IUniswapV2Pair(pair).price1CumulativeLast();\n\n    // if time has elapsed since the last update on the pair, mock the accumulated price values\n    (\n      uint112 reserve0,\n      uint112 reserve1,\n      uint32 blockTimestampLast\n    ) = IUniswapV2Pair(pair).getReserves();\n    if (blockTimestampLast != blockTimestamp) {\n      // subtraction overflow is desired\n      uint32 timeElapsed = blockTimestamp - blockTimestampLast;\n      // addition overflow is desired\n\n      // counterfactual\n      // price0Cumulative += uint(FixedPoint.fraction(reserve1, reserve0)._x) * timeElapsed;\n      int256 ratio0 = PRBMathSD59x18.div(\n        int256(uint256(reserve1)),\n        int256(uint256(reserve0))\n      );\n      price0Cumulative += uint256(ratio0) * uint256(timeElapsed);\n\n      // counterfactual\n      // price1Cumulative += uint(FixedPoint.fraction(reserve0, reserve1)._x) * timeElapsed;\n      int256 ratio1 = PRBMathSD59x18.div(\n        int256(uint256(reserve0)),\n        int256(uint256(reserve1))\n      );\n      price1Cumulative += uint256(ratio1) * uint256(timeElapsed);\n    }\n  }\n}\n\ncontract UniswapV2Oracle is IOracle {\n  /// @notice oracle that returns price in USD\n  IPriceOracleAggregator public immutable aggregator;\n\n  /// @dev the latestAnser returned\n  uint256 private latestAnswer;\n\n  uint256 public constant PERIOD = 24 hours;\n\n  IUniswapV2Pair public immutable pair;\n  bool public isFirstToken;\n  address public immutable token0;\n  address public immutable token1;\n\n  uint256 public price0CumulativeLast;\n  uint256 public price1CumulativeLast;\n  uint32 public blockTimestampLast;\n\n  uint256 public price0Average;\n  uint256 public price1Average;\n\n  constructor(\n    address _factory,\n    address _tokenA,\n    address _tokenB,\n    address _priceOracleAggregator\n  ) {\n    require(_priceOracleAggregator != address(0), \"UNIV2: Invalid Aggregator\");\n    require(_factory != address(0), \"UNIV2: Invalid factory\");\n    require(_tokenA != address(0), \"UNIV2: Invalid tokenA\");\n    require(_tokenB != address(0), \"UNIV2: Invalid tokenB\");\n\n    aggregator = IPriceOracleAggregator(_priceOracleAggregator);\n\n    IUniswapV2Pair _pair = IUniswapV2Pair(\n      UniswapV2Library.pairFor(_factory, _tokenA, _tokenB)\n    );\n    require(address(_pair) != address(0), \"UNIV2: Invalid Pair\");\n\n    pair = _pair;\n    token0 = _pair.token0();\n    token1 = _pair.token1();\n\n    price0CumulativeLast = _pair.price0CumulativeLast(); // fetch the current accumulated price value (1 / 0)\n    price1CumulativeLast = _pair.price1CumulativeLast(); // fetch the current accumulated price value (0 / 1)\n    uint112 reserve0;\n    uint112 reserve1;\n    (reserve0, reserve1, blockTimestampLast) = _pair.getReserves();\n    require(reserve0 != 0 && reserve1 != 0, \"UNIV2: NO_RESERVES\"); // ensure that there's liquidity in the pair\n\n    if (_tokenA == _pair.token0()) {\n      isFirstToken = true;\n    } else {\n      isFirstToken = false;\n    }\n  }\n\n  function update() public {\n    (\n      uint256 price0Cumulative,\n      uint256 price1Cumulative,\n      uint32 blockTimestamp\n    ) = UniswapV2OracleLibrary.currentCumulativePrices(address(pair));\n\n    uint32 timeElapsed = blockTimestamp - blockTimestampLast; // overflow is desired\n\n    // ensure that at least one full period has passed since the last update\n    if (timeElapsed >= PERIOD) {\n      // overflow is desired, casting never truncates\n      price0Average = uint256(\n        PRBMathSD59x18.div(\n          int256(price0Cumulative - price0CumulativeLast),\n          int256(uint256(timeElapsed))\n        )\n      );\n      price1Average = uint256(\n        PRBMathSD59x18.div(\n          int256(price1Cumulative - price1CumulativeLast),\n          int256(uint256(timeElapsed))\n        )\n      );\n\n      price0CumulativeLast = price0Cumulative;\n      price1CumulativeLast = price1Cumulative;\n      blockTimestampLast = blockTimestamp;\n    }\n  }\n\n  /// @dev returns price of asset in 1e8 of USD\n  function getPriceInUSD() external override returns (uint256 price) {\n    update();\n\n    if (isFirstToken) {\n      price =\n        (price0Average * aggregator.getPriceInUSD(token1)) /\n        (10**(pair.decimals() + 18));\n    } else {\n      price =\n        (price1Average * aggregator.getPriceInUSD(token0)) /\n        (10**(pair.decimals() + 18));\n    }\n    latestAnswer = price;\n\n    emit PriceUpdated(isFirstToken ? token0 : token1, price);\n  }\n\n  /// @dev returns the latest price of asset\n  function viewPriceInUSD() external view override returns (uint256) {\n    return latestAnswer;\n  }\n}\n"
    },
    "contracts/external/libraries/PRBMathSD59x18.sol": {
      "content": "// SPDX-License-Identifier: WTFPL\npragma solidity ^0.8.0;\n\nimport \"./PRBMath.sol\";\n\n/// @title PRBMathSD59x18\n/// @author Paul Razvan Berg\n/// @notice Smart contract library for advanced fixed-point math that works with int256 numbers considered to have 18\n/// trailing decimals. We call this number representation signed 59.18-decimal fixed-point, since the numbers can have\n/// a sign and there can be up to 59 digits in the integer part and up to 18 decimals in the fractional part. The numbers\n/// are bound by the minimum and the maximum values permitted by the Solidity type int256.\nlibrary PRBMathSD59x18 {\n    /// @dev log2(e) as a signed 59.18-decimal fixed-point number.\n    int256 internal constant LOG2_E = 1442695040888963407;\n\n    /// @dev Half the SCALE number.\n    int256 internal constant HALF_SCALE = 5e17;\n\n    /// @dev The maximum value a signed 59.18-decimal fixed-point number can have.\n    int256 internal constant MAX_SD59x18 =\n        57896044618658097711785492504343953926634992332820282019728792003956564819967;\n\n    /// @dev The maximum whole value a signed 59.18-decimal fixed-point number can have.\n    int256 internal constant MAX_WHOLE_SD59x18 =\n        57896044618658097711785492504343953926634992332820282019728000000000000000000;\n\n    /// @dev The minimum value a signed 59.18-decimal fixed-point number can have.\n    int256 internal constant MIN_SD59x18 =\n        -57896044618658097711785492504343953926634992332820282019728792003956564819968;\n\n    /// @dev The minimum whole value a signed 59.18-decimal fixed-point number can have.\n    int256 internal constant MIN_WHOLE_SD59x18 =\n        -57896044618658097711785492504343953926634992332820282019728000000000000000000;\n\n    /// @dev How many trailing decimals can be represented.\n    int256 internal constant SCALE = 1e18;\n\n    /// INTERNAL FUNCTIONS ///\n\n    /// @notice Calculate the absolute value of x.\n    ///\n    /// @dev Requirements:\n    /// - x must be greater than MIN_SD59x18.\n    ///\n    /// @param x The number to calculate the absolute value for.\n    /// @param result The absolute value of x.\n    function abs(int256 x) internal pure returns (int256 result) {\n        unchecked {\n            require(x > MIN_SD59x18);\n            result = x < 0 ? -x : x;\n        }\n    }\n\n    /// @notice Calculates arithmetic average of x and y, rounding down.\n    /// @param x The first operand as a signed 59.18-decimal fixed-point number.\n    /// @param y The second operand as a signed 59.18-decimal fixed-point number.\n    /// @return result The arithmetic average as a signed 59.18-decimal fixed-point number.\n    function avg(int256 x, int256 y) internal pure returns (int256 result) {\n        // The operations can never overflow.\n        unchecked {\n            // The last operand checks if both x and y are odd and if that is the case, we add 1 to the result. We need\n            // to do this because if both numbers are odd, the 0.5 remainder gets truncated twice.\n            result = (x >> 1) + (y >> 1) + (x & y & 1);\n        }\n    }\n\n    /// @notice Yields the least greatest signed 59.18 decimal fixed-point number greater than or equal to x.\n    ///\n    /// @dev Optimised for fractional value inputs, because for every whole value there are (1e18 - 1) fractional counterparts.\n    /// See https://en.wikipedia.org/wiki/Floor_and_ceiling_functions.\n    ///\n    /// Requirements:\n    /// - x must be less than or equal to MAX_WHOLE_SD59x18.\n    ///\n    /// @param x The signed 59.18-decimal fixed-point number to ceil.\n    /// @param result The least integer greater than or equal to x, as a signed 58.18-decimal fixed-point number.\n    function ceil(int256 x) internal pure returns (int256 result) {\n        require(x <= MAX_WHOLE_SD59x18);\n        unchecked {\n            int256 remainder = x % SCALE;\n            if (remainder == 0) {\n                result = x;\n            } else {\n                // Solidity uses C fmod style, which returns a modulus with the same sign as x.\n                result = x - remainder;\n                if (x > 0) {\n                    result += SCALE;\n                }\n            }\n        }\n    }\n\n    /// @notice Divides two signed 59.18-decimal fixed-point numbers, returning a new signed 59.18-decimal fixed-point number.\n    ///\n    /// @dev Variant of \"mulDiv\" that works with signed numbers. Works by computing the signs and the absolute values separately.\n    ///\n    /// Requirements:\n    /// - All from \"PRBMath.mulDiv\".\n    /// - None of the inputs can be type(int256).min.\n    /// - y cannot be zero.\n    /// - The result must fit within int256.\n    ///\n    /// Caveats:\n    /// - All from \"PRBMath.mulDiv\".\n    ///\n    /// @param x The numerator as a signed 59.18-decimal fixed-point number.\n    /// @param y The denominator as a signed 59.18-decimal fixed-point number.\n    /// @param result The quotient as a signed 59.18-decimal fixed-point number.\n    function div(int256 x, int256 y) internal pure returns (int256 result) {\n        require(x > type(int256).min);\n        require(y > type(int256).min);\n\n        // Get hold of the absolute values of x and y.\n        uint256 ax;\n        uint256 ay;\n        unchecked {\n            ax = x < 0 ? uint256(-x) : uint256(x);\n            ay = y < 0 ? uint256(-y) : uint256(y);\n        }\n\n        // Compute the absolute value of (x*SCALE)y. The result must fit within int256.\n        uint256 rUnsigned = PRBMath.mulDiv(ax, uint256(SCALE), ay);\n        require(rUnsigned <= uint256(type(int256).max));\n\n        // Get the signs of x and y.\n        uint256 sx;\n        uint256 sy;\n        assembly {\n            sx := sgt(x, sub(0, 1))\n            sy := sgt(y, sub(0, 1))\n        }\n\n        // XOR over sx and sy. This is basically checking whether the inputs have the same sign. If yes, the result\n        // should be positive. Otherwise, it should be negative.\n        result = sx ^ sy == 1 ? -int256(rUnsigned) : int256(rUnsigned);\n    }\n\n    /// @notice Returns Euler's number as a signed 59.18-decimal fixed-point number.\n    /// @dev See https://en.wikipedia.org/wiki/E_(mathematical_constant).\n    function e() internal pure returns (int256 result) {\n        result = 2718281828459045235;\n    }\n\n    /// @notice Calculates the natural exponent of x.\n    ///\n    /// @dev Based on the insight that e^x = 2^(x * log2(e)).\n    ///\n    /// Requirements:\n    /// - All from \"log2\".\n    /// - x must be less than 133.084258667509499441.\n    ///\n    /// Caveats:\n    /// - All from \"exp2\".\n    /// - For any x less than -41.446531673892822322, the result is zero.\n    ///\n    /// @param x The exponent as a signed 59.18-decimal fixed-point number.\n    /// @return result The result as a signed 59.18-decimal fixed-point number.\n    function exp(int256 x) internal pure returns (int256 result) {\n        // Without this check, the value passed to \"exp2\" would be less than -59.794705707972522261.\n        if (x < -41446531673892822322) {\n            return 0;\n        }\n\n        // Without this check, the value passed to \"exp2\" would be greater than 192.\n        require(x < 133084258667509499441);\n\n        // Do the fixed-point multiplication inline to save gas.\n        unchecked {\n            int256 doubleScaleProduct = x * LOG2_E;\n            result = exp2((doubleScaleProduct + HALF_SCALE) / SCALE);\n        }\n    }\n\n    /// @notice Calculates the binary exponent of x using the binary fraction method.\n    ///\n    /// @dev See https://ethereum.stackexchange.com/q/79903/24693.\n    ///\n    /// Requirements:\n    /// - x must be 192 or less.\n    /// - The result must fit within MAX_SD59x18.\n    ///\n    /// Caveats:\n    /// - For any x less than -59.794705707972522261, the result is zero.\n    ///\n    /// @param x The exponent as a signed 59.18-decimal fixed-point number.\n    /// @return result The result as a signed 59.18-decimal fixed-point number.\n    function exp2(int256 x) internal pure returns (int256 result) {\n        // This works because 2^(-x) = 1/2^x.\n        if (x < 0) {\n            // 2^59.794705707972522262 is the maximum number whose inverse does not truncate down to zero.\n            if (x < -59794705707972522261) {\n                return 0;\n            }\n\n            // Do the fixed-point inversion inline to save gas. The numerator is SCALE * SCALE.\n            unchecked {\n                result = 1e36 / exp2(-x);\n            }\n        } else {\n            // 2^192 doesn't fit within the 192.64-bit fixed-point representation.\n            require(x < 192e18);\n\n            unchecked {\n                // Convert x to the 192.64-bit fixed-point format.\n                uint256 x192x64 = (uint256(x) << 64) / uint256(SCALE);\n\n                // Safe to convert the result to int256 directly because the maximum input allowed is 192.\n                result = int256(PRBMath.exp2(x192x64));\n            }\n        }\n    }\n\n    /// @notice Yields the greatest signed 59.18 decimal fixed-point number less than or equal to x.\n    ///\n    /// @dev Optimised for fractional value inputs, because for every whole value there are (1e18 - 1) fractional counterparts.\n    /// See https://en.wikipedia.org/wiki/Floor_and_ceiling_functions.\n    ///\n    /// Requirements:\n    /// - x must be greater than or equal to MIN_WHOLE_SD59x18.\n    ///\n    /// @param x The signed 59.18-decimal fixed-point number to floor.\n    /// @param result The greatest integer less than or equal to x, as a signed 58.18-decimal fixed-point number.\n    function floor(int256 x) internal pure returns (int256 result) {\n        require(x >= MIN_WHOLE_SD59x18);\n        unchecked {\n            int256 remainder = x % SCALE;\n            if (remainder == 0) {\n                result = x;\n            } else {\n                // Solidity uses C fmod style, which returns a modulus with the same sign as x.\n                result = x - remainder;\n                if (x < 0) {\n                    result -= SCALE;\n                }\n            }\n        }\n    }\n\n    /// @notice Yields the excess beyond the floor of x for positive numbers and the part of the number to the right\n    /// of the radix point for negative numbers.\n    /// @dev Based on the odd function definition. https://en.wikipedia.org/wiki/Fractional_part\n    /// @param x The signed 59.18-decimal fixed-point number to get the fractional part of.\n    /// @param result The fractional part of x as a signed 59.18-decimal fixed-point number.\n    function frac(int256 x) internal pure returns (int256 result) {\n        unchecked {\n            result = x % SCALE;\n        }\n    }\n\n    /// @notice Converts a number from basic integer form to signed 59.18-decimal fixed-point representation.\n    ///\n    /// @dev Requirements:\n    /// - x must be greater than or equal to MIN_SD59x18 divided by SCALE.\n    /// - x must be less than or equal to MAX_SD59x18 divided by SCALE.\n    ///\n    /// @param x The basic integer to convert.\n    /// @param result The same number in signed 59.18-decimal fixed-point representation.\n    function fromInt(int256 x) internal pure returns (int256 result) {\n        unchecked {\n            require(x >= MIN_SD59x18 / SCALE && x <= MAX_SD59x18 / SCALE);\n            result = x * SCALE;\n        }\n    }\n\n    /// @notice Calculates geometric mean of x and y, i.e. sqrt(x * y), rounding down.\n    ///\n    /// @dev Requirements:\n    /// - x * y must fit within MAX_SD59x18, lest it overflows.\n    /// - x * y cannot be negative.\n    ///\n    /// @param x The first operand as a signed 59.18-decimal fixed-point number.\n    /// @param y The second operand as a signed 59.18-decimal fixed-point number.\n    /// @return result The result as a signed 59.18-decimal fixed-point number.\n    function gm(int256 x, int256 y) internal pure returns (int256 result) {\n        if (x == 0) {\n            return 0;\n        }\n\n        unchecked {\n            // Checking for overflow this way is faster than letting Solidity do it.\n            int256 xy = x * y;\n            require(xy / x == y);\n\n            // The product cannot be negative.\n            require(xy >= 0);\n\n            // We don't need to multiply by the SCALE here because the x*y product had already picked up a factor of SCALE\n            // during multiplication. See the comments within the \"sqrt\" function.\n            result = int256(PRBMath.sqrt(uint256(xy)));\n        }\n    }\n\n    /// @notice Calculates 1 / x, rounding towards zero.\n    ///\n    /// @dev Requirements:\n    /// - x cannot be zero.\n    ///\n    /// @param x The signed 59.18-decimal fixed-point number for which to calculate the inverse.\n    /// @return result The inverse as a signed 59.18-decimal fixed-point number.\n    function inv(int256 x) internal pure returns (int256 result) {\n        unchecked {\n            // 1e36 is SCALE * SCALE.\n            result = 1e36 / x;\n        }\n    }\n\n    /// @notice Calculates the natural logarithm of x.\n    ///\n    /// @dev Based on the insight that ln(x) = log2(x) / log2(e).\n    ///\n    /// Requirements:\n    /// - All from \"log2\".\n    ///\n    /// Caveats:\n    /// - All from \"log2\".\n    /// - This doesn't return exactly 1 for 2718281828459045235, for that we would need more fine-grained precision.\n    ///\n    /// @param x The signed 59.18-decimal fixed-point number for which to calculate the natural logarithm.\n    /// @return result The natural logarithm as a signed 59.18-decimal fixed-point number.\n    function ln(int256 x) internal pure returns (int256 result) {\n        // Do the fixed-point multiplication inline to save gas. This is overflow-safe because the maximum value that log2(x)\n        // can return is 195205294292027477728.\n        unchecked {\n            result = (log2(x) * SCALE) / LOG2_E;\n        }\n    }\n\n    /// @notice Calculates the common logarithm of x.\n    ///\n    /// @dev First checks if x is an exact power of ten and it stops if yes. If it's not, calculates the common\n    /// logarithm based on the insight that log10(x) = log2(x) / log2(10).\n    ///\n    /// Requirements:\n    /// - All from \"log2\".\n    ///\n    /// Caveats:\n    /// - All from \"log2\".\n    ///\n    /// @param x The signed 59.18-decimal fixed-point number for which to calculate the common logarithm.\n    /// @return result The common logarithm as a signed 59.18-decimal fixed-point number.\n    function log10(int256 x) internal pure returns (int256 result) {\n        require(x > 0);\n\n        // Note that the \"mul\" in this block is the assembly mul operation, not the \"mul\" function defined in this contract.\n        // prettier-ignore\n        assembly {\n            switch x\n            case 1 { result := mul(SCALE, sub(0, 18)) }\n            case 10 { result := mul(SCALE, sub(1, 18)) }\n            case 100 { result := mul(SCALE, sub(2, 18)) }\n            case 1000 { result := mul(SCALE, sub(3, 18)) }\n            case 10000 { result := mul(SCALE, sub(4, 18)) }\n            case 100000 { result := mul(SCALE, sub(5, 18)) }\n            case 1000000 { result := mul(SCALE, sub(6, 18)) }\n            case 10000000 { result := mul(SCALE, sub(7, 18)) }\n            case 100000000 { result := mul(SCALE, sub(8, 18)) }\n            case 1000000000 { result := mul(SCALE, sub(9, 18)) }\n            case 10000000000 { result := mul(SCALE, sub(10, 18)) }\n            case 100000000000 { result := mul(SCALE, sub(11, 18)) }\n            case 1000000000000 { result := mul(SCALE, sub(12, 18)) }\n            case 10000000000000 { result := mul(SCALE, sub(13, 18)) }\n            case 100000000000000 { result := mul(SCALE, sub(14, 18)) }\n            case 1000000000000000 { result := mul(SCALE, sub(15, 18)) }\n            case 10000000000000000 { result := mul(SCALE, sub(16, 18)) }\n            case 100000000000000000 { result := mul(SCALE, sub(17, 18)) }\n            case 1000000000000000000 { result := 0 }\n            case 10000000000000000000 { result := SCALE }\n            case 100000000000000000000 { result := mul(SCALE, 2) }\n            case 1000000000000000000000 { result := mul(SCALE, 3) }\n            case 10000000000000000000000 { result := mul(SCALE, 4) }\n            case 100000000000000000000000 { result := mul(SCALE, 5) }\n            case 1000000000000000000000000 { result := mul(SCALE, 6) }\n            case 10000000000000000000000000 { result := mul(SCALE, 7) }\n            case 100000000000000000000000000 { result := mul(SCALE, 8) }\n            case 1000000000000000000000000000 { result := mul(SCALE, 9) }\n            case 10000000000000000000000000000 { result := mul(SCALE, 10) }\n            case 100000000000000000000000000000 { result := mul(SCALE, 11) }\n            case 1000000000000000000000000000000 { result := mul(SCALE, 12) }\n            case 10000000000000000000000000000000 { result := mul(SCALE, 13) }\n            case 100000000000000000000000000000000 { result := mul(SCALE, 14) }\n            case 1000000000000000000000000000000000 { result := mul(SCALE, 15) }\n            case 10000000000000000000000000000000000 { result := mul(SCALE, 16) }\n            case 100000000000000000000000000000000000 { result := mul(SCALE, 17) }\n            case 1000000000000000000000000000000000000 { result := mul(SCALE, 18) }\n            case 10000000000000000000000000000000000000 { result := mul(SCALE, 19) }\n            case 100000000000000000000000000000000000000 { result := mul(SCALE, 20) }\n            case 1000000000000000000000000000000000000000 { result := mul(SCALE, 21) }\n            case 10000000000000000000000000000000000000000 { result := mul(SCALE, 22) }\n            case 100000000000000000000000000000000000000000 { result := mul(SCALE, 23) }\n            case 1000000000000000000000000000000000000000000 { result := mul(SCALE, 24) }\n            case 10000000000000000000000000000000000000000000 { result := mul(SCALE, 25) }\n            case 100000000000000000000000000000000000000000000 { result := mul(SCALE, 26) }\n            case 1000000000000000000000000000000000000000000000 { result := mul(SCALE, 27) }\n            case 10000000000000000000000000000000000000000000000 { result := mul(SCALE, 28) }\n            case 100000000000000000000000000000000000000000000000 { result := mul(SCALE, 29) }\n            case 1000000000000000000000000000000000000000000000000 { result := mul(SCALE, 30) }\n            case 10000000000000000000000000000000000000000000000000 { result := mul(SCALE, 31) }\n            case 100000000000000000000000000000000000000000000000000 { result := mul(SCALE, 32) }\n            case 1000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 33) }\n            case 10000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 34) }\n            case 100000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 35) }\n            case 1000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 36) }\n            case 10000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 37) }\n            case 100000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 38) }\n            case 1000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 39) }\n            case 10000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 40) }\n            case 100000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 41) }\n            case 1000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 42) }\n            case 10000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 43) }\n            case 100000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 44) }\n            case 1000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 45) }\n            case 10000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 46) }\n            case 100000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 47) }\n            case 1000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 48) }\n            case 10000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 49) }\n            case 100000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 50) }\n            case 1000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 51) }\n            case 10000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 52) }\n            case 100000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 53) }\n            case 1000000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 54) }\n            case 10000000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 55) }\n            case 100000000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 56) }\n            case 1000000000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 57) }\n            case 10000000000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 58) }\n            default {\n                result := MAX_SD59x18\n            }\n        }\n\n        if (result == MAX_SD59x18) {\n            // Do the fixed-point division inline to save gas. The denominator is log2(10).\n            unchecked {\n                result = (log2(x) * SCALE) / 3321928094887362347;\n            }\n        }\n    }\n\n    /// @notice Calculates the binary logarithm of x.\n    ///\n    /// @dev Based on the iterative approximation algorithm.\n    /// https://en.wikipedia.org/wiki/Binary_logarithm#Iterative_approximation\n    ///\n    /// Requirements:\n    /// - x must be greater than zero.\n    ///\n    /// Caveats:\n    /// - The results are not perfectly accurate to the last decimal, due to the lossy precision of the iterative approximation.\n    ///\n    /// @param x The signed 59.18-decimal fixed-point number for which to calculate the binary logarithm.\n    /// @return result The binary logarithm as a signed 59.18-decimal fixed-point number.\n    function log2(int256 x) internal pure returns (int256 result) {\n        require(x > 0);\n        unchecked {\n            // This works because log2(x) = -log2(1/x).\n            int256 sign;\n            if (x >= SCALE) {\n                sign = 1;\n            } else {\n                sign = -1;\n                // Do the fixed-point inversion inline to save gas. The numerator is SCALE * SCALE.\n                assembly {\n                    x := div(1000000000000000000000000000000000000, x)\n                }\n            }\n\n            // Calculate the integer part of the logarithm and add it to the result and finally calculate y = x * 2^(-n).\n            uint256 n = PRBMath.mostSignificantBit(uint256(x / SCALE));\n\n            // The integer part of the logarithm as a signed 59.18-decimal fixed-point number. The operation can't overflow\n            // because n is maximum 255, SCALE is 1e18 and sign is either 1 or -1.\n            result = int256(n) * SCALE;\n\n            // This is y = x * 2^(-n).\n            int256 y = x >> n;\n\n            // If y = 1, the fractional part is zero.\n            if (y == SCALE) {\n                return result * sign;\n            }\n\n            // Calculate the fractional part via the iterative approximation.\n            // The \"delta >>= 1\" part is equivalent to \"delta /= 2\", but shifting bits is faster.\n            for (int256 delta = int256(HALF_SCALE); delta > 0; delta >>= 1) {\n                y = (y * y) / SCALE;\n\n                // Is y^2 > 2 and so in the range [2,4)?\n                if (y >= 2 * SCALE) {\n                    // Add the 2^(-m) factor to the logarithm.\n                    result += delta;\n\n                    // Corresponds to z/2 on Wikipedia.\n                    y >>= 1;\n                }\n            }\n            result *= sign;\n        }\n    }\n\n    /// @notice Multiplies two signed 59.18-decimal fixed-point numbers together, returning a new signed 59.18-decimal\n    /// fixed-point number.\n    ///\n    /// @dev Variant of \"mulDiv\" that works with signed numbers and employs constant folding, i.e. the denominator is\n    /// always 1e18.\n    ///\n    /// Requirements:\n    /// - All from \"PRBMath.mulDivFixedPoint\".\n    /// - The result must fit within MAX_SD59x18.\n    ///\n    /// Caveats:\n    /// - The body is purposely left uncommented; see the NatSpec comments in \"PRBMath.mulDiv\" to understand how this works.\n    ///\n    /// @param x The multiplicand as a signed 59.18-decimal fixed-point number.\n    /// @param y The multiplier as a signed 59.18-decimal fixed-point number.\n    /// @return result The result as a signed 59.18-decimal fixed-point number.\n    function mul(int256 x, int256 y) internal pure returns (int256 result) {\n        require(x > MIN_SD59x18);\n        require(y > MIN_SD59x18);\n\n        unchecked {\n            uint256 ax;\n            uint256 ay;\n            ax = x < 0 ? uint256(-x) : uint256(x);\n            ay = y < 0 ? uint256(-y) : uint256(y);\n\n            uint256 rUnsigned = PRBMath.mulDivFixedPoint(ax, ay);\n            require(rUnsigned <= uint256(MAX_SD59x18));\n\n            uint256 sx;\n            uint256 sy;\n            assembly {\n                sx := sgt(x, sub(0, 1))\n                sy := sgt(y, sub(0, 1))\n            }\n            result = sx ^ sy == 1 ? -int256(rUnsigned) : int256(rUnsigned);\n        }\n    }\n\n    /// @notice Returns PI as a signed 59.18-decimal fixed-point number.\n    function pi() internal pure returns (int256 result) {\n        result = 3141592653589793238;\n    }\n\n    /// @notice Raises x to the power of y.\n    ///\n    /// @dev Based on the insight that x^y = 2^(log2(x) * y).\n    ///\n    /// Requirements:\n    /// - All from \"exp2\", \"log2\" and \"mul\".\n    /// - z cannot be zero.\n    ///\n    /// Caveats:\n    /// - All from \"exp2\", \"log2\" and \"mul\".\n    /// - Assumes 0^0 is 1.\n    ///\n    /// @param x Number to raise to given power y, as a signed 59.18-decimal fixed-point number.\n    /// @param y Exponent to raise x to, as a signed 59.18-decimal fixed-point number.\n    /// @return result x raised to power y, as a signed 59.18-decimal fixed-point number.\n    function pow(int256 x, int256 y) internal pure returns (int256 result) {\n        if (x == 0) {\n            result = y == 0 ? SCALE : int256(0);\n        } else {\n            result = exp2(mul(log2(x), y));\n        }\n    }\n\n    /// @notice Raises x (signed 59.18-decimal fixed-point number) to the power of y (basic unsigned integer) using the\n    /// famous algorithm \"exponentiation by squaring\".\n    ///\n    /// @dev See https://en.wikipedia.org/wiki/Exponentiation_by_squaring\n    ///\n    /// Requirements:\n    /// - All from \"abs\" and \"PRBMath.mulDivFixedPoint\".\n    /// - The result must fit within MAX_SD59x18.\n    ///\n    /// Caveats:\n    /// - All from \"PRBMath.mulDivFixedPoint\".\n    /// - Assumes 0^0 is 1.\n    ///\n    /// @param x The base as a signed 59.18-decimal fixed-point number.\n    /// @param y The exponent as an uint256.\n    /// @return result The result as a signed 59.18-decimal fixed-point number.\n    function powu(int256 x, uint256 y) internal pure returns (int256 result) {\n        uint256 xAbs = uint256(abs(x));\n\n        // Calculate the first iteration of the loop in advance.\n        uint256 rAbs = y & 1 > 0 ? xAbs : uint256(SCALE);\n\n        // Equivalent to \"for(y /= 2; y > 0; y /= 2)\" but faster.\n        for (y >>= 1; y > 0; y >>= 1) {\n            xAbs = PRBMath.mulDivFixedPoint(xAbs, xAbs);\n\n            // Equivalent to \"y % 2 == 1\" but faster.\n            if (y & 1 > 0) {\n                rAbs = PRBMath.mulDivFixedPoint(rAbs, xAbs);\n            }\n        }\n\n        // The result must fit within the 59.18-decimal fixed-point representation.\n        require(rAbs <= uint256(MAX_SD59x18));\n\n        // Is the base negative and the exponent an odd number?\n        bool isNegative = x < 0 && y & 1 == 1;\n        result = isNegative ? -int256(rAbs) : int256(rAbs);\n    }\n\n    /// @notice Returns 1 as a signed 59.18-decimal fixed-point number.\n    function scale() internal pure returns (int256 result) {\n        result = SCALE;\n    }\n\n    /// @notice Calculates the square root of x, rounding down.\n    /// @dev Uses the Babylonian method https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method.\n    ///\n    /// Requirements:\n    /// - x cannot be negative.\n    /// - x must be less than MAX_SD59x18 / SCALE.\n    ///\n    /// Caveats:\n    /// - The maximum fixed-point number permitted is 57896044618658097711785492504343953926634.992332820282019729.\n    ///\n    /// @param x The signed 59.18-decimal fixed-point number for which to calculate the square root.\n    /// @return result The result as a signed 59.18-decimal fixed-point .\n    function sqrt(int256 x) internal pure returns (int256 result) {\n        require(x >= 0);\n        require(\n            x < 57896044618658097711785492504343953926634992332820282019729\n        );\n        unchecked {\n            // Multiply x by the SCALE to account for the factor of SCALE that is picked up when multiplying two signed\n            // 59.18-decimal fixed-point numbers together (in this case, those two numbers are both the square root).\n            result = int256(PRBMath.sqrt(uint256(x * SCALE)));\n        }\n    }\n\n    /// @notice Converts a signed 59.18-decimal fixed-point number to basic integer form, rounding down in the process.\n    /// @param x The signed 59.18-decimal fixed-point number to convert.\n    /// @return result The same number in basic integer form.\n    function toInt(int256 x) internal pure returns (int256 result) {\n        unchecked {\n            result = x / SCALE;\n        }\n    }\n}\n"
    },
    "contracts/external/libraries/PRBMath.sol": {
      "content": "// SPDX-License-Identifier: WTFPL\npragma solidity ^0.8.0;\n\n/// @dev Common mathematical functions used in both PRBMathSD59x18 and PRBMathUD60x18. Note that this shared library\n/// does not always assume the signed 59.18-decimal fixed-point or the unsigned 60.18-decimal fixed-point\n// representation. When it does not, it is annotated in the function's NatSpec documentation.\nlibrary PRBMath {\n    /// STRUCTS ///\n\n    struct SD59x18 {\n        int256 value;\n    }\n\n    struct UD60x18 {\n        uint256 value;\n    }\n\n    /// STORAGE ///\n\n    /// @dev How many trailing decimals can be represented.\n    uint256 internal constant SCALE = 1e18;\n\n    /// @dev Largest power of two divisor of SCALE.\n    uint256 internal constant SCALE_LPOTD = 262144;\n\n    /// @dev SCALE inverted mod 2^256.\n    uint256 internal constant SCALE_INVERSE =\n        78156646155174841979727994598816262306175212592076161876661508869554232690281;\n\n    /// @notice Calculates the binary exponent of x using the binary fraction method.\n    /// @dev Has to use 192.64-bit fixed-point numbers.\n    /// See https://ethereum.stackexchange.com/a/96594/24693.\n    /// @param x The exponent as an unsigned 192.64-bit fixed-point number.\n    /// @return result The result as an unsigned 60.18-decimal fixed-point number.\n    function exp2(uint256 x) internal pure returns (uint256 result) {\n        unchecked {\n            // Start from 0.5 in the 192.64-bit fixed-point format.\n            result = 0x800000000000000000000000000000000000000000000000;\n\n            // Multiply the result by root(2, 2^-i) when the bit at position i is 1. None of the intermediary results overflows\n            // because the initial result is 2^191 and all magic factors are less than 2^65.\n            if (x & 0x8000000000000000 > 0) {\n                result = (result * 0x16A09E667F3BCC909) >> 64;\n            }\n            if (x & 0x4000000000000000 > 0) {\n                result = (result * 0x1306FE0A31B7152DF) >> 64;\n            }\n            if (x & 0x2000000000000000 > 0) {\n                result = (result * 0x1172B83C7D517ADCE) >> 64;\n            }\n            if (x & 0x1000000000000000 > 0) {\n                result = (result * 0x10B5586CF9890F62A) >> 64;\n            }\n            if (x & 0x800000000000000 > 0) {\n                result = (result * 0x1059B0D31585743AE) >> 64;\n            }\n            if (x & 0x400000000000000 > 0) {\n                result = (result * 0x102C9A3E778060EE7) >> 64;\n            }\n            if (x & 0x200000000000000 > 0) {\n                result = (result * 0x10163DA9FB33356D8) >> 64;\n            }\n            if (x & 0x100000000000000 > 0) {\n                result = (result * 0x100B1AFA5ABCBED61) >> 64;\n            }\n            if (x & 0x80000000000000 > 0) {\n                result = (result * 0x10058C86DA1C09EA2) >> 64;\n            }\n            if (x & 0x40000000000000 > 0) {\n                result = (result * 0x1002C605E2E8CEC50) >> 64;\n            }\n            if (x & 0x20000000000000 > 0) {\n                result = (result * 0x100162F3904051FA1) >> 64;\n            }\n            if (x & 0x10000000000000 > 0) {\n                result = (result * 0x1000B175EFFDC76BA) >> 64;\n            }\n            if (x & 0x8000000000000 > 0) {\n                result = (result * 0x100058BA01FB9F96D) >> 64;\n            }\n            if (x & 0x4000000000000 > 0) {\n                result = (result * 0x10002C5CC37DA9492) >> 64;\n            }\n            if (x & 0x2000000000000 > 0) {\n                result = (result * 0x1000162E525EE0547) >> 64;\n            }\n            if (x & 0x1000000000000 > 0) {\n                result = (result * 0x10000B17255775C04) >> 64;\n            }\n            if (x & 0x800000000000 > 0) {\n                result = (result * 0x1000058B91B5BC9AE) >> 64;\n            }\n            if (x & 0x400000000000 > 0) {\n                result = (result * 0x100002C5C89D5EC6D) >> 64;\n            }\n            if (x & 0x200000000000 > 0) {\n                result = (result * 0x10000162E43F4F831) >> 64;\n            }\n            if (x & 0x100000000000 > 0) {\n                result = (result * 0x100000B1721BCFC9A) >> 64;\n            }\n            if (x & 0x80000000000 > 0) {\n                result = (result * 0x10000058B90CF1E6E) >> 64;\n            }\n            if (x & 0x40000000000 > 0) {\n                result = (result * 0x1000002C5C863B73F) >> 64;\n            }\n            if (x & 0x20000000000 > 0) {\n                result = (result * 0x100000162E430E5A2) >> 64;\n            }\n            if (x & 0x10000000000 > 0) {\n                result = (result * 0x1000000B172183551) >> 64;\n            }\n            if (x & 0x8000000000 > 0) {\n                result = (result * 0x100000058B90C0B49) >> 64;\n            }\n            if (x & 0x4000000000 > 0) {\n                result = (result * 0x10000002C5C8601CC) >> 64;\n            }\n            if (x & 0x2000000000 > 0) {\n                result = (result * 0x1000000162E42FFF0) >> 64;\n            }\n            if (x & 0x1000000000 > 0) {\n                result = (result * 0x10000000B17217FBB) >> 64;\n            }\n            if (x & 0x800000000 > 0) {\n                result = (result * 0x1000000058B90BFCE) >> 64;\n            }\n            if (x & 0x400000000 > 0) {\n                result = (result * 0x100000002C5C85FE3) >> 64;\n            }\n            if (x & 0x200000000 > 0) {\n                result = (result * 0x10000000162E42FF1) >> 64;\n            }\n            if (x & 0x100000000 > 0) {\n                result = (result * 0x100000000B17217F8) >> 64;\n            }\n            if (x & 0x80000000 > 0) {\n                result = (result * 0x10000000058B90BFC) >> 64;\n            }\n            if (x & 0x40000000 > 0) {\n                result = (result * 0x1000000002C5C85FE) >> 64;\n            }\n            if (x & 0x20000000 > 0) {\n                result = (result * 0x100000000162E42FF) >> 64;\n            }\n            if (x & 0x10000000 > 0) {\n                result = (result * 0x1000000000B17217F) >> 64;\n            }\n            if (x & 0x8000000 > 0) {\n                result = (result * 0x100000000058B90C0) >> 64;\n            }\n            if (x & 0x4000000 > 0) {\n                result = (result * 0x10000000002C5C860) >> 64;\n            }\n            if (x & 0x2000000 > 0) {\n                result = (result * 0x1000000000162E430) >> 64;\n            }\n            if (x & 0x1000000 > 0) {\n                result = (result * 0x10000000000B17218) >> 64;\n            }\n            if (x & 0x800000 > 0) {\n                result = (result * 0x1000000000058B90C) >> 64;\n            }\n            if (x & 0x400000 > 0) {\n                result = (result * 0x100000000002C5C86) >> 64;\n            }\n            if (x & 0x200000 > 0) {\n                result = (result * 0x10000000000162E43) >> 64;\n            }\n            if (x & 0x100000 > 0) {\n                result = (result * 0x100000000000B1721) >> 64;\n            }\n            if (x & 0x80000 > 0) {\n                result = (result * 0x10000000000058B91) >> 64;\n            }\n            if (x & 0x40000 > 0) {\n                result = (result * 0x1000000000002C5C8) >> 64;\n            }\n            if (x & 0x20000 > 0) {\n                result = (result * 0x100000000000162E4) >> 64;\n            }\n            if (x & 0x10000 > 0) {\n                result = (result * 0x1000000000000B172) >> 64;\n            }\n            if (x & 0x8000 > 0) {\n                result = (result * 0x100000000000058B9) >> 64;\n            }\n            if (x & 0x4000 > 0) {\n                result = (result * 0x10000000000002C5D) >> 64;\n            }\n            if (x & 0x2000 > 0) {\n                result = (result * 0x1000000000000162E) >> 64;\n            }\n            if (x & 0x1000 > 0) {\n                result = (result * 0x10000000000000B17) >> 64;\n            }\n            if (x & 0x800 > 0) {\n                result = (result * 0x1000000000000058C) >> 64;\n            }\n            if (x & 0x400 > 0) {\n                result = (result * 0x100000000000002C6) >> 64;\n            }\n            if (x & 0x200 > 0) {\n                result = (result * 0x10000000000000163) >> 64;\n            }\n            if (x & 0x100 > 0) {\n                result = (result * 0x100000000000000B1) >> 64;\n            }\n            if (x & 0x80 > 0) {\n                result = (result * 0x10000000000000059) >> 64;\n            }\n            if (x & 0x40 > 0) {\n                result = (result * 0x1000000000000002C) >> 64;\n            }\n            if (x & 0x20 > 0) {\n                result = (result * 0x10000000000000016) >> 64;\n            }\n            if (x & 0x10 > 0) {\n                result = (result * 0x1000000000000000B) >> 64;\n            }\n            if (x & 0x8 > 0) {\n                result = (result * 0x10000000000000006) >> 64;\n            }\n            if (x & 0x4 > 0) {\n                result = (result * 0x10000000000000003) >> 64;\n            }\n            if (x & 0x2 > 0) {\n                result = (result * 0x10000000000000001) >> 64;\n            }\n            if (x & 0x1 > 0) {\n                result = (result * 0x10000000000000001) >> 64;\n            }\n\n            // We're doing two things at the same time:\n            //\n            //   1. Multiply the result by 2^n + 1, where \"2^n\" is the integer part and the one is added to account for\n            //      the fact that we initially set the result to 0.5. This is accomplished by subtracting from 191\n            //      rather than 192.\n            //   2. Convert the result to the unsigned 60.18-decimal fixed-point format.\n            //\n            // This works because 2^(191-ip) = 2^ip / 2^191, where \"ip\" is the integer part \"2^n\".\n            result *= SCALE;\n            result >>= (191 - (x >> 64));\n        }\n    }\n\n    /// @notice Finds the zero-based index of the first one in the binary representation of x.\n    /// @dev See the note on msb in the \"Find First Set\" Wikipedia article https://en.wikipedia.org/wiki/Find_first_set\n    /// @param x The uint256 number for which to find the index of the most significant bit.\n    /// @return msb The index of the most significant bit as an uint256.\n    function mostSignificantBit(uint256 x) internal pure returns (uint256 msb) {\n        if (x >= 2**128) {\n            x >>= 128;\n            msb += 128;\n        }\n        if (x >= 2**64) {\n            x >>= 64;\n            msb += 64;\n        }\n        if (x >= 2**32) {\n            x >>= 32;\n            msb += 32;\n        }\n        if (x >= 2**16) {\n            x >>= 16;\n            msb += 16;\n        }\n        if (x >= 2**8) {\n            x >>= 8;\n            msb += 8;\n        }\n        if (x >= 2**4) {\n            x >>= 4;\n            msb += 4;\n        }\n        if (x >= 2**2) {\n            x >>= 2;\n            msb += 2;\n        }\n        if (x >= 2**1) {\n            // No need to shift x any more.\n            msb += 1;\n        }\n    }\n\n    /// @notice Calculates floor(x*ydenominator) with full precision.\n    ///\n    /// @dev Credit to Remco Bloemen under MIT license https://xn--2-umb.com/21/muldiv.\n    ///\n    /// Requirements:\n    /// - The denominator cannot be zero.\n    /// - The result must fit within uint256.\n    ///\n    /// Caveats:\n    /// - This function does not work with fixed-point numbers.\n    ///\n    /// @param x The multiplicand as an uint256.\n    /// @param y The multiplier as an uint256.\n    /// @param denominator The divisor as an uint256.\n    /// @return result The result as an uint256.\n    function mulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 denominator\n    ) internal pure returns (uint256 result) {\n        // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n        // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n        // variables such that product = prod1 * 2^256 + prod0.\n        uint256 prod0; // Least significant 256 bits of the product\n        uint256 prod1; // Most significant 256 bits of the product\n        assembly {\n            let mm := mulmod(x, y, not(0))\n            prod0 := mul(x, y)\n            prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n        }\n\n        // Handle non-overflow cases, 256 by 256 division\n        if (prod1 == 0) {\n            require(denominator > 0);\n            assembly {\n                result := div(prod0, denominator)\n            }\n            return result;\n        }\n\n        // Make sure the result is less than 2^256. Also prevents denominator == 0.\n        require(denominator > prod1);\n\n        ///////////////////////////////////////////////\n        // 512 by 256 division.\n        ///////////////////////////////////////////////\n\n        // Make division exact by subtracting the remainder from [prod1 prod0].\n        uint256 remainder;\n        assembly {\n            // Compute remainder using mulmod.\n            remainder := mulmod(x, y, denominator)\n\n            // Subtract 256 bit number from 512 bit number\n            prod1 := sub(prod1, gt(remainder, prod0))\n            prod0 := sub(prod0, remainder)\n        }\n\n        // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\n        // See https://cs.stackexchange.com/q/138556/92363.\n        unchecked {\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\n            uint256 lpotdod = denominator & (~denominator + 1);\n            assembly {\n                // Divide denominator by lpotdod.\n                denominator := div(denominator, lpotdod)\n\n                // Divide [prod1 prod0] by lpotdod.\n                prod0 := div(prod0, lpotdod)\n\n                // Flip lpotdod such that it is 2^256 / lpotdod. If lpotdod is zero, then it becomes one.\n                lpotdod := add(div(sub(0, lpotdod), lpotdod), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * lpotdod;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Now use Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\n            // in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /// @notice Calculates floor(x*y1e18) with full precision.\n    ///\n    /// @dev Variant of \"mulDiv\" with constant folding, i.e. in which the denominator is always 1e18. Before returning the\n    /// final result, we add 1 if (x * y) % SCALE >= HALF_SCALE. Without this, 6.6e-19 would be truncated to 0 instead of\n    /// being rounded to 1e-18.  See \"Listing 6\" and text above it at https://accu.org/index.php/journals/1717.\n    ///\n    /// Requirements:\n    /// - The result must fit within uint256.\n    ///\n    /// Caveats:\n    /// - The body is purposely left uncommented; see the NatSpec comments in \"PRBMath.mulDiv\" to understand how this works.\n    /// - It is assumed that the result can never be type(uint256).max when x and y solve the following two equations:\n    ///     1. x * y = type(uint256).max * SCALE\n    ///     2. (x * y) % SCALE >= SCALE / 2\n    ///\n    /// @param x The multiplicand as an unsigned 60.18-decimal fixed-point number.\n    /// @param y The multiplier as an unsigned 60.18-decimal fixed-point number.\n    /// @return result The result as an unsigned 60.18-decimal fixed-point number.\n    function mulDivFixedPoint(uint256 x, uint256 y)\n        internal\n        pure\n        returns (uint256 result)\n    {\n        uint256 prod0;\n        uint256 prod1;\n        assembly {\n            let mm := mulmod(x, y, not(0))\n            prod0 := mul(x, y)\n            prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n        }\n\n        uint256 remainder;\n        uint256 roundUpUnit;\n        assembly {\n            remainder := mulmod(x, y, SCALE)\n            roundUpUnit := gt(remainder, 499999999999999999)\n        }\n\n        if (prod1 == 0) {\n            unchecked {\n                result = (prod0 / SCALE) + roundUpUnit;\n                return result;\n            }\n        }\n\n        require(SCALE > prod1);\n\n        assembly {\n            result := add(\n                mul(\n                    or(\n                        div(sub(prod0, remainder), SCALE_LPOTD),\n                        mul(\n                            sub(prod1, gt(remainder, prod0)),\n                            add(div(sub(0, SCALE_LPOTD), SCALE_LPOTD), 1)\n                        )\n                    ),\n                    SCALE_INVERSE\n                ),\n                roundUpUnit\n            )\n        }\n    }\n\n    /// @notice Calculates floor(x*ydenominator) with full precision.\n    ///\n    /// @dev An extension of \"mulDiv\" for signed numbers. Works by computing the signs and the absolute values separately.\n    ///\n    /// Requirements:\n    /// - None of the inputs can be type(int256).min.\n    /// - The result must fit within int256.\n    ///\n    /// @param x The multiplicand as an int256.\n    /// @param y The multiplier as an int256.\n    /// @param denominator The divisor as an int256.\n    /// @return result The result as an int256.\n    function mulDivSigned(\n        int256 x,\n        int256 y,\n        int256 denominator\n    ) internal pure returns (int256 result) {\n        require(x > type(int256).min);\n        require(y > type(int256).min);\n        require(denominator > type(int256).min);\n\n        // Get hold of the absolute values of x, y and the denominator.\n        uint256 ax;\n        uint256 ay;\n        uint256 ad;\n        unchecked {\n            ax = x < 0 ? uint256(-x) : uint256(x);\n            ay = y < 0 ? uint256(-y) : uint256(y);\n            ad = denominator < 0 ? uint256(-denominator) : uint256(denominator);\n        }\n\n        // Compute the absolute value of (x*y)denominator. The result must fit within int256.\n        uint256 resultUnsigned = mulDiv(ax, ay, ad);\n        require(resultUnsigned <= uint256(type(int256).max));\n\n        // Get the signs of x, y and the denominator.\n        uint256 sx;\n        uint256 sy;\n        uint256 sd;\n        assembly {\n            sx := sgt(x, sub(0, 1))\n            sy := sgt(y, sub(0, 1))\n            sd := sgt(denominator, sub(0, 1))\n        }\n\n        // XOR over sx, sy and sd. This is checking whether there are one or three negative signs in the inputs.\n        // If yes, the result should be negative.\n        result = sx ^ sy ^ sd == 0\n            ? -int256(resultUnsigned)\n            : int256(resultUnsigned);\n    }\n\n    /// @notice Calculates the square root of x, rounding down.\n    /// @dev Uses the Babylonian method https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method.\n    ///\n    /// Caveats:\n    /// - This function does not work with fixed-point numbers.\n    ///\n    /// @param x The uint256 number for which to calculate the square root.\n    /// @return result The result as an uint256.\n    function sqrt(uint256 x) internal pure returns (uint256 result) {\n        if (x == 0) {\n            return 0;\n        }\n\n        // Set the initial guess to the closest power of two that is higher than x.\n        uint256 xAux = uint256(x);\n        result = 1;\n        if (xAux >= 0x100000000000000000000000000000000) {\n            xAux >>= 128;\n            result <<= 64;\n        }\n        if (xAux >= 0x10000000000000000) {\n            xAux >>= 64;\n            result <<= 32;\n        }\n        if (xAux >= 0x100000000) {\n            xAux >>= 32;\n            result <<= 16;\n        }\n        if (xAux >= 0x10000) {\n            xAux >>= 16;\n            result <<= 8;\n        }\n        if (xAux >= 0x100) {\n            xAux >>= 8;\n            result <<= 4;\n        }\n        if (xAux >= 0x10) {\n            xAux >>= 4;\n            result <<= 2;\n        }\n        if (xAux >= 0x8) {\n            result <<= 1;\n        }\n\n        // The operations can never overflow because the result is max 2^127 when it enters this block.\n        unchecked {\n            result = (result + x / result) >> 1;\n            result = (result + x / result) >> 1;\n            result = (result + x / result) >> 1;\n            result = (result + x / result) >> 1;\n            result = (result + x / result) >> 1;\n            result = (result + x / result) >> 1;\n            result = (result + x / result) >> 1; // Seven iterations should be enough\n            uint256 roundedDownResult = x / result;\n            return result >= roundedDownResult ? roundedDownResult : result;\n        }\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}