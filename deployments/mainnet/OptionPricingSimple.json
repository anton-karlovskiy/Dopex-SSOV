{
  "address": "0x9baDE4013a7601aA1f3e9f1361a4ebE60D91B1B5",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "_volatilityCap",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "_minOptionPricePercentage",
          "type": "uint256"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "constructor"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "previousOwner",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "newOwner",
          "type": "address"
        }
      ],
      "name": "OwnershipTransferred",
      "type": "event"
    },
    {
      "inputs": [
        {
          "internalType": "bool",
          "name": "isPut",
          "type": "bool"
        },
        {
          "internalType": "uint256",
          "name": "expiry",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "strike",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "lastPrice",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "volatility",
          "type": "uint256"
        }
      ],
      "name": "getOptionPrice",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "minOptionPricePercentage",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "owner",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "renounceOwnership",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "newOwner",
          "type": "address"
        }
      ],
      "name": "transferOwnership",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "_minOptionPricePercentage",
          "type": "uint256"
        }
      ],
      "name": "updateMinOptionPricePercentage",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "_volatilityCap",
          "type": "uint256"
        }
      ],
      "name": "updateVolatilityCap",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "volatilityCap",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    }
  ],
  "transactionHash": "0x4440061458cad519032d25515de0bdf950ff5f60b5fb4a4f224ab4b6df1f584b",
  "receipt": {
    "to": null,
    "from": "0xDe485812E28824e542B9c2270B6b8eD9232B7D0b",
    "contractAddress": "0x9baDE4013a7601aA1f3e9f1361a4ebE60D91B1B5",
    "transactionIndex": 23,
    "gasUsed": "2475948",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000020000000000000000000820000000080000000008000000000000400000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000002000000000000000100000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0x46a1fe1b669aeb7fbcc5193706a4f466a88eac66d4bf9588217d4ef386ef24ef",
    "transactionHash": "0x4440061458cad519032d25515de0bdf950ff5f60b5fb4a4f224ab4b6df1f584b",
    "logs": [
      {
        "transactionIndex": 23,
        "blockNumber": 13712230,
        "transactionHash": "0x4440061458cad519032d25515de0bdf950ff5f60b5fb4a4f224ab4b6df1f584b",
        "address": "0x9baDE4013a7601aA1f3e9f1361a4ebE60D91B1B5",
        "topics": [
          "0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0",
          "0x0000000000000000000000000000000000000000000000000000000000000000",
          "0x000000000000000000000000de485812e28824e542b9c2270b6b8ed9232b7d0b"
        ],
        "data": "0x",
        "logIndex": 26,
        "blockHash": "0x46a1fe1b669aeb7fbcc5193706a4f466a88eac66d4bf9588217d4ef386ef24ef"
      }
    ],
    "blockNumber": 13712230,
    "cumulativeGasUsed": "3637359",
    "status": 1,
    "byzantium": true
  },
  "args": [
    "500",
    "50000000"
  ],
  "solcInputHash": "e36b2af622afba709349df547e98e9e8",
  "metadata": "{\"compiler\":{\"version\":\"0.8.9+commit.e5eed63a\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_volatilityCap\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_minOptionPricePercentage\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"isPut\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"expiry\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"strike\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"volatility\",\"type\":\"uint256\"}],\"name\":\"getOptionPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minOptionPricePercentage\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_minOptionPricePercentage\",\"type\":\"uint256\"}],\"name\":\"updateMinOptionPricePercentage\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_volatilityCap\",\"type\":\"uint256\"}],\"name\":\"updateVolatilityCap\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"volatilityCap\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{\"getOptionPrice(bool,uint256,uint256,uint256,uint256)\":{\"params\":{\"expiry\":\"expiry timestamp\",\"isPut\":\"is put option\",\"lastPrice\":\"current price\",\"strike\":\"strike price\",\"volatility\":\"volatility\"}},\"owner()\":{\"details\":\"Returns the address of the current owner.\"},\"renounceOwnership()\":{\"details\":\"Leaves the contract without owner. It will not be possible to call `onlyOwner` functions anymore. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby removing any functionality that is only available to the owner.\"},\"transferOwnership(address)\":{\"details\":\"Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner.\"},\"updateMinOptionPricePercentage(uint256)\":{\"params\":{\"_minOptionPricePercentage\":\"the new %\"},\"returns\":{\"_0\":\"whether % was updated\"}},\"updateVolatilityCap(uint256)\":{\"params\":{\"_volatilityCap\":\"the new volatility cap\"},\"returns\":{\"_0\":\"whether volatility cap was updated\"}}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"getOptionPrice(bool,uint256,uint256,uint256,uint256)\":{\"notice\":\"computes the option price (with liquidity multiplier)\"},\"updateMinOptionPricePercentage(uint256)\":{\"notice\":\"updates % of the price of asset which is the minimum option price possible\"},\"updateVolatilityCap(uint256)\":{\"notice\":\"updates volatility cap for an option pool\"}},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/pricing/OptionPricingSimple.sol\":\"OptionPricingSimple\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[]},\"sources\":{\"@openzeppelin/contracts/access/Ownable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.0 (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\",\"keccak256\":\"0xa1b27b3f44ff825974e5268e8f63ad3b03add5b464880d860fbb8cae043e17f7\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/Context.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.0 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\",\"keccak256\":\"0x7736c187e6f1358c1ea9350a2a21aa8528dec1c2f43b374a9067465a3a51f5d3\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/math/SafeMath.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.0 (utils/math/SafeMath.sol)\\n\\npragma solidity ^0.8.0;\\n\\n// CAUTION\\n// This version of SafeMath should only be used with Solidity 0.8 or later,\\n// because it relies on the compiler's built in overflow checks.\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations.\\n *\\n * NOTE: `SafeMath` is generally not needed starting with Solidity 0.8, since the compiler\\n * now has built in overflow checking.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            uint256 c = a + b;\\n            if (c < a) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b > a) return (false, 0);\\n            return (true, a - b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n            // benefit is lost if 'b' is also tested.\\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n            if (a == 0) return (true, 0);\\n            uint256 c = a * b;\\n            if (c / a != b) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a / b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a % b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a + b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a * b;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a % b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {trySub}.\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        unchecked {\\n            require(b <= a, errorMessage);\\n            return a - b;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        unchecked {\\n            require(b > 0, errorMessage);\\n            return a / b;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting with custom message when dividing by zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryMod}.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        unchecked {\\n            require(b > 0, errorMessage);\\n            return a % b;\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x29c462775f5b4c76dce400f120f3530aa3f81da42c839f975dc2b64784d22434\",\"license\":\"MIT\"},\"contracts/external/libraries/ABDKMathQuad.sol\":{\"content\":\"// SPDX-License-Identifier: BSD-4-Clause\\n/*\\n * ABDK Math Quad Smart Contract Library.  Copyright \\u00a9 2019 by ABDK Consulting.\\n * Author: Mikhail Vladimirov <mikhail.vladimirov@gmail.com>\\n */\\npragma solidity ^0.8.0;\\n\\n/**\\n * Smart contract library of mathematical functions operating with IEEE 754\\n * quadruple-precision binary floating-point numbers (quadruple precision\\n * numbers).  As long as quadruple precision numbers are 16-bytes long, they are\\n * represented by bytes16 type.\\n */\\nlibrary ABDKMathQuad {\\n  /*\\n   * 0.\\n   */\\n  bytes16 private constant POSITIVE_ZERO = 0x00000000000000000000000000000000;\\n\\n  /*\\n   * -0.\\n   */\\n  bytes16 private constant NEGATIVE_ZERO = 0x80000000000000000000000000000000;\\n\\n  /*\\n   * +Infinity.\\n   */\\n  bytes16 private constant POSITIVE_INFINITY =\\n    0x7FFF0000000000000000000000000000;\\n\\n  /*\\n   * -Infinity.\\n   */\\n  bytes16 private constant NEGATIVE_INFINITY =\\n    0xFFFF0000000000000000000000000000;\\n\\n  /*\\n   * Canonical NaN value.\\n   */\\n  bytes16 private constant NaN = 0x7FFF8000000000000000000000000000;\\n\\n  /**\\n   * Convert signed 256-bit integer number into quadruple precision number.\\n   *\\n   * @param x signed 256-bit integer number\\n   * @return quadruple precision number\\n   */\\n  function fromInt(int256 x) internal pure returns (bytes16) {\\n    unchecked {\\n      if (x == 0) return bytes16(0);\\n      else {\\n        // We rely on overflow behavior here\\n        uint256 result = uint256(x > 0 ? x : -x);\\n\\n        uint256 msb = mostSignificantBit(result);\\n        if (msb < 112) result <<= 112 - msb;\\n        else if (msb > 112) result >>= msb - 112;\\n\\n        result =\\n          (result & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF) |\\n          ((16383 + msb) << 112);\\n        if (x < 0) result |= 0x80000000000000000000000000000000;\\n\\n        return bytes16(uint128(result));\\n      }\\n    }\\n  }\\n\\n  /**\\n   * Convert quadruple precision number into signed 256-bit integer number\\n   * rounding towards zero.  Revert on overflow.\\n   *\\n   * @param x quadruple precision number\\n   * @return signed 256-bit integer number\\n   */\\n  function toInt(bytes16 x) internal pure returns (int256) {\\n    unchecked {\\n      uint256 exponent = (uint128(x) >> 112) & 0x7FFF;\\n\\n      require(exponent <= 16638); // Overflow\\n      if (exponent < 16383) return 0; // Underflow\\n\\n      uint256 result = (uint256(uint128(x)) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF) |\\n        0x10000000000000000000000000000;\\n\\n      if (exponent < 16495) result >>= 16495 - exponent;\\n      else if (exponent > 16495) result <<= exponent - 16495;\\n\\n      if (uint128(x) >= 0x80000000000000000000000000000000) {\\n        // Negative\\n        require(\\n          result <=\\n            0x8000000000000000000000000000000000000000000000000000000000000000\\n        );\\n        return -int256(result); // We rely on overflow behavior here\\n      } else {\\n        require(\\n          result <=\\n            0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\\n        );\\n        return int256(result);\\n      }\\n    }\\n  }\\n\\n  /**\\n   * Convert unsigned 256-bit integer number into quadruple precision number.\\n   *\\n   * @param x unsigned 256-bit integer number\\n   * @return quadruple precision number\\n   */\\n  function fromUInt(uint256 x) internal pure returns (bytes16) {\\n    unchecked {\\n      if (x == 0) return bytes16(0);\\n      else {\\n        uint256 result = x;\\n\\n        uint256 msb = mostSignificantBit(result);\\n        if (msb < 112) result <<= 112 - msb;\\n        else if (msb > 112) result >>= msb - 112;\\n\\n        result =\\n          (result & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF) |\\n          ((16383 + msb) << 112);\\n\\n        return bytes16(uint128(result));\\n      }\\n    }\\n  }\\n\\n  /**\\n   * Convert quadruple precision number into unsigned 256-bit integer number\\n   * rounding towards zero.  Revert on underflow.  Note, that negative floating\\n   * point numbers in range (-1.0 .. 0.0) may be converted to unsigned integer\\n   * without error, because they are rounded to zero.\\n   *\\n   * @param x quadruple precision number\\n   * @return unsigned 256-bit integer number\\n   */\\n  function toUInt(bytes16 x) internal pure returns (uint256) {\\n    unchecked {\\n      uint256 exponent = (uint128(x) >> 112) & 0x7FFF;\\n\\n      if (exponent < 16383) return 0; // Underflow\\n\\n      require(uint128(x) < 0x80000000000000000000000000000000); // Negative\\n\\n      require(exponent <= 16638); // Overflow\\n      uint256 result = (uint256(uint128(x)) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF) |\\n        0x10000000000000000000000000000;\\n\\n      if (exponent < 16495) result >>= 16495 - exponent;\\n      else if (exponent > 16495) result <<= exponent - 16495;\\n\\n      return result;\\n    }\\n  }\\n\\n  /**\\n   * Convert signed 128.128 bit fixed point number into quadruple precision\\n   * number.\\n   *\\n   * @param x signed 128.128 bit fixed point number\\n   * @return quadruple precision number\\n   */\\n  function from128x128(int256 x) internal pure returns (bytes16) {\\n    unchecked {\\n      if (x == 0) return bytes16(0);\\n      else {\\n        // We rely on overflow behavior here\\n        uint256 result = uint256(x > 0 ? x : -x);\\n\\n        uint256 msb = mostSignificantBit(result);\\n        if (msb < 112) result <<= 112 - msb;\\n        else if (msb > 112) result >>= msb - 112;\\n\\n        result =\\n          (result & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF) |\\n          ((16255 + msb) << 112);\\n        if (x < 0) result |= 0x80000000000000000000000000000000;\\n\\n        return bytes16(uint128(result));\\n      }\\n    }\\n  }\\n\\n  /**\\n   * Convert quadruple precision number into signed 128.128 bit fixed point\\n   * number.  Revert on overflow.\\n   *\\n   * @param x quadruple precision number\\n   * @return signed 128.128 bit fixed point number\\n   */\\n  function to128x128(bytes16 x) internal pure returns (int256) {\\n    unchecked {\\n      uint256 exponent = (uint128(x) >> 112) & 0x7FFF;\\n\\n      require(exponent <= 16510); // Overflow\\n      if (exponent < 16255) return 0; // Underflow\\n\\n      uint256 result = (uint256(uint128(x)) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF) |\\n        0x10000000000000000000000000000;\\n\\n      if (exponent < 16367) result >>= 16367 - exponent;\\n      else if (exponent > 16367) result <<= exponent - 16367;\\n\\n      if (uint128(x) >= 0x80000000000000000000000000000000) {\\n        // Negative\\n        require(\\n          result <=\\n            0x8000000000000000000000000000000000000000000000000000000000000000\\n        );\\n        return -int256(result); // We rely on overflow behavior here\\n      } else {\\n        require(\\n          result <=\\n            0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\\n        );\\n        return int256(result);\\n      }\\n    }\\n  }\\n\\n  /**\\n   * Convert signed 64.64 bit fixed point number into quadruple precision\\n   * number.\\n   *\\n   * @param x signed 64.64 bit fixed point number\\n   * @return quadruple precision number\\n   */\\n  function from64x64(int128 x) internal pure returns (bytes16) {\\n    unchecked {\\n      if (x == 0) return bytes16(0);\\n      else {\\n        // We rely on overflow behavior here\\n        uint256 result = uint128(x > 0 ? x : -x);\\n\\n        uint256 msb = mostSignificantBit(result);\\n        if (msb < 112) result <<= 112 - msb;\\n        else if (msb > 112) result >>= msb - 112;\\n\\n        result =\\n          (result & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF) |\\n          ((16319 + msb) << 112);\\n        if (x < 0) result |= 0x80000000000000000000000000000000;\\n\\n        return bytes16(uint128(result));\\n      }\\n    }\\n  }\\n\\n  /**\\n   * Convert quadruple precision number into signed 64.64 bit fixed point\\n   * number.  Revert on overflow.\\n   *\\n   * @param x quadruple precision number\\n   * @return signed 64.64 bit fixed point number\\n   */\\n  function to64x64(bytes16 x) internal pure returns (int128) {\\n    unchecked {\\n      uint256 exponent = (uint128(x) >> 112) & 0x7FFF;\\n\\n      require(exponent <= 16446); // Overflow\\n      if (exponent < 16319) return 0; // Underflow\\n\\n      uint256 result = (uint256(uint128(x)) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF) |\\n        0x10000000000000000000000000000;\\n\\n      if (exponent < 16431) result >>= 16431 - exponent;\\n      else if (exponent > 16431) result <<= exponent - 16431;\\n\\n      if (uint128(x) >= 0x80000000000000000000000000000000) {\\n        // Negative\\n        require(result <= 0x80000000000000000000000000000000);\\n        return -int128(int256(result)); // We rely on overflow behavior here\\n      } else {\\n        require(result <= 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\\n        return int128(int256(result));\\n      }\\n    }\\n  }\\n\\n  /**\\n   * Convert octuple precision number into quadruple precision number.\\n   *\\n   * @param x octuple precision number\\n   * @return quadruple precision number\\n   */\\n  function fromOctuple(bytes32 x) internal pure returns (bytes16) {\\n    unchecked {\\n      bool negative = x &\\n        0x8000000000000000000000000000000000000000000000000000000000000000 >\\n        0;\\n\\n      uint256 exponent = (uint256(x) >> 236) & 0x7FFFF;\\n      uint256 significand = uint256(x) &\\n        0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n\\n      if (exponent == 0x7FFFF) {\\n        if (significand > 0) return NaN;\\n        else return negative ? NEGATIVE_INFINITY : POSITIVE_INFINITY;\\n      }\\n\\n      if (exponent > 278526)\\n        return negative ? NEGATIVE_INFINITY : POSITIVE_INFINITY;\\n      else if (exponent < 245649)\\n        return negative ? NEGATIVE_ZERO : POSITIVE_ZERO;\\n      else if (exponent < 245761) {\\n        significand =\\n          (significand |\\n            0x100000000000000000000000000000000000000000000000000000000000) >>\\n          (245885 - exponent);\\n        exponent = 0;\\n      } else {\\n        significand >>= 124;\\n        exponent -= 245760;\\n      }\\n\\n      uint128 result = uint128(significand | (exponent << 112));\\n      if (negative) result |= 0x80000000000000000000000000000000;\\n\\n      return bytes16(result);\\n    }\\n  }\\n\\n  /**\\n   * Convert quadruple precision number into octuple precision number.\\n   *\\n   * @param x quadruple precision number\\n   * @return octuple precision number\\n   */\\n  function toOctuple(bytes16 x) internal pure returns (bytes32) {\\n    unchecked {\\n      uint256 exponent = (uint128(x) >> 112) & 0x7FFF;\\n\\n      uint256 result = uint128(x) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n\\n      if (exponent == 0x7FFF)\\n        exponent = 0x7FFFF; // Infinity or NaN\\n      else if (exponent == 0) {\\n        if (result > 0) {\\n          uint256 msb = mostSignificantBit(result);\\n          result =\\n            (result << (236 - msb)) &\\n            0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n          exponent = 245649 + msb;\\n        }\\n      } else {\\n        result <<= 124;\\n        exponent += 245760;\\n      }\\n\\n      result |= exponent << 236;\\n      if (uint128(x) >= 0x80000000000000000000000000000000)\\n        result |= 0x8000000000000000000000000000000000000000000000000000000000000000;\\n\\n      return bytes32(result);\\n    }\\n  }\\n\\n  /**\\n   * Convert double precision number into quadruple precision number.\\n   *\\n   * @param x double precision number\\n   * @return quadruple precision number\\n   */\\n  function fromDouble(bytes8 x) internal pure returns (bytes16) {\\n    unchecked {\\n      uint256 exponent = (uint64(x) >> 52) & 0x7FF;\\n\\n      uint256 result = uint64(x) & 0xFFFFFFFFFFFFF;\\n\\n      if (exponent == 0x7FF)\\n        exponent = 0x7FFF; // Infinity or NaN\\n      else if (exponent == 0) {\\n        if (result > 0) {\\n          uint256 msb = mostSignificantBit(result);\\n          result = (result << (112 - msb)) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n          exponent = 15309 + msb;\\n        }\\n      } else {\\n        result <<= 60;\\n        exponent += 15360;\\n      }\\n\\n      result |= exponent << 112;\\n      if (x & 0x8000000000000000 > 0)\\n        result |= 0x80000000000000000000000000000000;\\n\\n      return bytes16(uint128(result));\\n    }\\n  }\\n\\n  /**\\n   * Convert quadruple precision number into double precision number.\\n   *\\n   * @param x quadruple precision number\\n   * @return double precision number\\n   */\\n  function toDouble(bytes16 x) internal pure returns (bytes8) {\\n    unchecked {\\n      bool negative = uint128(x) >= 0x80000000000000000000000000000000;\\n\\n      uint256 exponent = (uint128(x) >> 112) & 0x7FFF;\\n      uint256 significand = uint128(x) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n\\n      if (exponent == 0x7FFF) {\\n        if (significand > 0) return 0x7FF8000000000000;\\n        // NaN\\n        else\\n          return\\n            negative\\n              ? bytes8(0xFFF0000000000000) // -Infinity\\n              : bytes8(0x7FF0000000000000); // Infinity\\n      }\\n\\n      if (exponent > 17406)\\n        return\\n          negative\\n            ? bytes8(0xFFF0000000000000) // -Infinity\\n            : bytes8(0x7FF0000000000000);\\n      // Infinity\\n      else if (exponent < 15309)\\n        return\\n          negative\\n            ? bytes8(0x8000000000000000) // -0\\n            : bytes8(0x0000000000000000);\\n      // 0\\n      else if (exponent < 15361) {\\n        significand =\\n          (significand | 0x10000000000000000000000000000) >>\\n          (15421 - exponent);\\n        exponent = 0;\\n      } else {\\n        significand >>= 60;\\n        exponent -= 15360;\\n      }\\n\\n      uint64 result = uint64(significand | (exponent << 52));\\n      if (negative) result |= 0x8000000000000000;\\n\\n      return bytes8(result);\\n    }\\n  }\\n\\n  /**\\n   * Test whether given quadruple precision number is NaN.\\n   *\\n   * @param x quadruple precision number\\n   * @return true if x is NaN, false otherwise\\n   */\\n  function isNaN(bytes16 x) internal pure returns (bool) {\\n    unchecked {\\n      return\\n        uint128(x) & 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF >\\n        0x7FFF0000000000000000000000000000;\\n    }\\n  }\\n\\n  /**\\n   * Test whether given quadruple precision number is positive or negative\\n   * infinity.\\n   *\\n   * @param x quadruple precision number\\n   * @return true if x is positive or negative infinity, false otherwise\\n   */\\n  function isInfinity(bytes16 x) internal pure returns (bool) {\\n    unchecked {\\n      return\\n        uint128(x) & 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF ==\\n        0x7FFF0000000000000000000000000000;\\n    }\\n  }\\n\\n  /**\\n   * Calculate sign of x, i.e. -1 if x is negative, 0 if x if zero, and 1 if x\\n   * is positive.  Note that sign (-0) is zero.  Revert if x is NaN.\\n   *\\n   * @param x quadruple precision number\\n   * @return sign of x\\n   */\\n  function sign(bytes16 x) internal pure returns (int8) {\\n    unchecked {\\n      uint128 absoluteX = uint128(x) & 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n\\n      require(absoluteX <= 0x7FFF0000000000000000000000000000); // Not NaN\\n\\n      if (absoluteX == 0) return 0;\\n      else if (uint128(x) >= 0x80000000000000000000000000000000) return -1;\\n      else return 1;\\n    }\\n  }\\n\\n  /**\\n   * Calculate sign (x - y).  Revert if either argument is NaN, or both\\n   * arguments are infinities of the same sign.\\n   *\\n   * @param x quadruple precision number\\n   * @param y quadruple precision number\\n   * @return sign (x - y)\\n   */\\n  function cmp(bytes16 x, bytes16 y) internal pure returns (int8) {\\n    unchecked {\\n      uint128 absoluteX = uint128(x) & 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n\\n      require(absoluteX <= 0x7FFF0000000000000000000000000000); // Not NaN\\n\\n      uint128 absoluteY = uint128(y) & 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n\\n      require(absoluteY <= 0x7FFF0000000000000000000000000000); // Not NaN\\n\\n      // Not infinities of the same sign\\n      require(x != y || absoluteX < 0x7FFF0000000000000000000000000000);\\n\\n      if (x == y) return 0;\\n      else {\\n        bool negativeX = uint128(x) >= 0x80000000000000000000000000000000;\\n        bool negativeY = uint128(y) >= 0x80000000000000000000000000000000;\\n\\n        if (negativeX) {\\n          if (negativeY) return absoluteX > absoluteY ? -1 : int8(1);\\n          else return -1;\\n        } else {\\n          if (negativeY) return 1;\\n          else return absoluteX > absoluteY ? int8(1) : -1;\\n        }\\n      }\\n    }\\n  }\\n\\n  /**\\n   * Test whether x equals y.  NaN, infinity, and -infinity are not equal to\\n   * anything.\\n   *\\n   * @param x quadruple precision number\\n   * @param y quadruple precision number\\n   * @return true if x equals to y, false otherwise\\n   */\\n  function eq(bytes16 x, bytes16 y) internal pure returns (bool) {\\n    unchecked {\\n      if (x == y) {\\n        return\\n          uint128(x) & 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF <\\n          0x7FFF0000000000000000000000000000;\\n      } else return false;\\n    }\\n  }\\n\\n  /**\\n   * Calculate x + y.  Special values behave in the following way:\\n   *\\n   * NaN + x = NaN for any x.\\n   * Infinity + x = Infinity for any finite x.\\n   * -Infinity + x = -Infinity for any finite x.\\n   * Infinity + Infinity = Infinity.\\n   * -Infinity + -Infinity = -Infinity.\\n   * Infinity + -Infinity = -Infinity + Infinity = NaN.\\n   *\\n   * @param x quadruple precision number\\n   * @param y quadruple precision number\\n   * @return quadruple precision number\\n   */\\n  function add(bytes16 x, bytes16 y) internal pure returns (bytes16) {\\n    unchecked {\\n      uint256 xExponent = (uint128(x) >> 112) & 0x7FFF;\\n      uint256 yExponent = (uint128(y) >> 112) & 0x7FFF;\\n\\n      if (xExponent == 0x7FFF) {\\n        if (yExponent == 0x7FFF) {\\n          if (x == y) return x;\\n          else return NaN;\\n        } else return x;\\n      } else if (yExponent == 0x7FFF) return y;\\n      else {\\n        bool xSign = uint128(x) >= 0x80000000000000000000000000000000;\\n        uint256 xSignifier = uint128(x) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n        if (xExponent == 0) xExponent = 1;\\n        else xSignifier |= 0x10000000000000000000000000000;\\n\\n        bool ySign = uint128(y) >= 0x80000000000000000000000000000000;\\n        uint256 ySignifier = uint128(y) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n        if (yExponent == 0) yExponent = 1;\\n        else ySignifier |= 0x10000000000000000000000000000;\\n\\n        if (xSignifier == 0) return y == NEGATIVE_ZERO ? POSITIVE_ZERO : y;\\n        else if (ySignifier == 0) return x == NEGATIVE_ZERO ? POSITIVE_ZERO : x;\\n        else {\\n          int256 delta = int256(xExponent) - int256(yExponent);\\n\\n          if (xSign == ySign) {\\n            if (delta > 112) return x;\\n            else if (delta > 0) ySignifier >>= uint256(delta);\\n            else if (delta < -112) return y;\\n            else if (delta < 0) {\\n              xSignifier >>= uint256(-delta);\\n              xExponent = yExponent;\\n            }\\n\\n            xSignifier += ySignifier;\\n\\n            if (xSignifier >= 0x20000000000000000000000000000) {\\n              xSignifier >>= 1;\\n              xExponent += 1;\\n            }\\n\\n            if (xExponent == 0x7FFF)\\n              return xSign ? NEGATIVE_INFINITY : POSITIVE_INFINITY;\\n            else {\\n              if (xSignifier < 0x10000000000000000000000000000) xExponent = 0;\\n              else xSignifier &= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n\\n              return\\n                bytes16(\\n                  uint128(\\n                    (xSign ? 0x80000000000000000000000000000000 : 0) |\\n                      (xExponent << 112) |\\n                      xSignifier\\n                  )\\n                );\\n            }\\n          } else {\\n            if (delta > 0) {\\n              xSignifier <<= 1;\\n              xExponent -= 1;\\n            } else if (delta < 0) {\\n              ySignifier <<= 1;\\n              xExponent = yExponent - 1;\\n            }\\n\\n            if (delta > 112) ySignifier = 1;\\n            else if (delta > 1)\\n              ySignifier = ((ySignifier - 1) >> uint256(delta - 1)) + 1;\\n            else if (delta < -112) xSignifier = 1;\\n            else if (delta < -1)\\n              xSignifier = ((xSignifier - 1) >> uint256(-delta - 1)) + 1;\\n\\n            if (xSignifier >= ySignifier) xSignifier -= ySignifier;\\n            else {\\n              xSignifier = ySignifier - xSignifier;\\n              xSign = ySign;\\n            }\\n\\n            if (xSignifier == 0) return POSITIVE_ZERO;\\n\\n            uint256 msb = mostSignificantBit(xSignifier);\\n\\n            if (msb == 113) {\\n              xSignifier = (xSignifier >> 1) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n              xExponent += 1;\\n            } else if (msb < 112) {\\n              uint256 shift = 112 - msb;\\n              if (xExponent > shift) {\\n                xSignifier =\\n                  (xSignifier << shift) &\\n                  0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n                xExponent -= shift;\\n              } else {\\n                xSignifier <<= xExponent - 1;\\n                xExponent = 0;\\n              }\\n            } else xSignifier &= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n\\n            if (xExponent == 0x7FFF)\\n              return xSign ? NEGATIVE_INFINITY : POSITIVE_INFINITY;\\n            else\\n              return\\n                bytes16(\\n                  uint128(\\n                    (xSign ? 0x80000000000000000000000000000000 : 0) |\\n                      (xExponent << 112) |\\n                      xSignifier\\n                  )\\n                );\\n          }\\n        }\\n      }\\n    }\\n  }\\n\\n  /**\\n   * Calculate x - y.  Special values behave in the following way:\\n   *\\n   * NaN - x = NaN for any x.\\n   * Infinity - x = Infinity for any finite x.\\n   * -Infinity - x = -Infinity for any finite x.\\n   * Infinity - -Infinity = Infinity.\\n   * -Infinity - Infinity = -Infinity.\\n   * Infinity - Infinity = -Infinity - -Infinity = NaN.\\n   *\\n   * @param x quadruple precision number\\n   * @param y quadruple precision number\\n   * @return quadruple precision number\\n   */\\n  function sub(bytes16 x, bytes16 y) internal pure returns (bytes16) {\\n    unchecked {\\n      return add(x, y ^ 0x80000000000000000000000000000000);\\n    }\\n  }\\n\\n  /**\\n   * Calculate x * y.  Special values behave in the following way:\\n   *\\n   * NaN * x = NaN for any x.\\n   * Infinity * x = Infinity for any finite positive x.\\n   * Infinity * x = -Infinity for any finite negative x.\\n   * -Infinity * x = -Infinity for any finite positive x.\\n   * -Infinity * x = Infinity for any finite negative x.\\n   * Infinity * 0 = NaN.\\n   * -Infinity * 0 = NaN.\\n   * Infinity * Infinity = Infinity.\\n   * Infinity * -Infinity = -Infinity.\\n   * -Infinity * Infinity = -Infinity.\\n   * -Infinity * -Infinity = Infinity.\\n   *\\n   * @param x quadruple precision number\\n   * @param y quadruple precision number\\n   * @return quadruple precision number\\n   */\\n  function mul(bytes16 x, bytes16 y) internal pure returns (bytes16) {\\n    unchecked {\\n      uint256 xExponent = (uint128(x) >> 112) & 0x7FFF;\\n      uint256 yExponent = (uint128(y) >> 112) & 0x7FFF;\\n\\n      if (xExponent == 0x7FFF) {\\n        if (yExponent == 0x7FFF) {\\n          if (x == y) return x ^ (y & 0x80000000000000000000000000000000);\\n          else if (x ^ y == 0x80000000000000000000000000000000) return x | y;\\n          else return NaN;\\n        } else {\\n          if (y & 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF == 0) return NaN;\\n          else return x ^ (y & 0x80000000000000000000000000000000);\\n        }\\n      } else if (yExponent == 0x7FFF) {\\n        if (x & 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF == 0) return NaN;\\n        else return y ^ (x & 0x80000000000000000000000000000000);\\n      } else {\\n        uint256 xSignifier = uint128(x) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n        if (xExponent == 0) xExponent = 1;\\n        else xSignifier |= 0x10000000000000000000000000000;\\n\\n        uint256 ySignifier = uint128(y) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n        if (yExponent == 0) yExponent = 1;\\n        else ySignifier |= 0x10000000000000000000000000000;\\n\\n        xSignifier *= ySignifier;\\n        if (xSignifier == 0)\\n          return\\n            (x ^ y) & 0x80000000000000000000000000000000 > 0\\n              ? NEGATIVE_ZERO\\n              : POSITIVE_ZERO;\\n\\n        xExponent += yExponent;\\n\\n        uint256 msb = xSignifier >=\\n          0x200000000000000000000000000000000000000000000000000000000\\n          ? 225\\n          : xSignifier >=\\n            0x100000000000000000000000000000000000000000000000000000000\\n          ? 224\\n          : mostSignificantBit(xSignifier);\\n\\n        if (xExponent + msb < 16496) {\\n          // Underflow\\n          xExponent = 0;\\n          xSignifier = 0;\\n        } else if (xExponent + msb < 16608) {\\n          // Subnormal\\n          if (xExponent < 16496) xSignifier >>= 16496 - xExponent;\\n          else if (xExponent > 16496) xSignifier <<= xExponent - 16496;\\n          xExponent = 0;\\n        } else if (xExponent + msb > 49373) {\\n          xExponent = 0x7FFF;\\n          xSignifier = 0;\\n        } else {\\n          if (msb > 112) xSignifier >>= msb - 112;\\n          else if (msb < 112) xSignifier <<= 112 - msb;\\n\\n          xSignifier &= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n\\n          xExponent = xExponent + msb - 16607;\\n        }\\n\\n        return\\n          bytes16(\\n            uint128(\\n              uint128((x ^ y) & 0x80000000000000000000000000000000) |\\n                (xExponent << 112) |\\n                xSignifier\\n            )\\n          );\\n      }\\n    }\\n  }\\n\\n  /**\\n   * Calculate x / y.  Special values behave in the following way:\\n   *\\n   * NaN / x = NaN for any x.\\n   * x / NaN = NaN for any x.\\n   * Infinity / x = Infinity for any finite non-negative x.\\n   * Infinity / x = -Infinity for any finite negative x including -0.\\n   * -Infinity / x = -Infinity for any finite non-negative x.\\n   * -Infinity / x = Infinity for any finite negative x including -0.\\n   * x / Infinity = 0 for any finite non-negative x.\\n   * x / -Infinity = -0 for any finite non-negative x.\\n   * x / Infinity = -0 for any finite non-negative x including -0.\\n   * x / -Infinity = 0 for any finite non-negative x including -0.\\n   *\\n   * Infinity / Infinity = NaN.\\n   * Infinity / -Infinity = -NaN.\\n   * -Infinity / Infinity = -NaN.\\n   * -Infinity / -Infinity = NaN.\\n   *\\n   * Division by zero behaves in the following way:\\n   *\\n   * x / 0 = Infinity for any finite positive x.\\n   * x / -0 = -Infinity for any finite positive x.\\n   * x / 0 = -Infinity for any finite negative x.\\n   * x / -0 = Infinity for any finite negative x.\\n   * 0 / 0 = NaN.\\n   * 0 / -0 = NaN.\\n   * -0 / 0 = NaN.\\n   * -0 / -0 = NaN.\\n   *\\n   * @param x quadruple precision number\\n   * @param y quadruple precision number\\n   * @return quadruple precision number\\n   */\\n  function div(bytes16 x, bytes16 y) internal pure returns (bytes16) {\\n    unchecked {\\n      uint256 xExponent = (uint128(x) >> 112) & 0x7FFF;\\n      uint256 yExponent = (uint128(y) >> 112) & 0x7FFF;\\n\\n      if (xExponent == 0x7FFF) {\\n        if (yExponent == 0x7FFF) return NaN;\\n        else return x ^ (y & 0x80000000000000000000000000000000);\\n      } else if (yExponent == 0x7FFF) {\\n        if (y & 0x0000FFFFFFFFFFFFFFFFFFFFFFFFFFFF != 0) return NaN;\\n        else\\n          return POSITIVE_ZERO | ((x ^ y) & 0x80000000000000000000000000000000);\\n      } else if (y & 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF == 0) {\\n        if (x & 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF == 0) return NaN;\\n        else\\n          return\\n            POSITIVE_INFINITY | ((x ^ y) & 0x80000000000000000000000000000000);\\n      } else {\\n        uint256 ySignifier = uint128(y) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n        if (yExponent == 0) yExponent = 1;\\n        else ySignifier |= 0x10000000000000000000000000000;\\n\\n        uint256 xSignifier = uint128(x) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n        if (xExponent == 0) {\\n          if (xSignifier != 0) {\\n            uint256 shift = 226 - mostSignificantBit(xSignifier);\\n\\n            xSignifier <<= shift;\\n\\n            xExponent = 1;\\n            yExponent += shift - 114;\\n          }\\n        } else {\\n          xSignifier = (xSignifier | 0x10000000000000000000000000000) << 114;\\n        }\\n\\n        xSignifier = xSignifier / ySignifier;\\n        if (xSignifier == 0)\\n          return\\n            (x ^ y) & 0x80000000000000000000000000000000 > 0\\n              ? NEGATIVE_ZERO\\n              : POSITIVE_ZERO;\\n\\n        assert(xSignifier >= 0x1000000000000000000000000000);\\n\\n        uint256 msb = xSignifier >= 0x80000000000000000000000000000\\n          ? mostSignificantBit(xSignifier)\\n          : xSignifier >= 0x40000000000000000000000000000\\n          ? 114\\n          : xSignifier >= 0x20000000000000000000000000000\\n          ? 113\\n          : 112;\\n\\n        if (xExponent + msb > yExponent + 16497) {\\n          // Overflow\\n          xExponent = 0x7FFF;\\n          xSignifier = 0;\\n        } else if (xExponent + msb + 16380 < yExponent) {\\n          // Underflow\\n          xExponent = 0;\\n          xSignifier = 0;\\n        } else if (xExponent + msb + 16268 < yExponent) {\\n          // Subnormal\\n          if (xExponent + 16380 > yExponent)\\n            xSignifier <<= xExponent + 16380 - yExponent;\\n          else if (xExponent + 16380 < yExponent)\\n            xSignifier >>= yExponent - xExponent - 16380;\\n\\n          xExponent = 0;\\n        } else {\\n          // Normal\\n          if (msb > 112) xSignifier >>= msb - 112;\\n\\n          xSignifier &= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n\\n          xExponent = xExponent + msb + 16269 - yExponent;\\n        }\\n\\n        return\\n          bytes16(\\n            uint128(\\n              uint128((x ^ y) & 0x80000000000000000000000000000000) |\\n                (xExponent << 112) |\\n                xSignifier\\n            )\\n          );\\n      }\\n    }\\n  }\\n\\n  /**\\n   * Calculate -x.\\n   *\\n   * @param x quadruple precision number\\n   * @return quadruple precision number\\n   */\\n  function neg(bytes16 x) internal pure returns (bytes16) {\\n    unchecked {\\n      return x ^ 0x80000000000000000000000000000000;\\n    }\\n  }\\n\\n  /**\\n   * Calculate |x|.\\n   *\\n   * @param x quadruple precision number\\n   * @return quadruple precision number\\n   */\\n  function abs(bytes16 x) internal pure returns (bytes16) {\\n    unchecked {\\n      return x & 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n    }\\n  }\\n\\n  /**\\n   * Calculate square root of x.  Return NaN on negative x excluding -0.\\n   *\\n   * @param x quadruple precision number\\n   * @return quadruple precision number\\n   */\\n  function sqrt(bytes16 x) internal pure returns (bytes16) {\\n    unchecked {\\n      if (uint128(x) > 0x80000000000000000000000000000000) return NaN;\\n      else {\\n        uint256 xExponent = (uint128(x) >> 112) & 0x7FFF;\\n        if (xExponent == 0x7FFF) return x;\\n        else {\\n          uint256 xSignifier = uint128(x) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n          if (xExponent == 0) xExponent = 1;\\n          else xSignifier |= 0x10000000000000000000000000000;\\n\\n          if (xSignifier == 0) return POSITIVE_ZERO;\\n\\n          bool oddExponent = xExponent & 0x1 == 0;\\n          xExponent = (xExponent + 16383) >> 1;\\n\\n          if (oddExponent) {\\n            if (xSignifier >= 0x10000000000000000000000000000)\\n              xSignifier <<= 113;\\n            else {\\n              uint256 msb = mostSignificantBit(xSignifier);\\n              uint256 shift = (226 - msb) & 0xFE;\\n              xSignifier <<= shift;\\n              xExponent -= (shift - 112) >> 1;\\n            }\\n          } else {\\n            if (xSignifier >= 0x10000000000000000000000000000)\\n              xSignifier <<= 112;\\n            else {\\n              uint256 msb = mostSignificantBit(xSignifier);\\n              uint256 shift = (225 - msb) & 0xFE;\\n              xSignifier <<= shift;\\n              xExponent -= (shift - 112) >> 1;\\n            }\\n          }\\n\\n          uint256 r = 0x10000000000000000000000000000;\\n          r = (r + xSignifier / r) >> 1;\\n          r = (r + xSignifier / r) >> 1;\\n          r = (r + xSignifier / r) >> 1;\\n          r = (r + xSignifier / r) >> 1;\\n          r = (r + xSignifier / r) >> 1;\\n          r = (r + xSignifier / r) >> 1;\\n          r = (r + xSignifier / r) >> 1; // Seven iterations should be enough\\n          uint256 r1 = xSignifier / r;\\n          if (r1 < r) r = r1;\\n\\n          return\\n            bytes16(\\n              uint128((xExponent << 112) | (r & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF))\\n            );\\n        }\\n      }\\n    }\\n  }\\n\\n  /**\\n   * Calculate binary logarithm of x.  Return NaN on negative x excluding -0.\\n   *\\n   * @param x quadruple precision number\\n   * @return quadruple precision number\\n   */\\n  function log_2(bytes16 x) internal pure returns (bytes16) {\\n    unchecked {\\n      if (uint128(x) > 0x80000000000000000000000000000000) return NaN;\\n      else if (x == 0x3FFF0000000000000000000000000000) return POSITIVE_ZERO;\\n      else {\\n        uint256 xExponent = (uint128(x) >> 112) & 0x7FFF;\\n        if (xExponent == 0x7FFF) return x;\\n        else {\\n          uint256 xSignifier = uint128(x) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n          if (xExponent == 0) xExponent = 1;\\n          else xSignifier |= 0x10000000000000000000000000000;\\n\\n          if (xSignifier == 0) return NEGATIVE_INFINITY;\\n\\n          bool resultNegative;\\n          uint256 resultExponent = 16495;\\n          uint256 resultSignifier;\\n\\n          if (xExponent >= 0x3FFF) {\\n            resultNegative = false;\\n            resultSignifier = xExponent - 0x3FFF;\\n            xSignifier <<= 15;\\n          } else {\\n            resultNegative = true;\\n            if (xSignifier >= 0x10000000000000000000000000000) {\\n              resultSignifier = 0x3FFE - xExponent;\\n              xSignifier <<= 15;\\n            } else {\\n              uint256 msb = mostSignificantBit(xSignifier);\\n              resultSignifier = 16493 - msb;\\n              xSignifier <<= 127 - msb;\\n            }\\n          }\\n\\n          if (xSignifier == 0x80000000000000000000000000000000) {\\n            if (resultNegative) resultSignifier += 1;\\n            uint256 shift = 112 - mostSignificantBit(resultSignifier);\\n            resultSignifier <<= shift;\\n            resultExponent -= shift;\\n          } else {\\n            uint256 bb = resultNegative ? 1 : 0;\\n            while (resultSignifier < 0x10000000000000000000000000000) {\\n              resultSignifier <<= 1;\\n              resultExponent -= 1;\\n\\n              xSignifier *= xSignifier;\\n              uint256 b = xSignifier >> 255;\\n              resultSignifier += b ^ bb;\\n              xSignifier >>= 127 + b;\\n            }\\n          }\\n\\n          return\\n            bytes16(\\n              uint128(\\n                (resultNegative ? 0x80000000000000000000000000000000 : 0) |\\n                  (resultExponent << 112) |\\n                  (resultSignifier & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF)\\n              )\\n            );\\n        }\\n      }\\n    }\\n  }\\n\\n  /**\\n   * Calculate natural logarithm of x.  Return NaN on negative x excluding -0.\\n   *\\n   * @param x quadruple precision number\\n   * @return quadruple precision number\\n   */\\n  function ln(bytes16 x) internal pure returns (bytes16) {\\n    unchecked {\\n      return mul(log_2(x), 0x3FFE62E42FEFA39EF35793C7673007E5);\\n    }\\n  }\\n\\n  /**\\n   * Calculate 2^x.\\n   *\\n   * @param x quadruple precision number\\n   * @return quadruple precision number\\n   */\\n  function pow_2(bytes16 x) internal pure returns (bytes16) {\\n    unchecked {\\n      bool xNegative = uint128(x) > 0x80000000000000000000000000000000;\\n      uint256 xExponent = (uint128(x) >> 112) & 0x7FFF;\\n      uint256 xSignifier = uint128(x) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n\\n      if (xExponent == 0x7FFF && xSignifier != 0) return NaN;\\n      else if (xExponent > 16397)\\n        return xNegative ? POSITIVE_ZERO : POSITIVE_INFINITY;\\n      else if (xExponent < 16255) return 0x3FFF0000000000000000000000000000;\\n      else {\\n        if (xExponent == 0) xExponent = 1;\\n        else xSignifier |= 0x10000000000000000000000000000;\\n\\n        if (xExponent > 16367) xSignifier <<= xExponent - 16367;\\n        else if (xExponent < 16367) xSignifier >>= 16367 - xExponent;\\n\\n        if (xNegative && xSignifier > 0x406E00000000000000000000000000000000)\\n          return POSITIVE_ZERO;\\n\\n        if (!xNegative && xSignifier > 0x3FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)\\n          return POSITIVE_INFINITY;\\n\\n        uint256 resultExponent = xSignifier >> 128;\\n        xSignifier &= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n        if (xNegative && xSignifier != 0) {\\n          xSignifier = ~xSignifier;\\n          resultExponent += 1;\\n        }\\n\\n        uint256 resultSignifier = 0x80000000000000000000000000000000;\\n        if (xSignifier & 0x80000000000000000000000000000000 > 0)\\n          resultSignifier =\\n            (resultSignifier * 0x16A09E667F3BCC908B2FB1366EA957D3E) >>\\n            128;\\n        if (xSignifier & 0x40000000000000000000000000000000 > 0)\\n          resultSignifier =\\n            (resultSignifier * 0x1306FE0A31B7152DE8D5A46305C85EDEC) >>\\n            128;\\n        if (xSignifier & 0x20000000000000000000000000000000 > 0)\\n          resultSignifier =\\n            (resultSignifier * 0x1172B83C7D517ADCDF7C8C50EB14A791F) >>\\n            128;\\n        if (xSignifier & 0x10000000000000000000000000000000 > 0)\\n          resultSignifier =\\n            (resultSignifier * 0x10B5586CF9890F6298B92B71842A98363) >>\\n            128;\\n        if (xSignifier & 0x8000000000000000000000000000000 > 0)\\n          resultSignifier =\\n            (resultSignifier * 0x1059B0D31585743AE7C548EB68CA417FD) >>\\n            128;\\n        if (xSignifier & 0x4000000000000000000000000000000 > 0)\\n          resultSignifier =\\n            (resultSignifier * 0x102C9A3E778060EE6F7CACA4F7A29BDE8) >>\\n            128;\\n        if (xSignifier & 0x2000000000000000000000000000000 > 0)\\n          resultSignifier =\\n            (resultSignifier * 0x10163DA9FB33356D84A66AE336DCDFA3F) >>\\n            128;\\n        if (xSignifier & 0x1000000000000000000000000000000 > 0)\\n          resultSignifier =\\n            (resultSignifier * 0x100B1AFA5ABCBED6129AB13EC11DC9543) >>\\n            128;\\n        if (xSignifier & 0x800000000000000000000000000000 > 0)\\n          resultSignifier =\\n            (resultSignifier * 0x10058C86DA1C09EA1FF19D294CF2F679B) >>\\n            128;\\n        if (xSignifier & 0x400000000000000000000000000000 > 0)\\n          resultSignifier =\\n            (resultSignifier * 0x1002C605E2E8CEC506D21BFC89A23A00F) >>\\n            128;\\n        if (xSignifier & 0x200000000000000000000000000000 > 0)\\n          resultSignifier =\\n            (resultSignifier * 0x100162F3904051FA128BCA9C55C31E5DF) >>\\n            128;\\n        if (xSignifier & 0x100000000000000000000000000000 > 0)\\n          resultSignifier =\\n            (resultSignifier * 0x1000B175EFFDC76BA38E31671CA939725) >>\\n            128;\\n        if (xSignifier & 0x80000000000000000000000000000 > 0)\\n          resultSignifier =\\n            (resultSignifier * 0x100058BA01FB9F96D6CACD4B180917C3D) >>\\n            128;\\n        if (xSignifier & 0x40000000000000000000000000000 > 0)\\n          resultSignifier =\\n            (resultSignifier * 0x10002C5CC37DA9491D0985C348C68E7B3) >>\\n            128;\\n        if (xSignifier & 0x20000000000000000000000000000 > 0)\\n          resultSignifier =\\n            (resultSignifier * 0x1000162E525EE054754457D5995292026) >>\\n            128;\\n        if (xSignifier & 0x10000000000000000000000000000 > 0)\\n          resultSignifier =\\n            (resultSignifier * 0x10000B17255775C040618BF4A4ADE83FC) >>\\n            128;\\n        if (xSignifier & 0x8000000000000000000000000000 > 0)\\n          resultSignifier =\\n            (resultSignifier * 0x1000058B91B5BC9AE2EED81E9B7D4CFAB) >>\\n            128;\\n        if (xSignifier & 0x4000000000000000000000000000 > 0)\\n          resultSignifier =\\n            (resultSignifier * 0x100002C5C89D5EC6CA4D7C8ACC017B7C9) >>\\n            128;\\n        if (xSignifier & 0x2000000000000000000000000000 > 0)\\n          resultSignifier =\\n            (resultSignifier * 0x10000162E43F4F831060E02D839A9D16D) >>\\n            128;\\n        if (xSignifier & 0x1000000000000000000000000000 > 0)\\n          resultSignifier =\\n            (resultSignifier * 0x100000B1721BCFC99D9F890EA06911763) >>\\n            128;\\n        if (xSignifier & 0x800000000000000000000000000 > 0)\\n          resultSignifier =\\n            (resultSignifier * 0x10000058B90CF1E6D97F9CA14DBCC1628) >>\\n            128;\\n        if (xSignifier & 0x400000000000000000000000000 > 0)\\n          resultSignifier =\\n            (resultSignifier * 0x1000002C5C863B73F016468F6BAC5CA2B) >>\\n            128;\\n        if (xSignifier & 0x200000000000000000000000000 > 0)\\n          resultSignifier =\\n            (resultSignifier * 0x100000162E430E5A18F6119E3C02282A5) >>\\n            128;\\n        if (xSignifier & 0x100000000000000000000000000 > 0)\\n          resultSignifier =\\n            (resultSignifier * 0x1000000B1721835514B86E6D96EFD1BFE) >>\\n            128;\\n        if (xSignifier & 0x80000000000000000000000000 > 0)\\n          resultSignifier =\\n            (resultSignifier * 0x100000058B90C0B48C6BE5DF846C5B2EF) >>\\n            128;\\n        if (xSignifier & 0x40000000000000000000000000 > 0)\\n          resultSignifier =\\n            (resultSignifier * 0x10000002C5C8601CC6B9E94213C72737A) >>\\n            128;\\n        if (xSignifier & 0x20000000000000000000000000 > 0)\\n          resultSignifier =\\n            (resultSignifier * 0x1000000162E42FFF037DF38AA2B219F06) >>\\n            128;\\n        if (xSignifier & 0x10000000000000000000000000 > 0)\\n          resultSignifier =\\n            (resultSignifier * 0x10000000B17217FBA9C739AA5819F44F9) >>\\n            128;\\n        if (xSignifier & 0x8000000000000000000000000 > 0)\\n          resultSignifier =\\n            (resultSignifier * 0x1000000058B90BFCDEE5ACD3C1CEDC823) >>\\n            128;\\n        if (xSignifier & 0x4000000000000000000000000 > 0)\\n          resultSignifier =\\n            (resultSignifier * 0x100000002C5C85FE31F35A6A30DA1BE50) >>\\n            128;\\n        if (xSignifier & 0x2000000000000000000000000 > 0)\\n          resultSignifier =\\n            (resultSignifier * 0x10000000162E42FF0999CE3541B9FFFCF) >>\\n            128;\\n        if (xSignifier & 0x1000000000000000000000000 > 0)\\n          resultSignifier =\\n            (resultSignifier * 0x100000000B17217F80F4EF5AADDA45554) >>\\n            128;\\n        if (xSignifier & 0x800000000000000000000000 > 0)\\n          resultSignifier =\\n            (resultSignifier * 0x10000000058B90BFBF8479BD5A81B51AD) >>\\n            128;\\n        if (xSignifier & 0x400000000000000000000000 > 0)\\n          resultSignifier =\\n            (resultSignifier * 0x1000000002C5C85FDF84BD62AE30A74CC) >>\\n            128;\\n        if (xSignifier & 0x200000000000000000000000 > 0)\\n          resultSignifier =\\n            (resultSignifier * 0x100000000162E42FEFB2FED257559BDAA) >>\\n            128;\\n        if (xSignifier & 0x100000000000000000000000 > 0)\\n          resultSignifier =\\n            (resultSignifier * 0x1000000000B17217F7D5A7716BBA4A9AE) >>\\n            128;\\n        if (xSignifier & 0x80000000000000000000000 > 0)\\n          resultSignifier =\\n            (resultSignifier * 0x100000000058B90BFBE9DDBAC5E109CCE) >>\\n            128;\\n        if (xSignifier & 0x40000000000000000000000 > 0)\\n          resultSignifier =\\n            (resultSignifier * 0x10000000002C5C85FDF4B15DE6F17EB0D) >>\\n            128;\\n        if (xSignifier & 0x20000000000000000000000 > 0)\\n          resultSignifier =\\n            (resultSignifier * 0x1000000000162E42FEFA494F1478FDE05) >>\\n            128;\\n        if (xSignifier & 0x10000000000000000000000 > 0)\\n          resultSignifier =\\n            (resultSignifier * 0x10000000000B17217F7D20CF927C8E94C) >>\\n            128;\\n        if (xSignifier & 0x8000000000000000000000 > 0)\\n          resultSignifier =\\n            (resultSignifier * 0x1000000000058B90BFBE8F71CB4E4B33D) >>\\n            128;\\n        if (xSignifier & 0x4000000000000000000000 > 0)\\n          resultSignifier =\\n            (resultSignifier * 0x100000000002C5C85FDF477B662B26945) >>\\n            128;\\n        if (xSignifier & 0x2000000000000000000000 > 0)\\n          resultSignifier =\\n            (resultSignifier * 0x10000000000162E42FEFA3AE53369388C) >>\\n            128;\\n        if (xSignifier & 0x1000000000000000000000 > 0)\\n          resultSignifier =\\n            (resultSignifier * 0x100000000000B17217F7D1D351A389D40) >>\\n            128;\\n        if (xSignifier & 0x800000000000000000000 > 0)\\n          resultSignifier =\\n            (resultSignifier * 0x10000000000058B90BFBE8E8B2D3D4EDE) >>\\n            128;\\n        if (xSignifier & 0x400000000000000000000 > 0)\\n          resultSignifier =\\n            (resultSignifier * 0x1000000000002C5C85FDF4741BEA6E77E) >>\\n            128;\\n        if (xSignifier & 0x200000000000000000000 > 0)\\n          resultSignifier =\\n            (resultSignifier * 0x100000000000162E42FEFA39FE95583C2) >>\\n            128;\\n        if (xSignifier & 0x100000000000000000000 > 0)\\n          resultSignifier =\\n            (resultSignifier * 0x1000000000000B17217F7D1CFB72B45E1) >>\\n            128;\\n        if (xSignifier & 0x80000000000000000000 > 0)\\n          resultSignifier =\\n            (resultSignifier * 0x100000000000058B90BFBE8E7CC35C3F0) >>\\n            128;\\n        if (xSignifier & 0x40000000000000000000 > 0)\\n          resultSignifier =\\n            (resultSignifier * 0x10000000000002C5C85FDF473E242EA38) >>\\n            128;\\n        if (xSignifier & 0x20000000000000000000 > 0)\\n          resultSignifier =\\n            (resultSignifier * 0x1000000000000162E42FEFA39F02B772C) >>\\n            128;\\n        if (xSignifier & 0x10000000000000000000 > 0)\\n          resultSignifier =\\n            (resultSignifier * 0x10000000000000B17217F7D1CF7D83C1A) >>\\n            128;\\n        if (xSignifier & 0x8000000000000000000 > 0)\\n          resultSignifier =\\n            (resultSignifier * 0x1000000000000058B90BFBE8E7BDCBE2E) >>\\n            128;\\n        if (xSignifier & 0x4000000000000000000 > 0)\\n          resultSignifier =\\n            (resultSignifier * 0x100000000000002C5C85FDF473DEA871F) >>\\n            128;\\n        if (xSignifier & 0x2000000000000000000 > 0)\\n          resultSignifier =\\n            (resultSignifier * 0x10000000000000162E42FEFA39EF44D91) >>\\n            128;\\n        if (xSignifier & 0x1000000000000000000 > 0)\\n          resultSignifier =\\n            (resultSignifier * 0x100000000000000B17217F7D1CF79E949) >>\\n            128;\\n        if (xSignifier & 0x800000000000000000 > 0)\\n          resultSignifier =\\n            (resultSignifier * 0x10000000000000058B90BFBE8E7BCE544) >>\\n            128;\\n        if (xSignifier & 0x400000000000000000 > 0)\\n          resultSignifier =\\n            (resultSignifier * 0x1000000000000002C5C85FDF473DE6ECA) >>\\n            128;\\n        if (xSignifier & 0x200000000000000000 > 0)\\n          resultSignifier =\\n            (resultSignifier * 0x100000000000000162E42FEFA39EF366F) >>\\n            128;\\n        if (xSignifier & 0x100000000000000000 > 0)\\n          resultSignifier =\\n            (resultSignifier * 0x1000000000000000B17217F7D1CF79AFA) >>\\n            128;\\n        if (xSignifier & 0x80000000000000000 > 0)\\n          resultSignifier =\\n            (resultSignifier * 0x100000000000000058B90BFBE8E7BCD6D) >>\\n            128;\\n        if (xSignifier & 0x40000000000000000 > 0)\\n          resultSignifier =\\n            (resultSignifier * 0x10000000000000002C5C85FDF473DE6B2) >>\\n            128;\\n        if (xSignifier & 0x20000000000000000 > 0)\\n          resultSignifier =\\n            (resultSignifier * 0x1000000000000000162E42FEFA39EF358) >>\\n            128;\\n        if (xSignifier & 0x10000000000000000 > 0)\\n          resultSignifier =\\n            (resultSignifier * 0x10000000000000000B17217F7D1CF79AB) >>\\n            128;\\n        if (xSignifier & 0x8000000000000000 > 0)\\n          resultSignifier =\\n            (resultSignifier * 0x1000000000000000058B90BFBE8E7BCD5) >>\\n            128;\\n        if (xSignifier & 0x4000000000000000 > 0)\\n          resultSignifier =\\n            (resultSignifier * 0x100000000000000002C5C85FDF473DE6A) >>\\n            128;\\n        if (xSignifier & 0x2000000000000000 > 0)\\n          resultSignifier =\\n            (resultSignifier * 0x10000000000000000162E42FEFA39EF34) >>\\n            128;\\n        if (xSignifier & 0x1000000000000000 > 0)\\n          resultSignifier =\\n            (resultSignifier * 0x100000000000000000B17217F7D1CF799) >>\\n            128;\\n        if (xSignifier & 0x800000000000000 > 0)\\n          resultSignifier =\\n            (resultSignifier * 0x10000000000000000058B90BFBE8E7BCC) >>\\n            128;\\n        if (xSignifier & 0x400000000000000 > 0)\\n          resultSignifier =\\n            (resultSignifier * 0x1000000000000000002C5C85FDF473DE5) >>\\n            128;\\n        if (xSignifier & 0x200000000000000 > 0)\\n          resultSignifier =\\n            (resultSignifier * 0x100000000000000000162E42FEFA39EF2) >>\\n            128;\\n        if (xSignifier & 0x100000000000000 > 0)\\n          resultSignifier =\\n            (resultSignifier * 0x1000000000000000000B17217F7D1CF78) >>\\n            128;\\n        if (xSignifier & 0x80000000000000 > 0)\\n          resultSignifier =\\n            (resultSignifier * 0x100000000000000000058B90BFBE8E7BB) >>\\n            128;\\n        if (xSignifier & 0x40000000000000 > 0)\\n          resultSignifier =\\n            (resultSignifier * 0x10000000000000000002C5C85FDF473DD) >>\\n            128;\\n        if (xSignifier & 0x20000000000000 > 0)\\n          resultSignifier =\\n            (resultSignifier * 0x1000000000000000000162E42FEFA39EE) >>\\n            128;\\n        if (xSignifier & 0x10000000000000 > 0)\\n          resultSignifier =\\n            (resultSignifier * 0x10000000000000000000B17217F7D1CF6) >>\\n            128;\\n        if (xSignifier & 0x8000000000000 > 0)\\n          resultSignifier =\\n            (resultSignifier * 0x1000000000000000000058B90BFBE8E7A) >>\\n            128;\\n        if (xSignifier & 0x4000000000000 > 0)\\n          resultSignifier =\\n            (resultSignifier * 0x100000000000000000002C5C85FDF473C) >>\\n            128;\\n        if (xSignifier & 0x2000000000000 > 0)\\n          resultSignifier =\\n            (resultSignifier * 0x10000000000000000000162E42FEFA39D) >>\\n            128;\\n        if (xSignifier & 0x1000000000000 > 0)\\n          resultSignifier =\\n            (resultSignifier * 0x100000000000000000000B17217F7D1CE) >>\\n            128;\\n        if (xSignifier & 0x800000000000 > 0)\\n          resultSignifier =\\n            (resultSignifier * 0x10000000000000000000058B90BFBE8E6) >>\\n            128;\\n        if (xSignifier & 0x400000000000 > 0)\\n          resultSignifier =\\n            (resultSignifier * 0x1000000000000000000002C5C85FDF472) >>\\n            128;\\n        if (xSignifier & 0x200000000000 > 0)\\n          resultSignifier =\\n            (resultSignifier * 0x100000000000000000000162E42FEFA38) >>\\n            128;\\n        if (xSignifier & 0x100000000000 > 0)\\n          resultSignifier =\\n            (resultSignifier * 0x1000000000000000000000B17217F7D1B) >>\\n            128;\\n        if (xSignifier & 0x80000000000 > 0)\\n          resultSignifier =\\n            (resultSignifier * 0x100000000000000000000058B90BFBE8D) >>\\n            128;\\n        if (xSignifier & 0x40000000000 > 0)\\n          resultSignifier =\\n            (resultSignifier * 0x10000000000000000000002C5C85FDF46) >>\\n            128;\\n        if (xSignifier & 0x20000000000 > 0)\\n          resultSignifier =\\n            (resultSignifier * 0x1000000000000000000000162E42FEFA2) >>\\n            128;\\n        if (xSignifier & 0x10000000000 > 0)\\n          resultSignifier =\\n            (resultSignifier * 0x10000000000000000000000B17217F7D0) >>\\n            128;\\n        if (xSignifier & 0x8000000000 > 0)\\n          resultSignifier =\\n            (resultSignifier * 0x1000000000000000000000058B90BFBE7) >>\\n            128;\\n        if (xSignifier & 0x4000000000 > 0)\\n          resultSignifier =\\n            (resultSignifier * 0x100000000000000000000002C5C85FDF3) >>\\n            128;\\n        if (xSignifier & 0x2000000000 > 0)\\n          resultSignifier =\\n            (resultSignifier * 0x10000000000000000000000162E42FEF9) >>\\n            128;\\n        if (xSignifier & 0x1000000000 > 0)\\n          resultSignifier =\\n            (resultSignifier * 0x100000000000000000000000B17217F7C) >>\\n            128;\\n        if (xSignifier & 0x800000000 > 0)\\n          resultSignifier =\\n            (resultSignifier * 0x10000000000000000000000058B90BFBD) >>\\n            128;\\n        if (xSignifier & 0x400000000 > 0)\\n          resultSignifier =\\n            (resultSignifier * 0x1000000000000000000000002C5C85FDE) >>\\n            128;\\n        if (xSignifier & 0x200000000 > 0)\\n          resultSignifier =\\n            (resultSignifier * 0x100000000000000000000000162E42FEE) >>\\n            128;\\n        if (xSignifier & 0x100000000 > 0)\\n          resultSignifier =\\n            (resultSignifier * 0x1000000000000000000000000B17217F6) >>\\n            128;\\n        if (xSignifier & 0x80000000 > 0)\\n          resultSignifier =\\n            (resultSignifier * 0x100000000000000000000000058B90BFA) >>\\n            128;\\n        if (xSignifier & 0x40000000 > 0)\\n          resultSignifier =\\n            (resultSignifier * 0x10000000000000000000000002C5C85FC) >>\\n            128;\\n        if (xSignifier & 0x20000000 > 0)\\n          resultSignifier =\\n            (resultSignifier * 0x1000000000000000000000000162E42FD) >>\\n            128;\\n        if (xSignifier & 0x10000000 > 0)\\n          resultSignifier =\\n            (resultSignifier * 0x10000000000000000000000000B17217E) >>\\n            128;\\n        if (xSignifier & 0x8000000 > 0)\\n          resultSignifier =\\n            (resultSignifier * 0x1000000000000000000000000058B90BE) >>\\n            128;\\n        if (xSignifier & 0x4000000 > 0)\\n          resultSignifier =\\n            (resultSignifier * 0x100000000000000000000000002C5C85E) >>\\n            128;\\n        if (xSignifier & 0x2000000 > 0)\\n          resultSignifier =\\n            (resultSignifier * 0x10000000000000000000000000162E42E) >>\\n            128;\\n        if (xSignifier & 0x1000000 > 0)\\n          resultSignifier =\\n            (resultSignifier * 0x100000000000000000000000000B17216) >>\\n            128;\\n        if (xSignifier & 0x800000 > 0)\\n          resultSignifier =\\n            (resultSignifier * 0x10000000000000000000000000058B90A) >>\\n            128;\\n        if (xSignifier & 0x400000 > 0)\\n          resultSignifier =\\n            (resultSignifier * 0x1000000000000000000000000002C5C84) >>\\n            128;\\n        if (xSignifier & 0x200000 > 0)\\n          resultSignifier =\\n            (resultSignifier * 0x100000000000000000000000000162E41) >>\\n            128;\\n        if (xSignifier & 0x100000 > 0)\\n          resultSignifier =\\n            (resultSignifier * 0x1000000000000000000000000000B1720) >>\\n            128;\\n        if (xSignifier & 0x80000 > 0)\\n          resultSignifier =\\n            (resultSignifier * 0x100000000000000000000000000058B8F) >>\\n            128;\\n        if (xSignifier & 0x40000 > 0)\\n          resultSignifier =\\n            (resultSignifier * 0x10000000000000000000000000002C5C7) >>\\n            128;\\n        if (xSignifier & 0x20000 > 0)\\n          resultSignifier =\\n            (resultSignifier * 0x1000000000000000000000000000162E3) >>\\n            128;\\n        if (xSignifier & 0x10000 > 0)\\n          resultSignifier =\\n            (resultSignifier * 0x10000000000000000000000000000B171) >>\\n            128;\\n        if (xSignifier & 0x8000 > 0)\\n          resultSignifier =\\n            (resultSignifier * 0x1000000000000000000000000000058B8) >>\\n            128;\\n        if (xSignifier & 0x4000 > 0)\\n          resultSignifier =\\n            (resultSignifier * 0x100000000000000000000000000002C5B) >>\\n            128;\\n        if (xSignifier & 0x2000 > 0)\\n          resultSignifier =\\n            (resultSignifier * 0x10000000000000000000000000000162D) >>\\n            128;\\n        if (xSignifier & 0x1000 > 0)\\n          resultSignifier =\\n            (resultSignifier * 0x100000000000000000000000000000B16) >>\\n            128;\\n        if (xSignifier & 0x800 > 0)\\n          resultSignifier =\\n            (resultSignifier * 0x10000000000000000000000000000058A) >>\\n            128;\\n        if (xSignifier & 0x400 > 0)\\n          resultSignifier =\\n            (resultSignifier * 0x1000000000000000000000000000002C4) >>\\n            128;\\n        if (xSignifier & 0x200 > 0)\\n          resultSignifier =\\n            (resultSignifier * 0x100000000000000000000000000000161) >>\\n            128;\\n        if (xSignifier & 0x100 > 0)\\n          resultSignifier =\\n            (resultSignifier * 0x1000000000000000000000000000000B0) >>\\n            128;\\n        if (xSignifier & 0x80 > 0)\\n          resultSignifier =\\n            (resultSignifier * 0x100000000000000000000000000000057) >>\\n            128;\\n        if (xSignifier & 0x40 > 0)\\n          resultSignifier =\\n            (resultSignifier * 0x10000000000000000000000000000002B) >>\\n            128;\\n        if (xSignifier & 0x20 > 0)\\n          resultSignifier =\\n            (resultSignifier * 0x100000000000000000000000000000015) >>\\n            128;\\n        if (xSignifier & 0x10 > 0)\\n          resultSignifier =\\n            (resultSignifier * 0x10000000000000000000000000000000A) >>\\n            128;\\n        if (xSignifier & 0x8 > 0)\\n          resultSignifier =\\n            (resultSignifier * 0x100000000000000000000000000000004) >>\\n            128;\\n        if (xSignifier & 0x4 > 0)\\n          resultSignifier =\\n            (resultSignifier * 0x100000000000000000000000000000001) >>\\n            128;\\n\\n        if (!xNegative) {\\n          resultSignifier =\\n            (resultSignifier >> 15) &\\n            0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n          resultExponent += 0x3FFF;\\n        } else if (resultExponent <= 0x3FFE) {\\n          resultSignifier =\\n            (resultSignifier >> 15) &\\n            0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n          resultExponent = 0x3FFF - resultExponent;\\n        } else {\\n          resultSignifier = resultSignifier >> (resultExponent - 16367);\\n          resultExponent = 0;\\n        }\\n\\n        return bytes16(uint128((resultExponent << 112) | resultSignifier));\\n      }\\n    }\\n  }\\n\\n  /**\\n   * Calculate e^x.\\n   *\\n   * @param x quadruple precision number\\n   * @return quadruple precision number\\n   */\\n  function exp(bytes16 x) internal pure returns (bytes16) {\\n    unchecked {\\n      return pow_2(mul(x, 0x3FFF71547652B82FE1777D0FFDA0D23A));\\n    }\\n  }\\n\\n  /**\\n   * Get index of the most significant non-zero bit in binary representation of\\n   * x.  Reverts if x is zero.\\n   *\\n   * @return index of the most significant non-zero bit in binary representation\\n   *         of x\\n   */\\n  function mostSignificantBit(uint256 x) private pure returns (uint256) {\\n    unchecked {\\n      require(x > 0);\\n\\n      uint256 result = 0;\\n\\n      if (x >= 0x100000000000000000000000000000000) {\\n        x >>= 128;\\n        result += 128;\\n      }\\n      if (x >= 0x10000000000000000) {\\n        x >>= 64;\\n        result += 64;\\n      }\\n      if (x >= 0x100000000) {\\n        x >>= 32;\\n        result += 32;\\n      }\\n      if (x >= 0x10000) {\\n        x >>= 16;\\n        result += 16;\\n      }\\n      if (x >= 0x100) {\\n        x >>= 8;\\n        result += 8;\\n      }\\n      if (x >= 0x10) {\\n        x >>= 4;\\n        result += 4;\\n      }\\n      if (x >= 0x4) {\\n        x >>= 2;\\n        result += 2;\\n      }\\n      if (x >= 0x2) result += 1; // No need to shift x anymore\\n\\n      return result;\\n    }\\n  }\\n}\\n\",\"keccak256\":\"0x805b2f232c048e00f00b26167538ae30e684fee3e2bef2cde2b6728481619309\",\"license\":\"BSD-4-Clause\"},\"contracts/interfaces/IOptionPricing.sol\":{\"content\":\"//SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.0;\\n\\ninterface IOptionPricing {\\n  function getOptionPrice(\\n    bool isPut,\\n    uint256 expiry,\\n    uint256 strike,\\n    uint256 lastPrice,\\n    uint256 baseIv\\n  ) external view returns (uint256);\\n}\\n\",\"keccak256\":\"0x5b8fc680c84fc7b324e2c5f5f3c03264ddbc367d6abe27bd3d6299120f99aee7\",\"license\":\"UNLICENSED\"},\"contracts/libraries/BlackScholes.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.0;\\n\\n// Libraries\\nimport {ABDKMathQuad} from '../external/libraries/ABDKMathQuad.sol';\\n\\n/// @title Black-Scholes option pricing formula and supporting statistical functions\\n/// @author Dopex\\n/// @notice This library implements the Black-Scholes model to price options.\\n/// See - https://en.wikipedia.org/wiki/Black%E2%80%93Scholes_model\\n/// @dev Implements the following implementation - https://cseweb.ucsd.edu/~goguen/courses/130/SayBlackScholes.html\\n/// Uses the ABDKMathQuad(https://github.com/abdk-consulting/abdk-libraries-solidity/blob/master/ABDKMathQuad.md)\\n/// library to make precise calculations. It uses a DIVISOR (1e16) for maintaining precision in constants.\\nlibrary BlackScholes {\\n    uint8 internal constant OPTION_TYPE_CALL = 0;\\n    uint8 internal constant OPTION_TYPE_PUT = 1;\\n\\n    uint256 internal constant DIVISOR = 10**16;\\n\\n    /**\\n     * @notice The function that uses the Black-Scholes equation to calculate the option price\\n     * See http://en.wikipedia.org/wiki/Black%E2%80%93Scholes_model#Black-Scholes_formula\\n     * NOTE: The different parts of the equation are broken down to separate functions as using\\n     * ABDKMathQuad makes small equations verbose.\\n     * @param optionType Type of option - 0 = call, 1 = put\\n     * @param price Stock price\\n     * @param strike Strike price\\n     * @param timeToExpiry Time to expiry in days\\n     * @param riskFreeRate Risk-free rate\\n     * @param volatility Volatility on the asset\\n     * @return Option price based on the Black-Scholes model\\n     */\\n    function calculate(\\n        uint8 optionType,\\n        uint256 price,\\n        uint256 strike,\\n        uint256 timeToExpiry,\\n        uint256 riskFreeRate,\\n        uint256 volatility\\n    ) internal pure returns (uint256) {\\n        bytes16 S = ABDKMathQuad.fromUInt(price);\\n        bytes16 X = ABDKMathQuad.fromUInt(strike);\\n        bytes16 T = ABDKMathQuad.div(\\n            ABDKMathQuad.fromUInt(timeToExpiry),\\n            ABDKMathQuad.fromUInt(36500) // 365 * 10 ^ DAYS_PRECISION\\n        );\\n        bytes16 r = ABDKMathQuad.div(\\n            ABDKMathQuad.fromUInt(riskFreeRate),\\n            ABDKMathQuad.fromUInt(10000)\\n        );\\n        bytes16 v = ABDKMathQuad.div(\\n            ABDKMathQuad.fromUInt(volatility),\\n            ABDKMathQuad.fromUInt(100)\\n        );\\n        bytes16 d1 = ABDKMathQuad.div(\\n            ABDKMathQuad.add(\\n                ABDKMathQuad.ln(ABDKMathQuad.div(S, X)),\\n                ABDKMathQuad.mul(\\n                    ABDKMathQuad.add(\\n                        r,\\n                        ABDKMathQuad.mul(\\n                            v,\\n                            ABDKMathQuad.div(v, ABDKMathQuad.fromUInt(2))\\n                        )\\n                    ),\\n                    T\\n                )\\n            ),\\n            ABDKMathQuad.mul(v, ABDKMathQuad.sqrt(T))\\n        );\\n        bytes16 d2 = ABDKMathQuad.sub(\\n            d1,\\n            ABDKMathQuad.mul(v, ABDKMathQuad.sqrt(T))\\n        );\\n        if (optionType == OPTION_TYPE_CALL) {\\n            return\\n                ABDKMathQuad.toUInt(\\n                    ABDKMathQuad.mul(\\n                        _calculateCallTimeDecay(S, d1, X, r, T, d2),\\n                        ABDKMathQuad.fromUInt(DIVISOR)\\n                    )\\n                );\\n        } else if (optionType == OPTION_TYPE_PUT) {\\n            return\\n                ABDKMathQuad.toUInt(\\n                    ABDKMathQuad.mul(\\n                        _calculatePutTimeDecay(X, r, T, d2, S, d1),\\n                        ABDKMathQuad.fromUInt(DIVISOR)\\n                    )\\n                );\\n        } else return 0;\\n    }\\n\\n    /// @dev Function to caluclate the call time decay\\n    /// From the implementation page(https://cseweb.ucsd.edu/~goguen/courses/130/SayBlackScholes.html); part of the equation\\n    /// ( S * CND(d1)-X * Math.exp(-r * T) * CND(d2) );\\n    function _calculateCallTimeDecay(\\n        bytes16 S,\\n        bytes16 d1,\\n        bytes16 X,\\n        bytes16 r,\\n        bytes16 T,\\n        bytes16 d2\\n    ) internal pure returns (bytes16) {\\n        return\\n            ABDKMathQuad.sub(\\n                ABDKMathQuad.mul(S, CND(d1)),\\n                ABDKMathQuad.mul(\\n                    ABDKMathQuad.mul(\\n                        X,\\n                        ABDKMathQuad.exp(\\n                            ABDKMathQuad.mul(ABDKMathQuad.neg(r), T)\\n                        )\\n                    ),\\n                    CND(d2)\\n                )\\n            );\\n    }\\n\\n    /// @dev Function to caluclate the put time decay\\n    /// From the implementation page(https://cseweb.ucsd.edu/~goguen/courses/130/SayBlackScholes.html); part of the equation -\\n    /// ( X * Math.exp(-r * T) * CND(-d2) - S * CND(-d1) );\\n    function _calculatePutTimeDecay(\\n        bytes16 X,\\n        bytes16 r,\\n        bytes16 T,\\n        bytes16 d2,\\n        bytes16 S,\\n        bytes16 d1\\n    ) internal pure returns (bytes16) {\\n        bytes16 price_part1 = ABDKMathQuad.mul(\\n            ABDKMathQuad.mul(\\n                X,\\n                ABDKMathQuad.exp(ABDKMathQuad.mul(ABDKMathQuad.neg(r), T))\\n            ),\\n            CND(ABDKMathQuad.neg(d2))\\n        );\\n        bytes16 price_part2 = ABDKMathQuad.mul(S, CND(ABDKMathQuad.neg(d1)));\\n        bytes16 price = ABDKMathQuad.sub(price_part1, price_part2);\\n        return price;\\n    }\\n\\n    /**\\n     * @notice Normal cumulative distribution function.\\n     * See http://en.wikipedia.org/wiki/Normal_distribution#Cumulative_distribution_function\\n     * From the implementation page(https://cseweb.ucsd.edu/~goguen/courses/130/SayBlackScholes.html); part of the equation -\\n     * \\\"k = 1 / (1 + .2316419 * x); return ( 1 - Math.exp(-x * x / 2)/ Math.sqrt(2*Math.PI) * k * (.31938153 + k * (-.356563782 + k * (1.781477937 + k * (-1.821255978 + k * 1.330274429)))) );\\\"\\n     * NOTE: The different parts of the equation are broken down to separate functions as using\\n     * ABDKMathQuad makes small equations verbose.\\n     */\\n    function CND(bytes16 x) internal pure returns (bytes16) {\\n        if (ABDKMathQuad.toInt(x) < 0) {\\n            return (\\n                ABDKMathQuad.sub(\\n                    ABDKMathQuad.fromUInt(1),\\n                    CND(ABDKMathQuad.neg(x))\\n                )\\n            );\\n        } else {\\n            bytes16 k = ABDKMathQuad.div(\\n                ABDKMathQuad.fromUInt(1),\\n                ABDKMathQuad.add(\\n                    ABDKMathQuad.fromUInt(1),\\n                    ABDKMathQuad.mul(\\n                        ABDKMathQuad.div(\\n                            ABDKMathQuad.fromUInt(2316419000000000),\\n                            ABDKMathQuad.fromUInt(DIVISOR)\\n                        ),\\n                        x\\n                    )\\n                )\\n            );\\n            bytes16 CND_part2 = _getCNDPart2(k, x);\\n            return ABDKMathQuad.sub(ABDKMathQuad.fromUInt(1), CND_part2);\\n        }\\n    }\\n\\n    function _getCNDPart2(bytes16 k, bytes16 x)\\n        internal\\n        pure\\n        returns (bytes16)\\n    {\\n        return ABDKMathQuad.mul(_getCNDPart2_1(x), _getCNDPart2_2(k));\\n    }\\n\\n    function _getCNDPart2_1(bytes16 x) internal pure returns (bytes16) {\\n        return\\n            ABDKMathQuad.div(\\n                ABDKMathQuad.exp(\\n                    ABDKMathQuad.mul(\\n                        ABDKMathQuad.neg(x),\\n                        ABDKMathQuad.div(x, ABDKMathQuad.fromUInt(2))\\n                    )\\n                ),\\n                ABDKMathQuad.sqrt(\\n                    ABDKMathQuad.mul(\\n                        ABDKMathQuad.fromUInt(2),\\n                        ABDKMathQuad.div(\\n                            ABDKMathQuad.fromUInt(31415926530000000),\\n                            ABDKMathQuad.fromUInt(DIVISOR)\\n                        )\\n                    )\\n                )\\n            );\\n    }\\n\\n    function _getCNDPart2_2(bytes16 k) internal pure returns (bytes16) {\\n        return\\n            ABDKMathQuad.mul(\\n                ABDKMathQuad.add(\\n                    ABDKMathQuad.div(\\n                        ABDKMathQuad.fromUInt(3193815300000000),\\n                        ABDKMathQuad.fromUInt(DIVISOR)\\n                    ),\\n                    ABDKMathQuad.mul(\\n                        k,\\n                        ABDKMathQuad.add(\\n                            ABDKMathQuad.neg(\\n                                ABDKMathQuad.div(\\n                                    ABDKMathQuad.fromUInt(3565637820000000),\\n                                    ABDKMathQuad.fromUInt(DIVISOR)\\n                                )\\n                            ),\\n                            ABDKMathQuad.mul(\\n                                k,\\n                                ABDKMathQuad.add(\\n                                    ABDKMathQuad.div(\\n                                        ABDKMathQuad.fromUInt(\\n                                            17814779370000000\\n                                        ),\\n                                        ABDKMathQuad.fromUInt(DIVISOR)\\n                                    ),\\n                                    _getCNDPart2_2_1(k)\\n                                )\\n                            )\\n                        )\\n                    )\\n                ),\\n                k\\n            );\\n    }\\n\\n    function _getCNDPart2_2_1(bytes16 k) internal pure returns (bytes16) {\\n        return\\n            ABDKMathQuad.mul(\\n                k,\\n                ABDKMathQuad.add(\\n                    ABDKMathQuad.neg(\\n                        ABDKMathQuad.div(\\n                            ABDKMathQuad.fromUInt(18212559780000000),\\n                            ABDKMathQuad.fromUInt(DIVISOR)\\n                        )\\n                    ),\\n                    ABDKMathQuad.mul(\\n                        k,\\n                        ABDKMathQuad.div(\\n                            ABDKMathQuad.fromUInt(13302744290000000),\\n                            ABDKMathQuad.fromUInt(DIVISOR)\\n                        )\\n                    )\\n                )\\n            );\\n    }\\n}\\n\",\"keccak256\":\"0x16201d5044db4f8c54fdfff00ba3f24b1961abddbfc8178a12039a41364065af\",\"license\":\"UNLICENSED\"},\"contracts/pricing/OptionPricingSimple.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.0;\\n\\n// Libraries\\nimport {SafeMath} from '@openzeppelin/contracts/utils/math/SafeMath.sol';\\nimport {BlackScholes} from '../libraries/BlackScholes.sol';\\nimport {ABDKMathQuad} from '../external/libraries/ABDKMathQuad.sol';\\n\\n// Contracts\\nimport {Ownable} from '@openzeppelin/contracts/access/Ownable.sol';\\n\\n// Interfaces\\nimport {IOptionPricing} from '../interfaces/IOptionPricing.sol';\\n\\ncontract OptionPricingSimple is Ownable, IOptionPricing {\\n    using SafeMath for uint256;\\n\\n    // The max volatility possible\\n    uint256 public volatilityCap;\\n\\n    // The % of the price of asset which is the minimum option price possible in 1e8 precision\\n    uint256 public minOptionPricePercentage;\\n\\n    constructor(uint256 _volatilityCap, uint256 _minOptionPricePercentage) {\\n        volatilityCap = _volatilityCap;\\n        minOptionPricePercentage = _minOptionPricePercentage;\\n    }\\n\\n    /*---- GOVERNANCE FUNCTIONS ----*/\\n\\n    /// @notice updates volatility cap for an option pool\\n    /// @param _volatilityCap the new volatility cap\\n    /// @return whether volatility cap was updated\\n    function updateVolatilityCap(uint256 _volatilityCap)\\n        external\\n        onlyOwner\\n        returns (bool)\\n    {\\n        volatilityCap = _volatilityCap;\\n\\n        return true;\\n    }\\n\\n    /// @notice updates % of the price of asset which is the minimum option price possible\\n    /// @param _minOptionPricePercentage the new %\\n    /// @return whether % was updated\\n    function updateMinOptionPricePercentage(uint256 _minOptionPricePercentage)\\n        external\\n        onlyOwner\\n        returns (bool)\\n    {\\n        minOptionPricePercentage = _minOptionPricePercentage;\\n\\n        return true;\\n    }\\n\\n    /*---- VIEWS ----*/\\n\\n    /**\\n     * @notice computes the option price (with liquidity multiplier)\\n     * @param isPut is put option\\n     * @param expiry expiry timestamp\\n     * @param strike strike price\\n     * @param lastPrice current price\\n     * @param volatility volatility\\n     */\\n    function getOptionPrice(\\n        bool isPut,\\n        uint256 expiry,\\n        uint256 strike,\\n        uint256 lastPrice,\\n        uint256 volatility\\n    ) external view override returns (uint256) {\\n        uint256 timeToExpiry = expiry.sub(block.timestamp).div(864);\\n\\n        uint256 optionPrice = BlackScholes\\n            .calculate(\\n                isPut ? 1 : 0, // 0 - Put, 1 - Call\\n                lastPrice,\\n                strike,\\n                timeToExpiry, // Number of days to expiry mul by 100\\n                0,\\n                volatility\\n            )\\n            .div(BlackScholes.DIVISOR);\\n\\n        uint256 minOptionPrice = lastPrice.mul(minOptionPricePercentage).div(\\n            1e10\\n        );\\n\\n        if (minOptionPrice > optionPrice) {\\n            return minOptionPrice;\\n        }\\n\\n        return optionPrice;\\n    }\\n}\\n\",\"keccak256\":\"0x098f680bc814b04d3a0ff88895ba7c3ddb0f0acd659e11c65b3aeeb2c4baa461\",\"license\":\"UNLICENSED\"}},\"version\":1}",
  "bytecode": "0x60806040523480156200001157600080fd5b5060405162002ba038038062002ba083398101604081905262000034916200009e565b6200003f336200004e565b600191909155600255620000c3565b600080546001600160a01b038381166001600160a01b0319831681178455604051919092169283917f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e09190a35050565b60008060408385031215620000b257600080fd5b505080516020909101519092909150565b612acd80620000d36000396000f3fe608060405234801561001057600080fd5b50600436106100885760003560e01c8063715018a61161005b578063715018a6146100e85780638da5cb5b146100f2578063ad1ad5dc1461010d578063f2fde38b1461012057600080fd5b806305e927df1461008d57806325b2a93b146100a9578063326611f8146100b25780635b7b6d88146100d5575b600080fd5b61009660015481565b6040519081526020015b60405180910390f35b61009660025481565b6100c56100c036600461293d565b610133565b60405190151581526020016100a0565b6100966100e3366004612956565b610170565b6100f06101f9565b005b6000546040516001600160a01b0390911681526020016100a0565b6100c561011b36600461293d565b61022f565b6100f061012e36600461299f565b610263565b600080546001600160a01b031633146101675760405162461bcd60e51b815260040161015e906129c8565b60405180910390fd5b50600255600190565b60008061018961036061018388426102fe565b90610313565b905060006101b5662386f26fc100006101838a6101a75760006101aa565b60015b888a8760008b61031f565b905060006101d76402540be4006101836002548961047090919063ffffffff16565b9050818111156101eb5792506101f0915050565b509150505b95945050505050565b6000546001600160a01b031633146102235760405162461bcd60e51b815260040161015e906129c8565b61022d600061047c565b565b600080546001600160a01b0316331461025a5760405162461bcd60e51b815260040161015e906129c8565b50600190815590565b6000546001600160a01b0316331461028d5760405162461bcd60e51b815260040161015e906129c8565b6001600160a01b0381166102f25760405162461bcd60e51b815260206004820152602660248201527f4f776e61626c653a206e6577206f776e657220697320746865207a65726f206160448201526564647265737360d01b606482015260840161015e565b6102fb8161047c565b50565b600061030a8284612a13565b90505b92915050565b600061030a8284612a40565b60008061032b876104cc565b90506000610338876104cc565b90506000610358610348886104cc565b610353618e946104cc565b610530565b90506000610373610368886104cc565b6103536127106104cc565b9050600061038d610383886104cc565b61035360646104cc565b905060006103df6103d26103a96103a48989610530565b6107e8565b6103c76103cc876103c7886103c28a61035360026104cc565b61080b565b610a66565b8861080b565b610353846103c288610e26565b905060006103f9826103f4856103c289610e26565b610ff8565b905060ff8e1661043a5761042c61042761041789858a898b8861100a565b6103c2662386f26fc100006104cc565b61104f565b975050505050505050610466565b60ff8e166001141561045a5761042c610427610417888789868d896110d3565b60009750505050505050505b9695505050505050565b600061030a8284612a62565b600080546001600160a01b038381166001600160a01b0319831681178455604051919092169283917f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e09190a35050565b6000816104db57506000919050565b8160006104e782611132565b90506070811015610500578060700382901b9150610513565b6070811115610513576070810382901c91505b613fff0160701b6001600160701b03919091161760801b92915050565b6000617fff60f084811c8216919084901c8116908214156105765780617fff1415610565575061ffff60ef1b915061030d9050565b505050600160ff1b8116821861030d565b80617fff14156105ba576dffffffffffffffffffffffffffff60801b8416156105a9575061ffff60ef1b915061030d9050565b505050808218600160ff1b1661030d565b600160801b600160ff1b03841661060457600160801b600160ff1b0385166105ec575061ffff60ef1b915061030d9050565b505050808218600160ff1b16617fff60f01b1761030d565b6001600160701b03608085901c16816106205760019150610627565b600160701b175b6001600160701b03608087901c168361066657801561066157600061064b82611132565b6001955060e20393840160711901939190911b90505b610670565b600160701b1760721b5b81818161067f5761067f612a2a565b049050806106ac57600160ff1b8787181661069b5760006106a1565b600160ff1b5b94505050505061030d565b6001606c1b8110156106c0576106c0612a81565b6000600160731b8210156106ff57600160721b8210156106f457600160711b8210156106ed5760706106f7565b60716106f7565b60725b60ff16610708565b61070882611132565b90508361407101818601111561072657617fff9450600091506107b9565b83818601613ffc0110156107415760009450600091506107b9565b83818601613f8c01101561078e578385613ffc01111561076c578385613ffc010382901b9150610785565b8385613ffc01101561078557613ffc8585030382901c91505b600094506107b9565b60708111156107a1576070810382901c91505b6001600160701b038216915083818601613f8d010394505b81607086901b888a186001607f1b60801b1660801c6001600160801b0316171760801b9550505050505061030d565b600061030d6107f6836111d0565b6f3ffe62e42fefa39ef35793c7673007e560801b5b6000617fff60f084811c8216919084901c8116908214156108aa5780617fff1415610889576001600160801b0319858116908516141561085657505050600160ff1b8116821861030d565b600160ff1b6001600160801b03198686181614156108795750505081811761030d565b5061ffff60ef1b915061030d9050565b600160801b600160ff1b038416610565575061ffff60ef1b915061030d9050565b80617fff14156108e657600160801b600160ff1b0385166108d5575061ffff60ef1b915061030d9050565b505050600160ff1b8216811861030d565b6001600160701b03608086901c16826109025760019250610909565b600160701b175b6001600160701b03608086901c1682610925576001925061092c565b600160701b175b908102908161094957600160ff1b8787181661069b5760006106a1565b928201926000600160e11b83101561097c57600160e01b8310156109755761097083611132565b61097f565b60e061097f565b60e15b9050614070818601101561099a576000945060009250610a37565b6140e081860110156109dd576140708510156109bf57846140700383901c92506109d4565b6140708511156109d457614070850383901b92505b60009450610a37565b61c0dd81860111156109f757617fff945060009250610a37565b6070811115610a0e576070810383901c9250610a21565b6070811015610a21578060700383901b92505b6001600160701b03831692506140df8186010394505b82607086901b888a186001607f1b60801b1660801c6001600160801b0316171760801b9550505050505061030d565b6000617fff60f084811c8216919084901c811690821415610ab45780617fff1415610aaa576001600160801b0319858116908516141561087957849250505061030d565b849250505061030d565b80617fff1415610ac857839250505061030d565b6001607f1b608086901c90811015906001600160701b031683610aee5760019350610af5565b600160701b175b6001607f1b608087901c90811015906001600160701b031684610b1b5760019450610b22565b600160701b175b82610b52576001600160801b03198816600160ff1b14610b425787610b45565b60005b965050505050505061030d565b80610b72576001600160801b03198916600160ff1b14610b425788610b45565b8486038415158315151415610c7d576070811315610b99578997505050505050505061030d565b6000811315610bab5790811c90610bda565b606f19811215610bc4578897505050505050505061030d565b6000811215610bda578060000384901c93508596505b92810192600160711b8410610bf5576001968701969390931c925b86617fff1415610c275784610c0f57617fff60f01b610c19565b6001600160f01b03195b97505050505050505061030d565b600160701b841015610c3c5760009650610c49565b6001600160701b03841693505b83607088901b86610c5b576000610c61565b6001607f1b5b6001600160801b0316171760801b97505050505050505061030d565b6000811315610c9857600184901b9350600187039650610caf565b6000811215610caf57600182901b91506001860396505b6070811315610cc15760019150610d0e565b6001811315610cde576001810360018303901c6001019150610d0e565b606f19811215610cf15760019350610d0e565b600019811215610d0e576001816000030360018503901c60010193505b818410610d1f578184039350610d28565b83820393508294505b83610d3e57506000965061030d95505050505050565b6000610d4985611132565b90508060711415610d6f57600185901c6001600160701b03169450600188019750610dbe565b6070811015610db157607081900380891115610d9e578086901b6001600160701b031695508089039850610dab565b600098600019019590951b945b50610dbe565b6001600160701b03851694505b87617fff1415610df15785610dd857617fff60f01b610de2565b6001600160f01b03195b9850505050505050505061030d565b84607089901b87610e03576000610e09565b6001607f1b5b6001600160801b0316171760801b9850505050505050505061030d565b60006001607f1b608083901c1115610e44575061ffff60ef1b919050565b617fff60f083901c811690811415610e5d575090919050565b6001600160701b03608084901c1681610e795760019150610e80565b600160701b175b80610e8f575060009392505050565b613fff8201600190811c9216158015610ee157600160701b8210610eb957607182901b9150610f1c565b6000610ec483611132565b60e20360fe16606f19810160011c909403939290921b9150610f1c565b600160701b8210610ef857607082901b9150610f1c565b6000610f0383611132565b60e10360fe16606f19810160011c909403939290921b91505b600160701b80830401600190811c90818481610f3a57610f3a612a2a565b048201901c90506001818481610f5257610f52612a2a565b048201901c90506001818481610f6a57610f6a612a2a565b048201901c90506001818481610f8257610f82612a2a565b048201901c90506001818481610f9a57610f9a612a2a565b048201901c90506001818481610fb257610fb2612a2a565b048201901c90506000818481610fca57610fca612a2a565b04905081811015610fd9578091505b816001600160701b0316607086901b1760801b95505050505050919050565b600061030a83600160ff1b8418610a66565b600061104461101c886103c289611383565b6103f461103b886103c2611036600160ff1b8b188a61080b565b61141e565b6103c286611383565b979650505050505050565b6000617fff60f083901c16613fff81101561106d5750600092915050565b6001607f1b608084901c1061108157600080fd5b6140fe81111561109057600080fd5b600160701b6001600160701b03608085901c161761406f8210156110ba5761406f8290031c6110cc565b61406f8211156110cc5761406e1982011b5b9392505050565b6000806110ff6110f0896103c2611036600160ff1b8c188b61080b565b6103c2600160ff1b8818611383565b90506000611116856103c2600160ff1b8718611383565b905060006111248383610ff8565b9a9950505050505050505050565b600080821161114057600080fd5b6000600160801b831061115557608092831c92015b600160401b831061116857604092831c92015b640100000000831061117c57602092831c92015b62010000831061118e57601092831c92015b610100831061119f57600892831c92015b601083106111af57600492831c92015b600483106111bf57600292831c92015b6002831061030d5760010192915050565b60006001607f1b608083901c11156111ee575061ffff60ef1b919050565b613fff60f01b6001600160801b03198316141561120d57506000919050565b617fff60f083901c811690811415611226575090919050565b6001600160701b03608084901c16816112425760019150611249565b600160701b175b8061125f57506001600160f01b03199392505050565b600061406f81613fff85106112855750600f9290921b9160009150613ffe1984016112c4565b60019250600160701b84106112a75784613ffe039050600f84901b93506112c4565b60006112b285611132565b607f8190039590951b9461406d039150505b836001607f1b14156112fb5782156112da576001015b60006112e582611132565b60700390508082901b9150808303925050611349565b60008361130957600061130c565b60015b60ff1690505b600160701b8210156113475793800260ff81901c607f81019190911c94600019939093019260019290921b9082180190611312565b505b806001600160701b0316607083901b8461136457600061136a565b6001607f1b5b6001600160801b0316171760801b979650505050505050565b60008061138f83611445565b12156113b15761030d6113a260016104cc565b6103f4600160ff1b8518611383565b60006113f36113c060016104cc565b6103536113cd60016104cc565b6103c76103cc6113e366083ac553a55e006104cc565b610353662386f26fc100006104cc565b9050600061140182856114ec565b905061141661141060016104cc565b82610ff8565b949350505050565b600061030d611440836f1fffb8aa3b295c17f0bbbe87fed0691d60811b61080b565b611503565b6000617fff60f083901c166140fe81111561145f57600080fd5b613fff8110156114725750600092915050565b600160701b6001600160701b03608085901c161761406f82101561149c5761406f8290031c6114ae565b61406f8211156114ae5761406e1982011b5b6001607f1b608085901c106114d857600160ff1b8111156114ce57600080fd5b6000039392505050565b6001600160ff1b038111156110cc57600080fd5b600061030a6114fa83612855565b6103c28561289d565b60006001607f1b608083901c90811190617fff60f085901c8116916001600160701b0316908214801561153557508015155b15611549575061ffff60ef1b949350505050565b61400d82111561156e578261156357617fff60f01b6101f0565b600095945050505050565b613f7f8210156115875750613fff60f01b949350505050565b81611595576001915061159c565b600160701b175b613fef8211156115b257613fee1982011b6115c4565b613fef8210156115c457613fef8290031c5b8280156115d5575061203760811b81115b156115e557506000949350505050565b821580156116045750713fffffffffffffffffffffffffffffffffff81115b156116185750617fff60f01b949350505050565b6001600160801b0381169060801c83801561163257508115155b1561163e579019906001015b6001607f1b828116156116625770016a09e667f3bcc908b2fb1366ea957d3e0260801c5b6001607e1b831615611685577001306fe0a31b7152de8d5a46305c85edec0260801c5b6001607d1b8316156116a8577001172b83c7d517adcdf7c8c50eb14a791f0260801c5b6001607c1b8316156116cb5770010b5586cf9890f6298b92b71842a983630260801c5b6001607b1b8316156116ee577001059b0d31585743ae7c548eb68ca417fd0260801c5b6001607a1b83161561171157700102c9a3e778060ee6f7caca4f7a29bde80260801c5b600160791b8316156117345770010163da9fb33356d84a66ae336dcdfa3f0260801c5b600160781b83161561175757700100b1afa5abcbed6129ab13ec11dc95430260801c5b600160771b83161561177a5770010058c86da1c09ea1ff19d294cf2f679b0260801c5b600160761b83161561179d577001002c605e2e8cec506d21bfc89a23a00f0260801c5b600160751b8316156117c057700100162f3904051fa128bca9c55c31e5df0260801c5b600160741b8316156117e3577001000b175effdc76ba38e31671ca9397250260801c5b600160731b83161561180657700100058ba01fb9f96d6cacd4b180917c3d0260801c5b600160721b8316156118295770010002c5cc37da9491d0985c348c68e7b30260801c5b600160711b83161561184c577001000162e525ee054754457d59952920260260801c5b600160701b83161561186f5770010000b17255775c040618bf4a4ade83fc0260801c5b6001606f1b831615611892577001000058b91b5bc9ae2eed81e9b7d4cfab0260801c5b6001606e1b8316156118b557700100002c5c89d5ec6ca4d7c8acc017b7c90260801c5b6001606d1b8316156118d85770010000162e43f4f831060e02d839a9d16d0260801c5b6001606c1b8316156118fb57700100000b1721bcfc99d9f890ea069117630260801c5b6001606b1b83161561191e5770010000058b90cf1e6d97f9ca14dbcc16280260801c5b6001606a1b831615611941577001000002c5c863b73f016468f6bac5ca2b0260801c5b600160691b83161561196457700100000162e430e5a18f6119e3c02282a50260801c5b600160681b831615611987577001000000b1721835514b86e6d96efd1bfe0260801c5b600160671b8316156119aa57700100000058b90c0b48c6be5df846c5b2ef0260801c5b600160661b8316156119cd5770010000002c5c8601cc6b9e94213c72737a0260801c5b600160651b8316156119f0577001000000162e42fff037df38aa2b219f060260801c5b600160641b831615611a135770010000000b17217fba9c739aa5819f44f90260801c5b600160631b831615611a36577001000000058b90bfcdee5acd3c1cedc8230260801c5b600160621b831615611a5957700100000002c5c85fe31f35a6a30da1be500260801c5b600160611b831615611a7c5770010000000162e42ff0999ce3541b9fffcf0260801c5b600160601b831615611a9f57700100000000b17217f80f4ef5aadda455540260801c5b6001605f1b831615611ac25770010000000058b90bfbf8479bd5a81b51ad0260801c5b6001605e1b831615611ae5577001000000002c5c85fdf84bd62ae30a74cc0260801c5b6001605d1b831615611b0857700100000000162e42fefb2fed257559bdaa0260801c5b6001605c1b831615611b2b577001000000000b17217f7d5a7716bba4a9ae0260801c5b6001605b1b831615611b4e57700100000000058b90bfbe9ddbac5e109cce0260801c5b6001605a1b831615611b715770010000000002c5c85fdf4b15de6f17eb0d0260801c5b600160591b831615611b94577001000000000162e42fefa494f1478fde050260801c5b600160581b831615611bb75770010000000000b17217f7d20cf927c8e94c0260801c5b600160571b831615611bda577001000000000058b90bfbe8f71cb4e4b33d0260801c5b600160561b831615611bfd57700100000000002c5c85fdf477b662b269450260801c5b600160551b831615611c205770010000000000162e42fefa3ae53369388c0260801c5b600160541b831615611c4357700100000000000b17217f7d1d351a389d400260801c5b600160531b831615611c665770010000000000058b90bfbe8e8b2d3d4ede0260801c5b600160521b831615611c89577001000000000002c5c85fdf4741bea6e77e0260801c5b600160511b831615611cac57700100000000000162e42fefa39fe95583c20260801c5b600160501b831615611ccf577001000000000000b17217f7d1cfb72b45e10260801c5b6980000000000000000000831615611cf857700100000000000058b90bfbe8e7cc35c3f00260801c5b6940000000000000000000831615611d215770010000000000002c5c85fdf473e242ea380260801c5b6920000000000000000000831615611d4a577001000000000000162e42fefa39f02b772c0260801c5b6910000000000000000000831615611d735770010000000000000b17217f7d1cf7d83c1a0260801c5b6908000000000000000000831615611d9c577001000000000000058b90bfbe8e7bdcbe2e0260801c5b6904000000000000000000831615611dc557700100000000000002c5c85fdf473dea871f0260801c5b6902000000000000000000831615611dee5770010000000000000162e42fefa39ef44d910260801c5b6901000000000000000000831615611e1757700100000000000000b17217f7d1cf79e9490260801c5b68800000000000000000831615611e3f5770010000000000000058b90bfbe8e7bce5440260801c5b68400000000000000000831615611e67577001000000000000002c5c85fdf473de6eca0260801c5b68200000000000000000831615611e8f57700100000000000000162e42fefa39ef366f0260801c5b68100000000000000000831615611eb7577001000000000000000b17217f7d1cf79afa0260801c5b68080000000000000000831615611edf57700100000000000000058b90bfbe8e7bcd6d0260801c5b68040000000000000000831615611f075770010000000000000002c5c85fdf473de6b20260801c5b68020000000000000000831615611f2f577001000000000000000162e42fefa39ef3580260801c5b600160401b831615611f525770010000000000000000b17217f7d1cf79ab0260801c5b678000000000000000831615611f79577001000000000000000058b90bfbe8e7bcd50260801c5b674000000000000000831615611fa057700100000000000000002c5c85fdf473de6a0260801c5b672000000000000000831615611fc75770010000000000000000162e42fefa39ef340260801c5b671000000000000000831615611fee57700100000000000000000b17217f7d1cf7990260801c5b6708000000000000008316156120155770010000000000000000058b90bfbe8e7bcc0260801c5b67040000000000000083161561203c577001000000000000000002c5c85fdf473de50260801c5b67020000000000000083161561206357700100000000000000000162e42fefa39ef20260801c5b67010000000000000083161561208a577001000000000000000000b17217f7d1cf780260801c5b66800000000000008316156120b057700100000000000000000058b90bfbe8e7bb0260801c5b66400000000000008316156120d65770010000000000000000002c5c85fdf473dd0260801c5b66200000000000008316156120fc577001000000000000000000162e42fefa39ee0260801c5b66100000000000008316156121225770010000000000000000000b17217f7d1cf60260801c5b6608000000000000831615612148577001000000000000000000058b90bfbe8e7a0260801c5b660400000000000083161561216e57700100000000000000000002c5c85fdf473c0260801c5b66020000000000008316156121945770010000000000000000000162e42fefa39d0260801c5b66010000000000008316156121ba57700100000000000000000000b17217f7d1ce0260801c5b658000000000008316156121df5770010000000000000000000058b90bfbe8e60260801c5b65400000000000831615612204577001000000000000000000002c5c85fdf4720260801c5b6520000000000083161561222957700100000000000000000000162e42fefa380260801c5b6510000000000083161561224e577001000000000000000000000b17217f7d1b0260801c5b6508000000000083161561227357700100000000000000000000058b90bfbe8d0260801c5b650400000000008316156122985770010000000000000000000002c5c85fdf460260801c5b650200000000008316156122bd577001000000000000000000000162e42fefa20260801c5b650100000000008316156122e25770010000000000000000000000b17217f7d00260801c5b648000000000831615612306577001000000000000000000000058b90bfbe70260801c5b64400000000083161561232a57700100000000000000000000002c5c85fdf30260801c5b64200000000083161561234e5770010000000000000000000000162e42fef90260801c5b64100000000083161561237257700100000000000000000000000b17217f7c0260801c5b6408000000008316156123965770010000000000000000000000058b90bfbd0260801c5b6404000000008316156123ba577001000000000000000000000002c5c85fde0260801c5b6402000000008316156123de57700100000000000000000000000162e42fee0260801c5b640100000000831615612402577001000000000000000000000000b17217f60260801c5b638000000083161561242557700100000000000000000000000058b90bfa0260801c5b63400000008316156124485770010000000000000000000000002c5c85fc0260801c5b632000000083161561246b577001000000000000000000000000162e42fd0260801c5b631000000083161561248e5770010000000000000000000000000b17217e0260801c5b63080000008316156124b1577001000000000000000000000000058b90be0260801c5b63040000008316156124d457700100000000000000000000000002c5c85e0260801c5b63020000008316156124f75770010000000000000000000000000162e42e0260801c5b630100000083161561251a57700100000000000000000000000000b172160260801c5b6280000083161561253c5770010000000000000000000000000058b90a0260801c5b6240000083161561255e577001000000000000000000000000002c5c840260801c5b6220000083161561258057700100000000000000000000000000162e410260801c5b621000008316156125a2577001000000000000000000000000000b17200260801c5b620800008316156125c457700100000000000000000000000000058b8f0260801c5b620400008316156125e65770010000000000000000000000000002c5c70260801c5b62020000831615612608577001000000000000000000000000000162e30260801c5b6201000083161561262a5770010000000000000000000000000000b1710260801c5b61800083161561264b577001000000000000000000000000000058b80260801c5b61400083161561266c57700100000000000000000000000000002c5b0260801c5b61200083161561268d5770010000000000000000000000000000162d0260801c5b6110008316156126ae57700100000000000000000000000000000b160260801c5b6108008316156126cf5770010000000000000000000000000000058a0260801c5b6104008316156126f0577001000000000000000000000000000002c40260801c5b610200831615612711577001000000000000000000000000000001610260801c5b610100831615612732577001000000000000000000000000000000b00260801c5b6080831615612752577001000000000000000000000000000000570260801c5b60408316156127725770010000000000000000000000000000002b0260801c5b6020831615612792577001000000000000000000000000000000150260801c5b60108316156127b25770010000000000000000000000000000000a0260801c5b60088316156127d2577001000000000000000000000000000000040260801c5b60048316156127f2577001000000000000000000000000000000010260801c5b8461281357600f81901c6001600160701b03169050613fff82019150612842565b613ffe821161283857600f81901c6001600160701b0316905081613fff039150612842565b600091613fee19011c5b60709190911b1760801b95945050505050565b600061030d612875611036600160ff1b85186103c28661035360026104cc565b61035361289861288560026104cc565b6103c26113e3666f9c9e651c44806104cc565b610e26565b600061030d6129016128b86113e3660b58c2126f49006104cc565b6103c7856103c26128de6128d56113e3660caaedbfa8a7006104cc565b600160ff1b1890565b6103c7896103c26128f86113e3663f4a728c19ce806104cc565b6103c78d612907565b8361080b565b600061030d826103c26129266128d56113e36640b43a042331006104cc565b6103c7866103c26113e3662f42c683f17c806104cc565b60006020828403121561294f57600080fd5b5035919050565b600080600080600060a0868803121561296e57600080fd5b8535801515811461297e57600080fd5b97602087013597506040870135966060810135965060800135945092505050565b6000602082840312156129b157600080fd5b81356001600160a01b03811681146110cc57600080fd5b6020808252818101527f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572604082015260600190565b634e487b7160e01b600052601160045260246000fd5b600082821015612a2557612a256129fd565b500390565b634e487b7160e01b600052601260045260246000fd5b600082612a5d57634e487b7160e01b600052601260045260246000fd5b500490565b6000816000190483118215151615612a7c57612a7c6129fd565b500290565b634e487b7160e01b600052600160045260246000fdfea26469706673582212206c862d0e308452298a5a0081ce1bf6705b0ccdfc8b2f3b4da2fdc04de9d5f52764736f6c63430008090033",
  "deployedBytecode": "0x608060405234801561001057600080fd5b50600436106100885760003560e01c8063715018a61161005b578063715018a6146100e85780638da5cb5b146100f2578063ad1ad5dc1461010d578063f2fde38b1461012057600080fd5b806305e927df1461008d57806325b2a93b146100a9578063326611f8146100b25780635b7b6d88146100d5575b600080fd5b61009660015481565b6040519081526020015b60405180910390f35b61009660025481565b6100c56100c036600461293d565b610133565b60405190151581526020016100a0565b6100966100e3366004612956565b610170565b6100f06101f9565b005b6000546040516001600160a01b0390911681526020016100a0565b6100c561011b36600461293d565b61022f565b6100f061012e36600461299f565b610263565b600080546001600160a01b031633146101675760405162461bcd60e51b815260040161015e906129c8565b60405180910390fd5b50600255600190565b60008061018961036061018388426102fe565b90610313565b905060006101b5662386f26fc100006101838a6101a75760006101aa565b60015b888a8760008b61031f565b905060006101d76402540be4006101836002548961047090919063ffffffff16565b9050818111156101eb5792506101f0915050565b509150505b95945050505050565b6000546001600160a01b031633146102235760405162461bcd60e51b815260040161015e906129c8565b61022d600061047c565b565b600080546001600160a01b0316331461025a5760405162461bcd60e51b815260040161015e906129c8565b50600190815590565b6000546001600160a01b0316331461028d5760405162461bcd60e51b815260040161015e906129c8565b6001600160a01b0381166102f25760405162461bcd60e51b815260206004820152602660248201527f4f776e61626c653a206e6577206f776e657220697320746865207a65726f206160448201526564647265737360d01b606482015260840161015e565b6102fb8161047c565b50565b600061030a8284612a13565b90505b92915050565b600061030a8284612a40565b60008061032b876104cc565b90506000610338876104cc565b90506000610358610348886104cc565b610353618e946104cc565b610530565b90506000610373610368886104cc565b6103536127106104cc565b9050600061038d610383886104cc565b61035360646104cc565b905060006103df6103d26103a96103a48989610530565b6107e8565b6103c76103cc876103c7886103c28a61035360026104cc565b61080b565b610a66565b8861080b565b610353846103c288610e26565b905060006103f9826103f4856103c289610e26565b610ff8565b905060ff8e1661043a5761042c61042761041789858a898b8861100a565b6103c2662386f26fc100006104cc565b61104f565b975050505050505050610466565b60ff8e166001141561045a5761042c610427610417888789868d896110d3565b60009750505050505050505b9695505050505050565b600061030a8284612a62565b600080546001600160a01b038381166001600160a01b0319831681178455604051919092169283917f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e09190a35050565b6000816104db57506000919050565b8160006104e782611132565b90506070811015610500578060700382901b9150610513565b6070811115610513576070810382901c91505b613fff0160701b6001600160701b03919091161760801b92915050565b6000617fff60f084811c8216919084901c8116908214156105765780617fff1415610565575061ffff60ef1b915061030d9050565b505050600160ff1b8116821861030d565b80617fff14156105ba576dffffffffffffffffffffffffffff60801b8416156105a9575061ffff60ef1b915061030d9050565b505050808218600160ff1b1661030d565b600160801b600160ff1b03841661060457600160801b600160ff1b0385166105ec575061ffff60ef1b915061030d9050565b505050808218600160ff1b16617fff60f01b1761030d565b6001600160701b03608085901c16816106205760019150610627565b600160701b175b6001600160701b03608087901c168361066657801561066157600061064b82611132565b6001955060e20393840160711901939190911b90505b610670565b600160701b1760721b5b81818161067f5761067f612a2a565b049050806106ac57600160ff1b8787181661069b5760006106a1565b600160ff1b5b94505050505061030d565b6001606c1b8110156106c0576106c0612a81565b6000600160731b8210156106ff57600160721b8210156106f457600160711b8210156106ed5760706106f7565b60716106f7565b60725b60ff16610708565b61070882611132565b90508361407101818601111561072657617fff9450600091506107b9565b83818601613ffc0110156107415760009450600091506107b9565b83818601613f8c01101561078e578385613ffc01111561076c578385613ffc010382901b9150610785565b8385613ffc01101561078557613ffc8585030382901c91505b600094506107b9565b60708111156107a1576070810382901c91505b6001600160701b038216915083818601613f8d010394505b81607086901b888a186001607f1b60801b1660801c6001600160801b0316171760801b9550505050505061030d565b600061030d6107f6836111d0565b6f3ffe62e42fefa39ef35793c7673007e560801b5b6000617fff60f084811c8216919084901c8116908214156108aa5780617fff1415610889576001600160801b0319858116908516141561085657505050600160ff1b8116821861030d565b600160ff1b6001600160801b03198686181614156108795750505081811761030d565b5061ffff60ef1b915061030d9050565b600160801b600160ff1b038416610565575061ffff60ef1b915061030d9050565b80617fff14156108e657600160801b600160ff1b0385166108d5575061ffff60ef1b915061030d9050565b505050600160ff1b8216811861030d565b6001600160701b03608086901c16826109025760019250610909565b600160701b175b6001600160701b03608086901c1682610925576001925061092c565b600160701b175b908102908161094957600160ff1b8787181661069b5760006106a1565b928201926000600160e11b83101561097c57600160e01b8310156109755761097083611132565b61097f565b60e061097f565b60e15b9050614070818601101561099a576000945060009250610a37565b6140e081860110156109dd576140708510156109bf57846140700383901c92506109d4565b6140708511156109d457614070850383901b92505b60009450610a37565b61c0dd81860111156109f757617fff945060009250610a37565b6070811115610a0e576070810383901c9250610a21565b6070811015610a21578060700383901b92505b6001600160701b03831692506140df8186010394505b82607086901b888a186001607f1b60801b1660801c6001600160801b0316171760801b9550505050505061030d565b6000617fff60f084811c8216919084901c811690821415610ab45780617fff1415610aaa576001600160801b0319858116908516141561087957849250505061030d565b849250505061030d565b80617fff1415610ac857839250505061030d565b6001607f1b608086901c90811015906001600160701b031683610aee5760019350610af5565b600160701b175b6001607f1b608087901c90811015906001600160701b031684610b1b5760019450610b22565b600160701b175b82610b52576001600160801b03198816600160ff1b14610b425787610b45565b60005b965050505050505061030d565b80610b72576001600160801b03198916600160ff1b14610b425788610b45565b8486038415158315151415610c7d576070811315610b99578997505050505050505061030d565b6000811315610bab5790811c90610bda565b606f19811215610bc4578897505050505050505061030d565b6000811215610bda578060000384901c93508596505b92810192600160711b8410610bf5576001968701969390931c925b86617fff1415610c275784610c0f57617fff60f01b610c19565b6001600160f01b03195b97505050505050505061030d565b600160701b841015610c3c5760009650610c49565b6001600160701b03841693505b83607088901b86610c5b576000610c61565b6001607f1b5b6001600160801b0316171760801b97505050505050505061030d565b6000811315610c9857600184901b9350600187039650610caf565b6000811215610caf57600182901b91506001860396505b6070811315610cc15760019150610d0e565b6001811315610cde576001810360018303901c6001019150610d0e565b606f19811215610cf15760019350610d0e565b600019811215610d0e576001816000030360018503901c60010193505b818410610d1f578184039350610d28565b83820393508294505b83610d3e57506000965061030d95505050505050565b6000610d4985611132565b90508060711415610d6f57600185901c6001600160701b03169450600188019750610dbe565b6070811015610db157607081900380891115610d9e578086901b6001600160701b031695508089039850610dab565b600098600019019590951b945b50610dbe565b6001600160701b03851694505b87617fff1415610df15785610dd857617fff60f01b610de2565b6001600160f01b03195b9850505050505050505061030d565b84607089901b87610e03576000610e09565b6001607f1b5b6001600160801b0316171760801b9850505050505050505061030d565b60006001607f1b608083901c1115610e44575061ffff60ef1b919050565b617fff60f083901c811690811415610e5d575090919050565b6001600160701b03608084901c1681610e795760019150610e80565b600160701b175b80610e8f575060009392505050565b613fff8201600190811c9216158015610ee157600160701b8210610eb957607182901b9150610f1c565b6000610ec483611132565b60e20360fe16606f19810160011c909403939290921b9150610f1c565b600160701b8210610ef857607082901b9150610f1c565b6000610f0383611132565b60e10360fe16606f19810160011c909403939290921b91505b600160701b80830401600190811c90818481610f3a57610f3a612a2a565b048201901c90506001818481610f5257610f52612a2a565b048201901c90506001818481610f6a57610f6a612a2a565b048201901c90506001818481610f8257610f82612a2a565b048201901c90506001818481610f9a57610f9a612a2a565b048201901c90506001818481610fb257610fb2612a2a565b048201901c90506000818481610fca57610fca612a2a565b04905081811015610fd9578091505b816001600160701b0316607086901b1760801b95505050505050919050565b600061030a83600160ff1b8418610a66565b600061104461101c886103c289611383565b6103f461103b886103c2611036600160ff1b8b188a61080b565b61141e565b6103c286611383565b979650505050505050565b6000617fff60f083901c16613fff81101561106d5750600092915050565b6001607f1b608084901c1061108157600080fd5b6140fe81111561109057600080fd5b600160701b6001600160701b03608085901c161761406f8210156110ba5761406f8290031c6110cc565b61406f8211156110cc5761406e1982011b5b9392505050565b6000806110ff6110f0896103c2611036600160ff1b8c188b61080b565b6103c2600160ff1b8818611383565b90506000611116856103c2600160ff1b8718611383565b905060006111248383610ff8565b9a9950505050505050505050565b600080821161114057600080fd5b6000600160801b831061115557608092831c92015b600160401b831061116857604092831c92015b640100000000831061117c57602092831c92015b62010000831061118e57601092831c92015b610100831061119f57600892831c92015b601083106111af57600492831c92015b600483106111bf57600292831c92015b6002831061030d5760010192915050565b60006001607f1b608083901c11156111ee575061ffff60ef1b919050565b613fff60f01b6001600160801b03198316141561120d57506000919050565b617fff60f083901c811690811415611226575090919050565b6001600160701b03608084901c16816112425760019150611249565b600160701b175b8061125f57506001600160f01b03199392505050565b600061406f81613fff85106112855750600f9290921b9160009150613ffe1984016112c4565b60019250600160701b84106112a75784613ffe039050600f84901b93506112c4565b60006112b285611132565b607f8190039590951b9461406d039150505b836001607f1b14156112fb5782156112da576001015b60006112e582611132565b60700390508082901b9150808303925050611349565b60008361130957600061130c565b60015b60ff1690505b600160701b8210156113475793800260ff81901c607f81019190911c94600019939093019260019290921b9082180190611312565b505b806001600160701b0316607083901b8461136457600061136a565b6001607f1b5b6001600160801b0316171760801b979650505050505050565b60008061138f83611445565b12156113b15761030d6113a260016104cc565b6103f4600160ff1b8518611383565b60006113f36113c060016104cc565b6103536113cd60016104cc565b6103c76103cc6113e366083ac553a55e006104cc565b610353662386f26fc100006104cc565b9050600061140182856114ec565b905061141661141060016104cc565b82610ff8565b949350505050565b600061030d611440836f1fffb8aa3b295c17f0bbbe87fed0691d60811b61080b565b611503565b6000617fff60f083901c166140fe81111561145f57600080fd5b613fff8110156114725750600092915050565b600160701b6001600160701b03608085901c161761406f82101561149c5761406f8290031c6114ae565b61406f8211156114ae5761406e1982011b5b6001607f1b608085901c106114d857600160ff1b8111156114ce57600080fd5b6000039392505050565b6001600160ff1b038111156110cc57600080fd5b600061030a6114fa83612855565b6103c28561289d565b60006001607f1b608083901c90811190617fff60f085901c8116916001600160701b0316908214801561153557508015155b15611549575061ffff60ef1b949350505050565b61400d82111561156e578261156357617fff60f01b6101f0565b600095945050505050565b613f7f8210156115875750613fff60f01b949350505050565b81611595576001915061159c565b600160701b175b613fef8211156115b257613fee1982011b6115c4565b613fef8210156115c457613fef8290031c5b8280156115d5575061203760811b81115b156115e557506000949350505050565b821580156116045750713fffffffffffffffffffffffffffffffffff81115b156116185750617fff60f01b949350505050565b6001600160801b0381169060801c83801561163257508115155b1561163e579019906001015b6001607f1b828116156116625770016a09e667f3bcc908b2fb1366ea957d3e0260801c5b6001607e1b831615611685577001306fe0a31b7152de8d5a46305c85edec0260801c5b6001607d1b8316156116a8577001172b83c7d517adcdf7c8c50eb14a791f0260801c5b6001607c1b8316156116cb5770010b5586cf9890f6298b92b71842a983630260801c5b6001607b1b8316156116ee577001059b0d31585743ae7c548eb68ca417fd0260801c5b6001607a1b83161561171157700102c9a3e778060ee6f7caca4f7a29bde80260801c5b600160791b8316156117345770010163da9fb33356d84a66ae336dcdfa3f0260801c5b600160781b83161561175757700100b1afa5abcbed6129ab13ec11dc95430260801c5b600160771b83161561177a5770010058c86da1c09ea1ff19d294cf2f679b0260801c5b600160761b83161561179d577001002c605e2e8cec506d21bfc89a23a00f0260801c5b600160751b8316156117c057700100162f3904051fa128bca9c55c31e5df0260801c5b600160741b8316156117e3577001000b175effdc76ba38e31671ca9397250260801c5b600160731b83161561180657700100058ba01fb9f96d6cacd4b180917c3d0260801c5b600160721b8316156118295770010002c5cc37da9491d0985c348c68e7b30260801c5b600160711b83161561184c577001000162e525ee054754457d59952920260260801c5b600160701b83161561186f5770010000b17255775c040618bf4a4ade83fc0260801c5b6001606f1b831615611892577001000058b91b5bc9ae2eed81e9b7d4cfab0260801c5b6001606e1b8316156118b557700100002c5c89d5ec6ca4d7c8acc017b7c90260801c5b6001606d1b8316156118d85770010000162e43f4f831060e02d839a9d16d0260801c5b6001606c1b8316156118fb57700100000b1721bcfc99d9f890ea069117630260801c5b6001606b1b83161561191e5770010000058b90cf1e6d97f9ca14dbcc16280260801c5b6001606a1b831615611941577001000002c5c863b73f016468f6bac5ca2b0260801c5b600160691b83161561196457700100000162e430e5a18f6119e3c02282a50260801c5b600160681b831615611987577001000000b1721835514b86e6d96efd1bfe0260801c5b600160671b8316156119aa57700100000058b90c0b48c6be5df846c5b2ef0260801c5b600160661b8316156119cd5770010000002c5c8601cc6b9e94213c72737a0260801c5b600160651b8316156119f0577001000000162e42fff037df38aa2b219f060260801c5b600160641b831615611a135770010000000b17217fba9c739aa5819f44f90260801c5b600160631b831615611a36577001000000058b90bfcdee5acd3c1cedc8230260801c5b600160621b831615611a5957700100000002c5c85fe31f35a6a30da1be500260801c5b600160611b831615611a7c5770010000000162e42ff0999ce3541b9fffcf0260801c5b600160601b831615611a9f57700100000000b17217f80f4ef5aadda455540260801c5b6001605f1b831615611ac25770010000000058b90bfbf8479bd5a81b51ad0260801c5b6001605e1b831615611ae5577001000000002c5c85fdf84bd62ae30a74cc0260801c5b6001605d1b831615611b0857700100000000162e42fefb2fed257559bdaa0260801c5b6001605c1b831615611b2b577001000000000b17217f7d5a7716bba4a9ae0260801c5b6001605b1b831615611b4e57700100000000058b90bfbe9ddbac5e109cce0260801c5b6001605a1b831615611b715770010000000002c5c85fdf4b15de6f17eb0d0260801c5b600160591b831615611b94577001000000000162e42fefa494f1478fde050260801c5b600160581b831615611bb75770010000000000b17217f7d20cf927c8e94c0260801c5b600160571b831615611bda577001000000000058b90bfbe8f71cb4e4b33d0260801c5b600160561b831615611bfd57700100000000002c5c85fdf477b662b269450260801c5b600160551b831615611c205770010000000000162e42fefa3ae53369388c0260801c5b600160541b831615611c4357700100000000000b17217f7d1d351a389d400260801c5b600160531b831615611c665770010000000000058b90bfbe8e8b2d3d4ede0260801c5b600160521b831615611c89577001000000000002c5c85fdf4741bea6e77e0260801c5b600160511b831615611cac57700100000000000162e42fefa39fe95583c20260801c5b600160501b831615611ccf577001000000000000b17217f7d1cfb72b45e10260801c5b6980000000000000000000831615611cf857700100000000000058b90bfbe8e7cc35c3f00260801c5b6940000000000000000000831615611d215770010000000000002c5c85fdf473e242ea380260801c5b6920000000000000000000831615611d4a577001000000000000162e42fefa39f02b772c0260801c5b6910000000000000000000831615611d735770010000000000000b17217f7d1cf7d83c1a0260801c5b6908000000000000000000831615611d9c577001000000000000058b90bfbe8e7bdcbe2e0260801c5b6904000000000000000000831615611dc557700100000000000002c5c85fdf473dea871f0260801c5b6902000000000000000000831615611dee5770010000000000000162e42fefa39ef44d910260801c5b6901000000000000000000831615611e1757700100000000000000b17217f7d1cf79e9490260801c5b68800000000000000000831615611e3f5770010000000000000058b90bfbe8e7bce5440260801c5b68400000000000000000831615611e67577001000000000000002c5c85fdf473de6eca0260801c5b68200000000000000000831615611e8f57700100000000000000162e42fefa39ef366f0260801c5b68100000000000000000831615611eb7577001000000000000000b17217f7d1cf79afa0260801c5b68080000000000000000831615611edf57700100000000000000058b90bfbe8e7bcd6d0260801c5b68040000000000000000831615611f075770010000000000000002c5c85fdf473de6b20260801c5b68020000000000000000831615611f2f577001000000000000000162e42fefa39ef3580260801c5b600160401b831615611f525770010000000000000000b17217f7d1cf79ab0260801c5b678000000000000000831615611f79577001000000000000000058b90bfbe8e7bcd50260801c5b674000000000000000831615611fa057700100000000000000002c5c85fdf473de6a0260801c5b672000000000000000831615611fc75770010000000000000000162e42fefa39ef340260801c5b671000000000000000831615611fee57700100000000000000000b17217f7d1cf7990260801c5b6708000000000000008316156120155770010000000000000000058b90bfbe8e7bcc0260801c5b67040000000000000083161561203c577001000000000000000002c5c85fdf473de50260801c5b67020000000000000083161561206357700100000000000000000162e42fefa39ef20260801c5b67010000000000000083161561208a577001000000000000000000b17217f7d1cf780260801c5b66800000000000008316156120b057700100000000000000000058b90bfbe8e7bb0260801c5b66400000000000008316156120d65770010000000000000000002c5c85fdf473dd0260801c5b66200000000000008316156120fc577001000000000000000000162e42fefa39ee0260801c5b66100000000000008316156121225770010000000000000000000b17217f7d1cf60260801c5b6608000000000000831615612148577001000000000000000000058b90bfbe8e7a0260801c5b660400000000000083161561216e57700100000000000000000002c5c85fdf473c0260801c5b66020000000000008316156121945770010000000000000000000162e42fefa39d0260801c5b66010000000000008316156121ba57700100000000000000000000b17217f7d1ce0260801c5b658000000000008316156121df5770010000000000000000000058b90bfbe8e60260801c5b65400000000000831615612204577001000000000000000000002c5c85fdf4720260801c5b6520000000000083161561222957700100000000000000000000162e42fefa380260801c5b6510000000000083161561224e577001000000000000000000000b17217f7d1b0260801c5b6508000000000083161561227357700100000000000000000000058b90bfbe8d0260801c5b650400000000008316156122985770010000000000000000000002c5c85fdf460260801c5b650200000000008316156122bd577001000000000000000000000162e42fefa20260801c5b650100000000008316156122e25770010000000000000000000000b17217f7d00260801c5b648000000000831615612306577001000000000000000000000058b90bfbe70260801c5b64400000000083161561232a57700100000000000000000000002c5c85fdf30260801c5b64200000000083161561234e5770010000000000000000000000162e42fef90260801c5b64100000000083161561237257700100000000000000000000000b17217f7c0260801c5b6408000000008316156123965770010000000000000000000000058b90bfbd0260801c5b6404000000008316156123ba577001000000000000000000000002c5c85fde0260801c5b6402000000008316156123de57700100000000000000000000000162e42fee0260801c5b640100000000831615612402577001000000000000000000000000b17217f60260801c5b638000000083161561242557700100000000000000000000000058b90bfa0260801c5b63400000008316156124485770010000000000000000000000002c5c85fc0260801c5b632000000083161561246b577001000000000000000000000000162e42fd0260801c5b631000000083161561248e5770010000000000000000000000000b17217e0260801c5b63080000008316156124b1577001000000000000000000000000058b90be0260801c5b63040000008316156124d457700100000000000000000000000002c5c85e0260801c5b63020000008316156124f75770010000000000000000000000000162e42e0260801c5b630100000083161561251a57700100000000000000000000000000b172160260801c5b6280000083161561253c5770010000000000000000000000000058b90a0260801c5b6240000083161561255e577001000000000000000000000000002c5c840260801c5b6220000083161561258057700100000000000000000000000000162e410260801c5b621000008316156125a2577001000000000000000000000000000b17200260801c5b620800008316156125c457700100000000000000000000000000058b8f0260801c5b620400008316156125e65770010000000000000000000000000002c5c70260801c5b62020000831615612608577001000000000000000000000000000162e30260801c5b6201000083161561262a5770010000000000000000000000000000b1710260801c5b61800083161561264b577001000000000000000000000000000058b80260801c5b61400083161561266c57700100000000000000000000000000002c5b0260801c5b61200083161561268d5770010000000000000000000000000000162d0260801c5b6110008316156126ae57700100000000000000000000000000000b160260801c5b6108008316156126cf5770010000000000000000000000000000058a0260801c5b6104008316156126f0577001000000000000000000000000000002c40260801c5b610200831615612711577001000000000000000000000000000001610260801c5b610100831615612732577001000000000000000000000000000000b00260801c5b6080831615612752577001000000000000000000000000000000570260801c5b60408316156127725770010000000000000000000000000000002b0260801c5b6020831615612792577001000000000000000000000000000000150260801c5b60108316156127b25770010000000000000000000000000000000a0260801c5b60088316156127d2577001000000000000000000000000000000040260801c5b60048316156127f2577001000000000000000000000000000000010260801c5b8461281357600f81901c6001600160701b03169050613fff82019150612842565b613ffe821161283857600f81901c6001600160701b0316905081613fff039150612842565b600091613fee19011c5b60709190911b1760801b95945050505050565b600061030d612875611036600160ff1b85186103c28661035360026104cc565b61035361289861288560026104cc565b6103c26113e3666f9c9e651c44806104cc565b610e26565b600061030d6129016128b86113e3660b58c2126f49006104cc565b6103c7856103c26128de6128d56113e3660caaedbfa8a7006104cc565b600160ff1b1890565b6103c7896103c26128f86113e3663f4a728c19ce806104cc565b6103c78d612907565b8361080b565b600061030d826103c26129266128d56113e36640b43a042331006104cc565b6103c7866103c26113e3662f42c683f17c806104cc565b60006020828403121561294f57600080fd5b5035919050565b600080600080600060a0868803121561296e57600080fd5b8535801515811461297e57600080fd5b97602087013597506040870135966060810135965060800135945092505050565b6000602082840312156129b157600080fd5b81356001600160a01b03811681146110cc57600080fd5b6020808252818101527f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572604082015260600190565b634e487b7160e01b600052601160045260246000fd5b600082821015612a2557612a256129fd565b500390565b634e487b7160e01b600052601260045260246000fd5b600082612a5d57634e487b7160e01b600052601260045260246000fd5b500490565b6000816000190483118215151615612a7c57612a7c6129fd565b500290565b634e487b7160e01b600052600160045260246000fdfea26469706673582212206c862d0e308452298a5a0081ce1bf6705b0ccdfc8b2f3b4da2fdc04de9d5f52764736f6c63430008090033",
  "devdoc": {
    "kind": "dev",
    "methods": {
      "getOptionPrice(bool,uint256,uint256,uint256,uint256)": {
        "params": {
          "expiry": "expiry timestamp",
          "isPut": "is put option",
          "lastPrice": "current price",
          "strike": "strike price",
          "volatility": "volatility"
        }
      },
      "owner()": {
        "details": "Returns the address of the current owner."
      },
      "renounceOwnership()": {
        "details": "Leaves the contract without owner. It will not be possible to call `onlyOwner` functions anymore. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby removing any functionality that is only available to the owner."
      },
      "transferOwnership(address)": {
        "details": "Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner."
      },
      "updateMinOptionPricePercentage(uint256)": {
        "params": {
          "_minOptionPricePercentage": "the new %"
        },
        "returns": {
          "_0": "whether % was updated"
        }
      },
      "updateVolatilityCap(uint256)": {
        "params": {
          "_volatilityCap": "the new volatility cap"
        },
        "returns": {
          "_0": "whether volatility cap was updated"
        }
      }
    },
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {
      "getOptionPrice(bool,uint256,uint256,uint256,uint256)": {
        "notice": "computes the option price (with liquidity multiplier)"
      },
      "updateMinOptionPricePercentage(uint256)": {
        "notice": "updates % of the price of asset which is the minimum option price possible"
      },
      "updateVolatilityCap(uint256)": {
        "notice": "updates volatility cap for an option pool"
      }
    },
    "version": 1
  },
  "storageLayout": {
    "storage": [
      {
        "astId": 3344,
        "contract": "contracts/pricing/OptionPricingSimple.sol:OptionPricingSimple",
        "label": "_owner",
        "offset": 0,
        "slot": "0",
        "type": "t_address"
      },
      {
        "astId": 28925,
        "contract": "contracts/pricing/OptionPricingSimple.sol:OptionPricingSimple",
        "label": "volatilityCap",
        "offset": 0,
        "slot": "1",
        "type": "t_uint256"
      },
      {
        "astId": 28927,
        "contract": "contracts/pricing/OptionPricingSimple.sol:OptionPricingSimple",
        "label": "minOptionPricePercentage",
        "offset": 0,
        "slot": "2",
        "type": "t_uint256"
      }
    ],
    "types": {
      "t_address": {
        "encoding": "inplace",
        "label": "address",
        "numberOfBytes": "20"
      },
      "t_uint256": {
        "encoding": "inplace",
        "label": "uint256",
        "numberOfBytes": "32"
      }
    }
  }
}